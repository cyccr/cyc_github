# 2. DEMO工程说明

# 2.1. DEMO_DevKitBoard工程说明

## 2.1.1. 工程简介

* 该工程为开源板测试学习工程，主要实现了视频，音频，ui,网络，wifi,蓝牙，系统，传感器，等测试例子,为全功能工程。
* 工程例子使用方法是通过在demo_config.h文件中开启宏进行编译实现，只能开启单个宏功。（当开启多个宏时可能会导致IO冲突功能异常等情况）
* 通过全局搜索测试宏就能找到测试代码所在之处，所有测试代码均独立为上层应用代码。
* 如果需要修改app_config文件的配置会在测试代码中予以说明解释。
* 除该工程外其余demo工程均为单功能最小系统工程，由于包含了各种库因此会导致下载时间较长特别是在带ui资源文件是需要大概几十秒才能下载好，而最小系统工程下载快的就几秒就能下载好。
* JL79全系功应用均有客户使用进行研发量产，所以这个于市面上一些开发板不同之处在于我们已经完善了很多底层应用功能，能让学习者快速上手进行进行开发学习。

## 2.1.2. 板级说明

* 该板级已经完成所有的外设io配置，所有配置均模块化使用宏包住，在使用摸个模块功能时需要注意app_config.h中该功能宏有没有被开启。
* 对于新手而已看着这些配置信息吃力的话大概看下就行，通过学习测试列子慢慢熟悉就好。（刚开始大家都一样的）

## 2.1.3. 示例工程

具体的示例工程代码详见" apps/demo/demo_DevKitBoard " 。


# 2.2. DEMO_HELLO工程说明

**概述**

本工程展示了demo_hello的使用示例:

* 创建hello_demo_task线程

具体的示例工程代码详见 "apps/demo/demo_hello"。

## 2.2.1. 代码流程

1.app_main()入口：

A）打印程序运行时刻

B）创建demo_hello启动任务hello_demo_task

```
voidapp_main()
{
printf("\r\n\r\n\r\n\r\n\r\n ------------hello demo run %s-------------\r\n\r\n\r\n\r\n\r\n",__TIME__);
os_task_create(hello_demo_task,NULL,10,1000,0,"hello_demo_task");
}
```

## 2.2.2. 常见问题

* demo_hello工程是79系列最简单的demo工程，用户可以添加 `apps/common/example` 下的示例进行工程的功能增加，或者自行在此demo_hello工程上进行功能开发。


# 2.3. DEMO_WIFI工程说明

**概述**

本工程展示了使用iperf测试wifi吞吐率的使用示例:

* WIFI STA模式测试IPERF
* WIFI AP模式测试IPERF
* IPERF的上下行吞吐率测试以及参数配置

具体的示例工程代码详见 `apps/demo/demo_wifi`

## 2.3.1. WIFI框架图

![](img\1.png)

## 2.3.2. 工程配置

* app_config.h：
  > * 打开宏 #define CONFIG_WIFI_ENABLE 无线WiFi
  > * 打开宏#define CONFIG_IPERF_ENABLE iperf测试
  >
  > ```
  > #define CONFIG_WIFI_ENABLE                                      /* 无线WIFI */
  > #define CONFIG_IPERF_ENABLE                                     // iperf测试
  > ```
  >
* wifi_demo_task.c:
  > * 打开宏定义AP_MODE_TEST或者STA_MODE_TEST配置WIFI工作模式
  > * 配置AP模式和STA模式的SSID（名称）和PWD（密码）
  > * wifi_on(); 之后调用 iperf_test()
  >
  > ```
  > //选择其中一种开机默认的模式测试
  > #define AP_MODE_TEST
  > //#define STA_MODE_TEST
  > //#define MONITOR_MODE_TEST
  >
  > //#define WIFI_MODE_CYCLE_TEST //从起始测试模式开始(FORCE_DEFAULT_MODE=1)或者最后记忆模式开始((FORCE_DEFAULT_MODE=0)), 循环测试WIFI模式切换: ->AP_MODE ->STA_MODE ->MONITOR_MODE ->AP_MODE ...
  >
  > #define FORCE_DEFAULT_MODE 0 //配置wifi_on之后的模式,0为使用最后记忆的模式, 1为强制默认模式, 3-200为STA连接超时时间多少秒,如果超时都连接不上就连接最后记忆的或者最优网络
  >
  > #define AP_SSID "AC79_WIFI_DEMO_"      //配置 AP模式的SSID前缀
  > #define AP_PWD  ""                //配置 AP模式的密码
  > #define STA_SSID  "配置需要连接的路由器SSID"           //配置 STA模式的SSID
  > #define STA_PWD  "配置需要连接的路由器密码"      //配置 STA模式的密码
  > #define CONNECT_BEST_SSID  0    //配置如果啟動WIFI后在STA模式下, 是否挑选连接记忆过的信号最优WIFI
  > ```
  >

## 2.3.3. 模块依赖

* 如果只需要测试STA模式和MONITOR模式, 工程文件或者Makefile包含wl_wifi_sta.a, wpasupplicant.a
* 如果只需要测试AP模式, 工程文件或者Makefile包含wl_wifi_ap.a
* 如果STA和AP模式均要测试, 工程文件或者Makefile包含wl_wifi.a,wpasupplicant.a
* 其中wl_wifi_ap_sfc.a,wl_wifi_sta_sfc.a,wl_wifi_sfc.a为节省内存/降低性能版本的WIFI库

## 2.3.4. 代码流程

1.demo_wifi()入口：

A）创建WIFI启动任务wifi_demo_task

B）打印WIFI信号质量信息和吞吐率信息

```
static int demo_wifi(void)
{
return os_task_create(wifi_demo_task,NULL,10,1000,0,"wifi_demo_task");
}
```

2.wifi_event_callback()：

A）case WIFI_EVENT_MODULE_INIT: 配置WIFI启动前的必要配置, 例如WIFI MP测试后校准PA参数, WIFI启动前的默认模式, 配置信息等

B）case WIFI_EVENT_MODULE_START:配置WIFI启动后的配置

```
 case WIFI_EVENT_MODULE_START:
        puts("|network_user_callback->WIFI_EVENT_MODULE_START\n");

        struct wifi_mode_info info;
        info.mode = NONE_MODE;
        wifi_get_mode_cur_info(&info);
        if (info.mode == SMP_CFG_MODE) {
            net.arg = "net";
            net.event = NET_EVENT_SMP_CFG_FIRST;
            net_event_notify(NET_EVENT_FROM_USER, &net);
        }

        u32  tx_rate_control_tab = // 不需要哪个速率就删除掉,可以动态设定
            0
            | BIT(0) //0:CCK 1M
            | BIT(1) //1:CCK 2M
            | BIT(2) //2:CCK 5.5M
            | BIT(3) //3:OFDM 6M
            | BIT(4) //4:MCS0/7.2M
            | BIT(5) //5:OFDM 9M
            | BIT(6) //6:CCK 11M
            | BIT(7) //7:OFDM 12M
            | BIT(8) //8:MCS1/14.4M
            | BIT(9) //9:OFDM 18M
            | BIT(10) //10:MCS2/21.7M
            | BIT(11) //11:OFDM 24M
            | BIT(12) //12:MCS3/28.9M
            | BIT(13) //13:OFDM 36M
            | BIT(14) //14:MCS4/43.3M
            | BIT(15) //15:OFDM 48M
            | BIT(16) //16:OFDM 54M
            | BIT(17) //17:MCS5/57.8M
            | BIT(18) //18:MCS6/65.0M
            | BIT(19) //19:MCS7/72.2M
            ;
        wifi_set_tx_rate_control_tab(tx_rate_control_tab);
#if 0
        wifi_set_pwr(0); //把WIFI模拟功率调整到最低档位节电
#endif

        break;case WIFI_EVENT_MODULE_START:
puts("|network_user_callback->WIFI_EVENT_MODULE_START\n");

structwifi_mode_infoinfo;
info.mode=NONE_MODE;
wifi_get_mode_cur_info(&info);
if(info.mode==SMP_CFG_MODE){
net.arg="net";
net.event=NET_EVENT_SMP_CFG_FIRST;
net_event_notify(NET_EVENT_FROM_USER,&net);
}

u32tx_rate_control_tab=// 不需要哪个速率就删除掉,可以动态设定
0
|BIT(0)//0:CCK 1M
|BIT(1)//1:CCK 2M
|BIT(2)//2:CCK 5.5M
|BIT(3)//3:OFDM 6M
|BIT(4)//4:MCS0/7.2M
|BIT(5)//5:OFDM 9M
|BIT(6)//6:CCK 11M
|BIT(7)//7:OFDM 12M
|BIT(8)//8:MCS1/14.4M
|BIT(9)//9:OFDM 18M
|BIT(10)//10:MCS2/21.7M
|BIT(11)//11:OFDM 24M
|BIT(12)//12:MCS3/28.9M
|BIT(13)//13:OFDM 36M
|BIT(14)//14:MCS4/43.3M
|BIT(15)//15:OFDM 48M
|BIT(16)//16:OFDM 54M
|BIT(17)//17:MCS5/57.8M
|BIT(18)//18:MCS6/65.0M
|BIT(19)//19:MCS7/72.2M
;
wifi_set_tx_rate_control_tab(tx_rate_control_tab);
#if 0
        wifi_set_pwr(0); //把WIFI模拟功率调整到最低档位节电
#endif

break;
```

3.wifi_demo_task()函数流程:

A）注册WIFI事件回调函数

B）启动WIFI

C）启动IPERF测试

```
static void wifi_demo_task(void *priv)
{
    wifi_set_store_ssid_cnt(NETWORK_SSID_INFO_CNT);
    wifi_set_event_callback(wifi_event_callback);

    wifi_on();

    //wifi_on之后即可初始化服务器类型的网络应用程序
    iperf_test();
    ......
}staticvoidwifi_demo_task(void*priv)
{
wifi_set_store_ssid_cnt(NETWORK_SSID_INFO_CNT);
wifi_set_event_callback(wifi_event_callback);

wifi_on();

//wifi_on之后即可初始化服务器类型的网络应用程序
iperf_test();
......
}
```

## 2.3.5. 操作说明

* 设备端操作:
  1.编译工程，烧录镜像，复位启动
  2.系统启动后，可以通过串口软件看到示例的WIFI相关打印信息
* 手机端操作:
  1.安卓手机可安装 [Magic iPerf.apk](https://gitee.com/Jieli-Tech/fw-AC79_AIoT_SDK/tree/master/sdk_tools) ，苹果手机端在商店安装对应收费版本软件, PC端可安装 [iperf-3.1.3-win64.exe](https://gitee.com/Jieli-Tech/fw-AC79_AIoT_SDK/tree/master/sdk_tools)
  2.参考文档 [iperf3工具说明]()

## 2.3.6. 常见问题

* WIFI库选择说明:

| wl_wifi.a         | 包含AP和STA模式,占据大内存,性能强悍 |
| :---------------- | ----------------------------------- |
| wl_wifi_sfc.a     | 包含AP和STA模式,占据内存小          |
| wl_wifi_ap.a      | 只包含AP模式,占据大内存,性能强悍    |
| wl_wifi_ap_sfc.a  | 只包含AP模式,占据内存小             |
| wl_wifi_sta.a     | 只包含STA模式,占据大内存,性能强悍   |
| wl_wifi_sta_sfc.a | 只包含STA模式,占据内存小            |
| lwip.a            | 占据大内存,性能强悍                 |
| lwip_sfc.a        | 占据内存小                          |

**Important**

1. 如果需要使用STA模式，需要包含 wpasupplicant.a，仅使用AP模式不需要包含
2. WIFI API接口头文件在 wifi/wifi_connect.h

* iperf测试吞吐率一般结果为多少?
  答:AP模式下一般TX/RX速率有800KB/S-2MB/S,STA模式下一般有200KB-1MB/S
* 影响iperf测试吞吐率的因素有哪些?
  答:
  1.WIFI RF校准参数有没有进行仪器测试调整到SDK里面
  2.板子天线是否有调试好
  3.AP模式比STA模式吞吐率要高
  4.空中信道是否有比较大的干扰
  5.SDK运行过程中剩下的CPU使用率是否足够
  6.测试手机,路由器,设备,距离是否足够小
  7.使用占据资源多的高性能的WIFI库与LWIP库有利于提高吞吐率
  8.程序运行在SDRAM模式比在SFC模式吞吐率要高


# 2.4. DEMO_AUDIO工程说明

**概述**

本工程展示了：

* 1.本地播歌接口使用方法，播放SD卡、FLASH和U盘的音频文件。
* 2.网络播歌接口使用方法，在同一个局域网内，设备可通过手机DLNA进行投歌播放。
* 3.录音模块接口使用方法，将MIC、LINEIN、PLNK、IIS的数字信号采集后推到DAC播放，也可保存录音文件到SD卡或者通过DAC模拟直通。
* 4.打断唤醒使用方法，通过离线唤醒词进行唤醒

## 2.4.1. 工程配置说明

* 1.在 `<span class="pre">apps/demo/demo_audio/include/app_config.h</span>` 选择需要使用的模式功能，程序运行后通过按键进行切换模式（可通过提示音进行确认模式）

```
#define CONFIG_LOCAL_MUSIC_MODE_ENABLE      //mode:本地播放模式使能
#define CONFIG_RECORDER_MODE_ENABLE         //mode:录音模式使能

#ifdef CONFIG_NET_ENABLE
#define CONFIG_NET_MUSIC_MODE_ENABLE        //mode:网络播放模式使能
#define CONFIG_ASR_ALGORITHM_ENABLE         //mode:打断唤醒模式使能
#endif
```

* 2.对应板级文件board.c：详情查看AUDIO_ADC、AUDIO_DAC、IIS、PDM LINK等文档配置，配置dac_data、adc_data、iis0_data和plnk0_data

  ```
  //DAC配置(需要对应原理图(原理图请移步gitee)看下DAC支不支持,如AC7911BA只引出DACL,AC7916A引出DACL+DACR)

  //1. 单通道 单端 fDACL(左声道)
  static const struct dac_platform_data dac_data = {
      .pa_auto_mute = 1,              //关闭DAC不输出声音时是否自动MUTE功放  0：不mute功放 1：MUTE功放
      .pa_mute_port = 0xff,           //功放MUTE IO ，只在pa_auto_mute为1时有效
      .pa_mute_value = 1,             //MUTE电平值，只在pa_auto_mute为1时有效  0：低电平 1：高电平
      .differ_output = 0,             //是否使用差分输出模式  0：不使用 1：使用
      .hw_channel = 0x01,             //硬件DAC模拟通道
      .ch_num = 1,                        //差分只需开一个通道
      .vcm_init_delay_ms = 1000,
  #ifdef CONFIG_DEC_ANALOG_VOLUME_ENABLE
      .fade_enable = 1,               //模拟音量淡入淡出使能位
      .fade_delay_ms = 40,            //模拟音量淡入淡出延时
  #endif
  };

  #if 0   //例子,其他不相关/不修改参数不列出来

  //2. 单通道 单端 fDACR(右声道)
  static const struct dac_platform_data dac_data = {
      .differ_output = 0, //选择是否采用差分输出模式
      .hw_channel = 0x02, //BIT(0)使用DACL | BIT(1)使用DACR
      .ch_num = 1,
  };

  //3. 双通道 立体声 fDACL+fDACR(左/右声道)
  static const struct dac_platform_data dac_data = {
      .differ_output = 0, //选择是否采用差分输出模式
      .hw_channel = 0x03, //BIT(0)使用DACL | BIT(1)使用DACR
      .ch_num = 2,
  };

  //4. 双通道 差分 fDACL/fDACR(左右声道合并)
  static const struct dac_platform_data dac_data = {
      .differ_output = 1, //选择是否采用差分输出模式
      .hw_channel = 0x03, //BIT(0)使用DACL | BIT(1)使用DACR
      .ch_num = 1,        //差分只需开一个通道
  };

  //5. 四通道 差分 fDACL/fDACR+rDACL/rDACR(前后左声道合并,前后右声道合并,相当于抗干扰好一点的左/右声道)
  static const struct dac_platform_data dac_data = {
      .differ_output = 1, //选择是否采用差分输出模式
      .hw_channel = 0x0f, //BIT(0)使用fDACL | BIT(1)使用fDACR | BIT(2)使用rDACL | BIT(3)使用rDACR
      .ch_num = 2,        //差分只需开一个通道
  };

  //6. 四通道 立体声 fDACL+fDACR+rDACL+rDACR(立体环绕声)
  static const struct dac_platform_data dac_data = {
      .differ_output = 0, //选择是否采用差分输出模式
      .hw_channel = 0x0f, //BIT(0)使用fDACL | BIT(1)使用fDACR | BIT(2)使用rDACL | BIT(3)使用rDACR
      .ch_num = 4,
  };

  #endif


  //MIC/LINEIN配置(需要对应原理图(原理图请移步gitee)看下支不支持,如AC7911BA引出MIC0P/MIC0N MIC1N MIC2P/MIC2N MIC3P ,AUX0 AUX1 AUX2 AUX3)

  static const struct adc_platform_data adc_data = {
      .mic_channel = LADC_CH_MIC0_P_N, //  | LADC_CH_MIC2_P_N, //P代表硬件MIC直接正端，N代表硬件MIC只接负端，P_N代表硬件MIC采用差分接法
      .linein_channel = NULL, //LADC_CH_AUX0 | LADC_CH_AUX2,
      .mic_ch_num = 1, //整个代码运行过程中会用到多少路通道AUDIO MIC
      .linein_ch_num = 0, //整个代码运行过程中会用到多少路通道AUDIO LINEIN
      .all_channel_open = 1, //四路全开，默认打开
      .isel = 2, //电流档位选择，勿改动
      .dump_num = 480, //丢弃刚打开硬件时的数据点数
  };

  //IIS配置(移步文档《IIS(ALNK)》)

  static const struct iis_platform_data iis0_data = {
      .channel_in = 0,            //输入通道 BIT(X)
      .channel_out = BIT(0),      //输出通道 BIT(X)
      .port_sel = IIS_PORTC,      //IO组选择
      .data_width = 0,            //BIT(X)为通道X使用24bit模式，不配置的通道则使用16bit
      .mclk_output = 0,           //1:输出mclk 0:不输出mclk
      .slave_mode = 0,            //1：从机模式 0：主机模式
      .dump_points_num = 320, //丢弃刚打开硬件时的数据点数
  };

  //PLNK数字麦配置

  static void plnk0_port_remap_cb(void)//重映射函数
  {
      //重映射PDM DAT-PA2   PDM CLK-PA3     重映射的DAT脚和CLK时钟脚可根据原理图所有引脚选择
      extern int gpio_plnk_rx_input(u32 gpio, u8 index, u8 data_sel);
      gpio_plnk_rx_input(IO_PORTA_02, 0, 0);//plnk数字DAT0输入 ，当第三个参数为1时gpio_plnk_rx_input(IO_PORTA_02, 0, 0);plnk数字DAT1输入
      gpio_output_channle(IO_PORTA_01, CH0_PLNK0_SCLK_OUT);       //SCLK0使用outputchannel0
      JL_IOMAP->CON3 |= BIT(18);//PLNK0 SCLK0 输出使能，若使用PLNK1数字麦1,JL_IOMAP->CON3 |= BIT(19)
  }
  static void plnk0_port_unremap_cb(void)//解除重映射
  {
      JL_IOMAP->CON3 &= ~BIT(18); //PLNK0 SCLK0 输出失能       若使用PLNK1数字麦1，JL_IOMAP->CON3 &= ~BIT(19);
      gpio_clear_output_channle(IO_PORTA_01, CH0_PLNK0_SCLK_OUT);//释放outputchannel0
      gpio_set_die(IO_PORTA_02, 0);//数字/模拟输入切换
  }
  //plnk的时钟和数据引脚都采用重映射的使用例子
  static const struct plnk_platform_data plnk0_data = {
      .hw_channel = PLNK_CH_MIC_L,               //使用DAT0输入
      .clk_out = 1,                              // 使能时钟输出
      .port_remap_cb = plnk0_port_remap_cb,      //重映射
      .port_unremap_cb = plnk0_port_unremap_cb,  //解除重映射
      .sample_edge = 0,                          //0:下降沿采样数据  1:上升沿采样数据
      .share_data_io = 1,                        //双数字麦是否共用同一个数据输入IO
      .high_gain = 1,                            //0:-6db增益    1:0db增益
      .dc_cancelling_filter = 14,                //去直流滤波器等级0-15
      .dump_points_num = 640,                    //丢弃刚打开硬件时的数据点数
  };


  static const struct audio_pf_data audio_pf_d = {
      .adc_pf_data = &adc_data,
      .dac_pf_data = &dac_data,
      .iis0_pf_data = &iis0_data,
      .plnk0_pf_data = &plnk0_data,
  };
  static const struct audio_platform_data audio_data = {
      .private_data = (void *) &audio_pf_d,
  };
  ```

  定义宏#define CONFIG_AUDIO_ENC_SAMPLE_SOURCE //录音设备源选择

  ```
  #define AUDIO_ENC_SAMPLE_SOURCE_MIC         0 //录音输入源： 模拟MIC
  #define AUDIO_ENC_SAMPLE_SOURCE_PLNK0       1 //录音输入源：数字麦PLNK0
  #define AUDIO_ENC_SAMPLE_SOURCE_PLNK1       2 //录音输入源：数字麦PLNK1
  #define AUDIO_ENC_SAMPLE_SOURCE_IIS0        3 //录音输入源：IIS0
  #define AUDIO_ENC_SAMPLE_SOURCE_IIS1        4 //录音输入源：IIS1
  #define AUDIO_ENC_SAMPLE_SOURCE_LINEIN      5 //录音输入源：LINEIN

  #define CONFIG_AUDIO_ENC_SAMPLE_SOURCE     AUDIO_ENC_SAMPLE_SOURCE_MIC    //录音输入源选择
  ```

## 2.4.2. 工程操作说明

* 测试前请根据实际原理图配置好相应板级文件，尤其是串口打印和AUDIO ADC的对应IO口配置，还有AD按键对应阻值的配置
* 1.按键操功能：* 切换模式：KEY_MODE按键。

  * （1） 本地播歌模式：* A)暂停或继续播放：短按KEY_OK按键。
    * B)切换文件夹播放：长按KEY_OK按键。
    * C)音量增加：短按KEY_VOLUME_INC按键。
    * D)音量减小：短按KEY_VOLUME_DEC按键。
    * E)播放上一首：长按KEY_VOLUME_DEC按键。
    * F)播放下一首：长按KEY_VOLUME_INC按键。
  * （2） 网络播放模式：* A)暂停或继续播放：短按KEY_OK按键。
    * B)音量增加：短按KEY_VOLUME_INC按键。
    * C)音量减小：短按KEY_VOLUME_DEC按键。
    * D)播放上一首：长按KEY_VOLUME_DEC按键。
    * E)播放下一首：长按KEY_VOLUME_INC按键。
  * （3） 录音模式:* A)暂停或继续录音：短按KEY_OK按键。
    * B)音量增加：短按KEY_VOLUME_INC按键。
    * C)音量减小：短按KEY_VOLUME_DEC按键。
    * D)ADC模拟增益增加：长按KEY_VOLUME_INC按键。
    * E)ADC模拟增益减小：长按KEY_VOLUME_DEC按键。
    * F)模拟直通到DAC：长按KEY_OK按键。
    * G)录音到sd卡：长按KEY_MODE按键。
* 2.使用网络播放模式需要设备连上路由器，在app_config.h配置相应的路由器名称SSID和密码PWD，使用demo_DevKitBoard工程需在demo_config.h打开宏#define USE_DEMO_WIFI_TEST然后再wifi_demo_task.c中设置WIFI相应的SSID和PWD，然后打开手机里的各大音乐播放器app，点击DLNA投屏找到设备投屏。
* 3.使用本地播放模式需要插入SD卡并且卡里面有支持解码格式的歌曲文件。
* 4.使用录音模式linein输入时，使用音频线连接电脑音频输出，另一头连接AUX信号输入，连接原理图对应的IO。MIC/PLNK输入需要相应的元器件。

## 2.4.3. 代码流程

> 模式切换audio_demo_mode_switch():创建audio_app，通过app_state_machine接口使得存在多个模式,并且多个模式之间是互斥关系(非后台)的情况下, 建立多个app_state_machine切换可以使得系统资源合理利用和降低CPU的消耗。

![](img\2.png)

```
static const struct audio_app_t audio_app_table[] = {//模式切换表
#ifdef CONFIG_LOCAL_MUSIC_MODE_ENABLE   //本地播放模式
    {"FlashMusic.mp3", "local_music"},
#endif
#ifdef CONFIG_NET_MUSIC_MODE_ENABLE     //网络播放模式
    {"NetMusic.mp3", "net_music"  },
#endif
#ifdef CONFIG_RECORDER_MODE_ENABLE      //录音模式
    {"Recorder.mp3", "recorder"},
#endif
#ifdef CONFIG_ASR_ALGORITHM_ENABLE      //打断唤醒模式
    {"AiSpeaker.mp3", "ai_speaker"},
#endif
};

int audio_demo_mode_switch(void)//模式选择
{
    if (mode_index >= ARRAY_SIZE(audio_app_table)) {
        mode_index = 0;
    }
    struct intent it;

    if (get_current_app()) {
        init_intent(&it);
        it.name = audio_app_table[mode_index].app_name;
        it.action = ACTION_STOP;    //退出当前模式
        start_app(&it);
    }

    char path[64];

    sprintf(path, "%s%s", CONFIG_VOICE_PROMPT_FILE_PATH, audio_app_table[mode_index].tone_file_name);

    return app_play_tone_file(path);
}
```

## 2.4.4. 模式说明

1.本地播放模式 local_music.c

* 未挂载sd卡时播放flash内提示音资源，插sd卡播放sd中内容，详情sd挂载使用参考sd文档

> ```
> if (storage_device_ready()) {
>     return local_music_switch_local_device(CONFIG_MUSIC_PATH_SD);
> } else {
>     return local_music_switch_local_device(CONFIG_MUSIC_PATH_FLASH);
> }
> ```

* 本地播放可选择FLASH、SD卡和U盘之间切换，通过扫描文件和搜索指定音频格式进行选择解码播放，有全盘搜索播放和目录搜索播放。

```
//释放资源，切换播放源设备
static int local_music_switch_local_device(const char *path)
{//SD卡、U盘切换
    log_i("local_music_switch_local_device\n");

    if (__this->dir_list) {//搜索文件夹
        fscan_release(__this->dir_list);
        __this->dir_list = NULL;
    }
    if (__this->fscan) {//扫描文件
        fscan_release(__this->fscan);
        __this->fscan = NULL;
    }
    if (__this->wait_sd) {//等待SD卡挂载
        wait_completion_del(__this->wait_sd);
        __this->wait_sd = 0;
    }
    if (__this->wait_udisk) {//等待U盘挂载
        wait_completion_del(__this->wait_udisk);
        __this->wait_udisk = 0;
    }

    local_music_dec_stop();//播放结束

    if (path == NULL) {
        return -1;
    }

    __this->local_path = path;//播放路径

    local_music_dec_switch_dir(FSEL_FIRST_FILE);//本地播放选择文件夹

    return 0;
}
```

```
//切换文件夹
    static int local_music_dec_switch_dir(int fsel_mode)
    {
    ......
        ......
        //全盘播放
        if (__this->local_play_all && __this->local_path != CONFIG_MUSIC_PATH_FLASH) {
            //全盘搜索
            if (__this->fscan) {
                fscan_release(__this->fscan);
            }
    #if CONFIG_DEC_DECRYPT_ENABLE    //扫描相应格式文件，包含子目录-r，-t扫描文件格式 ，-sn按照按照文件号排序，扫描目录层数2
            __this->fscan = fscan(__this->local_path, "-r -tMP3WMAWAVM4AAMRAPEFLAAACSPXOPUDTSADPSMP -sn", 2);
    #else
            __this->fscan = fscan(__this->local_path, "-r -tMP3WMAWAVM4AAMRAPEFLAAACSPXOPUDTSADP -sn", 2);
    #endif
            ......
            return local_music_dec_switch_file(FSEL_FIRST_FILE);//切换歌曲
        }

        //搜索文件夹
        if (!__this->dir_list) {
            __this->dir_list = fscan(__this->local_path, "-d -sn", 2);//扫描根目录文件夹
            .......
        }

        //选择文件夹
    __again:
        do {
            dir = fselect(__this->dir_list, fsel_mode, 0);//选择文件夹
            if (dir) {
                i++;
                break;
            }
            if (fsel_mode == FSEL_NEXT_FILE) {//选择模式下一个文件
                fsel_mode = FSEL_FIRST_FILE; //最开始文件开始
            } else if (fsel_mode == FSEL_PREV_FILE) { //选择模式上一个文件
                fsel_mode = FSEL_LAST_FILE; //最后一个文件开始
            } else {
                log_w("fselect_dir_faild, create dir\n");
                return -1;
            }
        } while (i++ < __this->dir_list->file_number);//通过文件号选择文件

    ........
        .......

        len = fget_name(dir, (u8 *)name, sizeof(name) - 1);//获取文件名长度
        ........
        .......
        }

        fclose(dir);


        fname_to_path(path, __this->local_path, name, len, 1, 0);

    #if 0   //此处播放指定目录，用户填写的目录路径要注意中文编码问题，看不懂就直接用16进制把路径打印出来
        const char *user_dir = "";  //指定目录
        if (!file && strcmp(path, user_dir)) {
            log_i("dir name : %s\n", path);
            if (fsel_mode == FSEL_FIRST_FILE) {
                fsel_mode = FSEL_NEXT_FILE;
            } else if (fsel_mode == FSEL_LAST_FILE) {
                fsel_mode = FSEL_PREV_FILE;
            }
            goto __again;
        }
    #endif

        /*搜索文件夹下的音频文件，按序号排序*/
    #if CONFIG_DEC_DECRYPT_ENABLE   //扫描相应格式文件，包含子目录-r，-t扫描文件格式 ，-sn按照按照文件号排序，扫描目录层数2
        __this->fscan = fscan(path, "-tMP3WMAWAVM4AAMRAPEFLAAACSPXOPUDTSADPSMP -sn", 2);
    #else
        __this->fscan = fscan(path, "-tMP3WMAWAVM4AAMRAPEFLAAACSPXOPUDTSADP -sn", 2);
    #endif

        if (!file) {
            if (!__this->fscan || !__this->fscan->file_number) {
                if (fsel_mode == FSEL_FIRST_FILE) {//选择模式下一个文件
                    fsel_mode = FSEL_NEXT_FILE;//最开始文件开始
                } else if (fsel_mode == FSEL_LAST_FILE) {//选择模式上一个文件
                    fsel_mode = FSEL_PREV_FILE;//最后一个文件开始
                }
                goto __again;
            }
            local_music_dec_switch_file(FSEL_FIRST_FILE);//切换歌曲
        }

        return 0;
    }
```

2.网络播歌 net_music.c

* 通过ai_server平台服务器使用DLNA功能，在同一个局域网内可通过手机app支持的DLNA功能将手机上的音频投放到设备上播放。

```
#define CONFIG_DLNA_SDK_ENABLE              //打开DLNA音乐播放功能
```

![](img/3.png)

3.录音模式 recorder.c

```
/****************打开解码DAC器*******************/
    req.dec.cmd             = AUDIO_DEC_OPEN;
    req.dec.volume          = __this->volume;
    req.dec.output_buf_len  = 4 * 1024;
    req.dec.channel         = channel;
    req.dec.sample_rate     = sample_rate;
    req.dec.vfs_ops         = &recorder_vfs_ops;
    req.dec.dec_type                = "pcm";
    req.dec.sample_source   = CONFIG_AUDIO_DEC_PLAY_SOURCE;
    req.dec.file            = (FILE *)&__this->save_cbuf;
    /* req.dec.attr            = AUDIO_ATTR_LR_ADD; */          //左右声道数据合在一起,封装只有DACL但需要测试两个MIC时可以打开此功能

    err = server_request(__this->dec_server, AUDIO_REQ_DEC, &req);
    if (err) {
        goto __err;
    }

    req.dec.cmd = AUDIO_DEC_START;
    server_request(__this->dec_server, AUDIO_REQ_DEC, &req);
```

* 将MIC的数字信号采集后推到DAC播放，注意：如果需要播放两路MIC，DAC分别对应的是DACL和DACR，要留意芯片封装是否有DACR引脚出来， 而且要使能DAC的双通道输出，DAC如果采用差分输出方式也只会听到第一路MIC的声音。
* 录音打开解码器

```
/****************打开编码器*******************/
    memset(&req, 0, sizeof(union audio_req));

    //BIT(x)用来区分上层需要获取哪个通道的数据
    if (channel == 2) {
        req.enc.channel_bit_map = BIT(CONFIG_AUDIO_ADC_CHANNEL_L) | BIT(CONFIG_AUDIO_ADC_CHANNEL_R);//如BIT(0) 对应的是MIC0 BIT(1)对应的是MIC1
    } else {
        req.enc.channel_bit_map = BIT(CONFIG_AUDIO_ADC_CHANNEL_L);
    }
    req.enc.frame_size = sample_rate / 100 * 4 * channel;   //收集够多少字节PCM数据就回调一次fwrite
    req.enc.output_buf_len = req.enc.frame_size * 3; //底层缓冲buf至少设成3倍frame_size
    req.enc.cmd = AUDIO_ENC_OPEN;
    req.enc.channel = channel;
    req.enc.volume = __this->gain;
    req.enc.sample_rate = sample_rate;
    req.enc.format = "pcm";
    req.enc.sample_source = __this->sample_source;
    req.enc.vfs_ops = &recorder_vfs_ops;
    req.enc.file = (FILE *)&__this->save_cbuf;
    if (channel == 1 && !strcmp(__this->sample_source, "mic") && (sample_rate == 8000 || sample_rate == 16000)) {
        req.enc.use_vad = 1; //打开VAD断句功能
        req.enc.dns_enable = 1; //打开降噪功能
        req.enc.vad_auto_refresh = 1; //VAD自动刷新
    }

    err = server_request(__this->enc_server, AUDIO_REQ_ENC, &req);
    if (err) {
        goto __err1;
    }
```

* 录音打开编码器

```
/****************打开编码器*******************/
memset(&req,0,sizeof(unionaudio_req));

//BIT(x)用来区分上层需要获取哪个通道的数据
if(channel==2){
req.enc.channel_bit_map=BIT(CONFIG_AUDIO_ADC_CHANNEL_L)|BIT(CONFIG_AUDIO_ADC_CHANNEL_R);//如BIT(0) 对应的是MIC0 BIT(1)对应的是MIC1
}else{
req.enc.channel_bit_map=BIT(CONFIG_AUDIO_ADC_CHANNEL_L);
}
req.enc.frame_size=sample_rate/100*4*channel;//收集够多少字节PCM数据就回调一次fwrite
req.enc.output_buf_len=req.enc.frame_size*3;//底层缓冲buf至少设成3倍frame_size
req.enc.cmd=AUDIO_ENC_OPEN;
req.enc.channel=channel;
req.enc.volume=__this->gain;
req.enc.sample_rate=sample_rate;
req.enc.format="pcm";
req.enc.sample_source=__this->sample_source;
req.enc.vfs_ops=&recorder_vfs_ops;
req.enc.file=(FILE*)&__this->save_cbuf;
if(channel==1&&!strcmp(__this->sample_source,"mic")&&(sample_rate==8000||sample_rate==16000)){
req.enc.use_vad=1;//打开VAD断句功能
req.enc.dns_enable=1;//打开降噪功能
req.enc.vad_auto_refresh=1;//VAD自动刷新
}

err=server_request(__this->enc_server,AUDIO_REQ_ENC,&req);
if(err){
goto__err1;
}
```

* MIC或者LINEIN模拟直通到DAC，不需要软件参与。
* 因为AUDIO ADC数字模块上的使用限制，例如在使用通道2的时候，数字通道0和1一定要打开，所以在多路AD复用的情况下，建议把四路数字通道都打开，驱动里会自动分离各个通道的数据，具体使用方法如下：

请求enc_server 打开时需要增加参数req.enc.channel_bit_map = BIT(x)，x代表要使用的哪一个通道。注意，如果上面的配置all_channel_open = 0，一定要将所有req.enc.channel_bit_map = 0;

AUDIO ADC多路复用使用过程中，若想动态调整增益，取值范围是0-100，需要使用该函数void adc_multiplex_set_gain(const char [*](https://doc.zh-jieli.com/AC79/zh-cn/master/project_template/demo/demo_audio.html#id5)source, u8 channel_bit_map, u8 gain)， source 取值”mic”或者”linein”。

* 录音到SD卡

```
//录音文件到SD卡
static int recorder_to_file(int sample_rate, u8 channel)
{
    union audio_req req = {0};

    __this->run_flag = 1;
    __this->direct = 0;

    char time_str[64] = {0};
    char file_name[100] = {0};
    u8 dir_len = 0;
    struct tm timeinfo = {0};
    time_t timestamp = time(NULL) + 28800;
    localtime_r(&timestamp, &timeinfo);
    strcpy(time_str, CONFIG_ROOT_PATH"RECORDER/\\U");
    dir_len = strlen(time_str);
    strftime(time_str + dir_len, sizeof(time_str) - dir_len, "%Y-%m-%dT%H-%M-%S.wav", &timeinfo);
    log_i("recorder file name : %s\n", time_str);

    memcpy(file_name, time_str, dir_len);

    for (u8 i = 0; i < strlen(time_str) - dir_len; ++i) {
        file_name[dir_len + i * 2] = time_str[dir_len + i];
    }

    req.enc.cmd = AUDIO_ENC_OPEN;
    req.enc.channel = channel;
    req.enc.volume = __this->gain;
    req.enc.frame_size = 8192;
    req.enc.output_buf_len = req.enc.frame_size * 10;
    req.enc.sample_rate = sample_rate;
    req.enc.format = "wav";
    req.enc.sample_source = __this->sample_source;
    req.enc.msec = CONFIG_AUDIO_RECORDER_DURATION;
    req.enc.file = __this->fp = fopen(file_name, "w+");
    /* req.enc.sample_depth = 24; //IIS支持采集24bit深度 */
    if (channel == 4) {
        req.enc.channel_bit_map = 0x0f;
    } else if (channel == 2) {
        req.enc.channel_bit_map = BIT(CONFIG_AUDIO_ADC_CHANNEL_L) | BIT(CONFIG_AUDIO_ADC_CHANNEL_R);
    } else {
        req.enc.channel_bit_map = BIT(CONFIG_AUDIO_ADC_CHANNEL_L);
    }

    return server_request(__this->enc_server, AUDIO_REQ_ENC, &req);
}
```

4.打断唤醒模式

* 打断唤醒使用方法，通过打断唤醒算法通过唤醒词进行唤醒
* 详情查看AISP打断唤醒文档

## 2.4.5. 编解码流程

* 详情请查看音频编解码文档AUDIO_ENC和AUDIO_DEC



# 2.5. DEMO_BLE工程说明

**概述**

本工程展示了使用蓝牙BLE分别充当主从机进行数据传输测试功能和mesh功能。

> * 1.从机 数传
> * 2.主机 client角色
> * 3.多机通讯
> * 4.mesh测试demo

具体的示例工程代码详见  `apps/demo/demo_ble `。

## 2.5.1. 工程配置说明

`apps/demo/demo_ble/include/app_config.h`

* A)打开宏 #define TCFG_USER_BLE_ENABLE BLE功能使能
* B)BLE DEMO模式选择：选择需要打开的测试用例置1，同时只能选择一项

> 打开宏 #define TRANS_DATA_EN 1 从机模式 数传
>
> 打开宏 #define BT_NET_CENTRAL_EN 1 主机模式 client角色 搜寻连接其它BLE从机
>
> 打开宏 #define TRANS_MULTI_BLE_EN 1 多机通讯（支持多个主机和从机同时运行）
>
> 打开宏 #define CONFIG_BLE_MESH_ENABLE 1 mesh组网测试demo

```
//*********************************************************************************//
//                                  BT_BLE配置                                     //
//*********************************************************************************//
#ifdef CONFIG_BT_ENABLE

#define CONFIG_BT_RX_BUFF_SIZE  0
#define CONFIG_BT_TX_BUFF_SIZE  0

#define TCFG_USER_BLE_ENABLE                      1     //BLE功能使能
#define TCFG_USER_BT_CLASSIC_ENABLE               0     //经典蓝牙功能

#if TCFG_USER_BLE_ENABLE
//BLE DEMO选择
#define BT_NET_HID_EN                             0     //从机 hid
#define TRANS_DATA_EN                             1     //从机 传输数据
#define BT_NET_CENTRAL_EN                         0     //主机 client角色
#define TRANS_MULTI_BLE_EN                        0     //多机通讯
#define CONFIG_BLE_MESH_ENABLE                    0     //mesh测试demo

#if (TRANS_MULTI_BLE_EN + BT_NET_HID_EN + BT_NET_CENTRAL_EN + TRANS_DATA_EN  + CONFIG_BLE_MESH_ENABLE > 1)
#error "they can not enable at the same time,just select one!!!"
#endif
```

## 2.5.2. 操作说明：

* 1.从机模式通过手机app（nrf connect）（扫描、发现、连接低功耗蓝牙设备的应用）连接到设备BLE的JL-AC79XXble

![](img\4.png)

对已经连接的蓝牙ble设备进行trans_data传输数据，进行写write，读read,通知notify等操作。

![](img\5.png)

* 2.主机模式：主动通过搜索去连接其它BLE从机设备用户需要填写以下过滤规则，填写不匹配会出现一直连接不上或者通讯失败的情况，需要指定搜索对应profile的uuid。

```
 //ble.c
#if BT_NET_CENTRAL_EN || TRANS_MULTI_BLE_MASTER_NUMS

//用户需要填写以下过滤规则，填写错误会出现一直连接不上的情况
//指定搜索uuid
static const target_uuid_t search_uuid_table[] = {

    // for uuid16
    // PRIMARY_SERVICE, ae80
    // CHARACTERISTIC,  ae81, WRITE_WITHOUT_RESPONSE | DYNAMIC,
    // CHARACTERISTIC,  ae82, NOTIFY,

    {
        .services_uuid16 = 0xae80,
        .characteristic_uuid16 = 0xae81,
        .opt_type = ATT_PROPERTY_WRITE_WITHOUT_RESPONSE,
    },

    {
        .services_uuid16 = 0xae80,
        .characteristic_uuid16 = 0xae82,
        .opt_type = ATT_PROPERTY_NOTIFY,
    },

    {
        .services_uuid16 = 0xae00,  //  6901A
        .characteristic_uuid16 = 0xae01,
        .opt_type = ATT_PROPERTY_WRITE_WITHOUT_RESPONSE,
    },

    {
        .services_uuid16 = 0xae00,  //  6901A
        .characteristic_uuid16 = 0xae01,
        .opt_type = ATT_PROPERTY_NOTIFY,
    },

    //for uuid128,sample
    //      PRIMARY_SERVICE, 0000F530-1212-EFDE-1523-785FEABCD123
    //      CHARACTERISTIC,  0000F531-1212-EFDE-1523-785FEABCD123, NOTIFY,
    //      CHARACTERISTIC,  0000F532-1212-EFDE-1523-785FEABCD123, WRITE_WITHOUT_RESPONSE | DYNAMIC,
    /*
        {
            .services_uuid16 = 0,
            .services_uuid128 =       {0x00,0x00,0xF5,0x30 ,0x12,0x12 ,0xEF, 0xDE ,0x15,0x23 ,0x78,0x5F,0xEA ,0xBC,0xD1,0x23} ,
            .characteristic_uuid16 = 0,
            .characteristic_uuid128 = {0x00,0x00,0xF5,0x31 ,0x12,0x12 ,0xEF, 0xDE ,0x15,0x23 ,0x78,0x5F,0xEA ,0xBC,0xD1,0x23},
            .opt_type = ATT_PROPERTY_NOTIFY,
        },

        {
            .services_uuid16 = 0,
            .services_uuid128 =       {0x00,0x00,0xF5,0x30 ,0x12,0x12 ,0xEF, 0xDE ,0x15,0x23 ,0x78,0x5F,0xEA ,0xBC,0xD1,0x23} ,
            .characteristic_uuid16 = 0,
            .characteristic_uuid128 = {0x00,0x00,0xF5,0x32 ,0x12,0x12 ,0xEF, 0xDE ,0x15,0x23 ,0x78,0x5F,0xEA ,0xBC,0xD1,0x23},
            .opt_type = ATT_PROPERTY_WRITE_WITHOUT_RESPONSE,
        },
    */
```

* 3.多机通讯：支持多个主机和从机角色同时运行。设备当从机时候，主机连接成功设备以后要开启通知notify之后，设备才会打开新的广播让额外设备进行连接。多机通讯从机模式：bt_multi_trans_init(); ble多机从机数传z`

  多机通讯主机模式：bt_multi_client_init(); ble多机主机数传

```
//app_config.h
#if TRANS_MULTI_BLE_EN
#define TRANS_MULTI_BLE_SLAVE_NUMS                2  //最大从机数
#define TRANS_MULTI_BLE_MASTER_NUMS               2  //最大主机数
#endif

//le_multi_common.h
#define SUPPORT_MAX_SERVER       TRANS_MULTI_BLE_SLAVE_NUMS
#define SUPPORT_MAX_CLIENT       TRANS_MULTI_BLE_MASTER_NUMS

//le_multi_common.c
void bt_ble_init(void)
{
    int error_reset = 0;
    //log_info("%s,%d\n", __FUNCTION__, __LINE__);
    //log_info("ble_file: %s", __FILE__);

    /*确认配置是否ok*/

    if (config_le_hci_connection_num && att_send_check_multi_dev(config_le_gatt_server_num, config_le_gatt_client_num)) {
        log_info("no support more device!!!\n");
        error_reset = 1;
    }

    if (error_reset) {
        printf("======error config!!!\n");
        ASSERT(0);
        while (1);
    }

#if SUPPORT_MAX_SERVER
    bt_multi_trans_init();
#endif

#if SUPPORT_MAX_CLIENT
    bt_multi_client_init();
#endif
}
```

* 4.mesh组网测试demo：蓝牙Mesh网络是用于建立多对多（many：many）设备通信的低能耗蓝牙（Bluetooth Low Energy，也称为Bluetooth LE）的网络拓扑，网络中包含的蓝牙设备之间可以相互进行信息的传递。在 `<span class="pre">apps/common/ble/mesh/model_api.h</span>` 选择对应的mesh测试用例

测试APP操作如下：

[![](img\111.gif)](https://doc.zh-jieli.com/AC79/zh-cn/master/_images/111.gif) [![](img\222.gif)](https://doc.zh-jieli.com/AC79/zh-cn/master/_images/222.gif)

## 2.5.3. 代码流程

* 1.app_main()，调用bt_ble_module_init()进行蓝牙BLE协议栈初始化

```
//app_main.c
/*
* 应用程序主函数
*/
voidapp_main()
{
puts("------------- demo_ble app main-------------\n");

externvoidbt_ble_module_init(void);
bt_ble_module_init();
}
```

* 2.bt_ble_module_init()

> A) 调用bt_max_pwr_set()函数设置蓝牙最大发射功率(0-11)。
>
> B) 调用bt_get_mac_addr()函数获取蓝牙mac地址。
>
> C) 调用lib_make_ble_address()函数根据提供的edr地址生成唯一对应ble地址。
>
> D) 调用le_controller_set_mac()函数设置ble的public地址。
>
> E) 调用btstack_init()函数进行蓝牙协议栈初始化。

```
//ble.c
void bt_ble_module_init(void)
{
    void lmp_set_sniff_disable(void);
    lmp_set_sniff_disable();

#if TCFG_USER_BLE_ENABLE
    u8 tmp_ble_addr[6];
    extern const u8 *bt_get_mac_addr(void);
    extern void lib_make_ble_address(u8 * ble_address, u8 * edr_address);
    extern int le_controller_set_mac(void *addr);
    lib_make_ble_address(tmp_ble_addr, (u8 *)bt_get_mac_addr());
    le_controller_set_mac((void *)tmp_ble_addr);
    printf("\n-----edr + ble 's address-----");
    put_buf((void *)bt_get_mac_addr(), 6);
    put_buf((void *)tmp_ble_addr, 6);
#if BT_NET_CENTRAL_EN || TRANS_MULTI_BLE_MASTER_NUMS
    extern void ble_client_config_init(void);
    ble_client_config_init();
#endif
#endif

    btstack_init();
}
```

* 3.BLE各个测试用例的初始化入口

```
//ble.c
static int bt_connction_status_event_handler(struct bt_event *bt)
{
    switch (bt->event) {
    case BT_STATUS_INIT_OK:
#if TRANS_MULTI_BLE_EN   //多机通讯
        bt_ble_init();
#else

#if BT_NET_CENTRAL_EN    //主机模式
        extern void bt_master_ble_init(void);
        bt_master_ble_init();
#endif
#if TRANS_DATA_EN       //从机模式
        bt_ble_init();
#endif
#if BT_NET_HID_EN     //从机hid
        extern void ble_module_enable(u8 en);
        extern void ble_hid_set_config(void);
        ble_hid_set_config();
        bt_ble_init();
#endif
#if CONFIG_BLE_MESH_ENABLE  //mesh组网
        extern void bt_ble_mesh_init(void);
        bt_ble_mesh_init();
#endif

#endif
        break;
    }

    return 0;
}
```

4.ble_report_data_deal()，主机模式下处理接收到的数据

```
//ble.c
static void ble_report_data_deal(att_data_report_t *report_data, const target_uuid_t *search_uuid)
{
    log_i("report_data:%02x,%02x,%d,len(%d)", report_data->packet_type,
        report_data->value_handle, report_data->value_offset, report_data->blob_length);

    put_buf(report_data->blob, report_data->blob_length);

    //处理接收数据

    switch (report_data->packet_type) {
    case GATT_EVENT_NOTIFICATION:  //notify
        break;

    case GATT_EVENT_INDICATION://indicate
    case GATT_EVENT_CHARACTERISTIC_VALUE_QUERY_RESULT://read
        break;

    case GATT_EVENT_LONG_CHARACTERISTIC_VALUE_QUERY_RESULT://read long
        break;

    default:
        break;
    }
}
```

5.主机模式下发送测试数据

```
//ble.c
static void client_event_callback(le_client_event_e event, u8 *packet, int size)
{
    switch (event) {
    case CLI_EVENT_MATCH_DEV:
        log_i("match_name:%s\n", ((client_match_cfg_t *)packet)->compare_data);
        break;

    case CLI_EVENT_MATCH_UUID:
        ;
        opt_handle_t *opt_hdl = (opt_handle_t *)packet;
        if (opt_hdl->search_uuid == &search_uuid_table[0]) {
            ble_client_write_handle = opt_hdl->value_handle;
            log_i("match_uuid\n");
        }
        break;

    case CLI_EVENT_SEARCH_PROFILE_COMPLETE:
        log_i("CLI_EVENT_SEARCH_PROFILE_COMPLETE\n");
        //可以开始发送数据
#if TRANS_MULTI_BLE_MASTER_NUMS
        for (int i = 0; i < TRANS_MULTI_BLE_MASTER_NUMS; i++) {
            u16 tmp_handle = mul_dev_get_conn_handle(i, MULTI_ROLE_CLIENT);
            if (tmp_handle) {
                ble_client_api->opt_comm_send_ext(tmp_handle, ble_client_write_handle, (u8 *)test_data, sizeof(test_data), ATT_OP_WRITE_WITHOUT_RESPOND);
            }
        }
#else
        //发送测试数据
        if (ble_client_write_handle) {
            ble_client_api->opt_comm_send(ble_client_write_handle, (u8 *)test_data, sizeof(test_data), ATT_OP_WRITE_WITHOUT_RESPOND);
        }
#endif
        break;

    case CLI_EVENT_CONNECTED:
        break;

    case CLI_EVENT_DISCONNECT:
        ble_client_write_handle = 0;
        break;

    default:
        break;
    }
}
```




# 2.6. DEMO_EDR工程说明

**概述**

本工程展示了使用蓝牙EDR进行播歌和通话测试的使用示例。

* 1.实现蓝牙EDR播歌中暂停播放、上下曲、音量增减等功能。
* 2.实现蓝牙EDR通话中接听和挂断电话，音量增减等功能。
* 3.实现蓝牙发射功能。
* 4.实现spp数据传输功能。

具体的示例工程代码详见 `apps/demo/demo_edr `。

## 2.6.1. 工程配置说明

`apps/demo/demo_edr/app_config`

```
#define CONFIG_POWER_ON_ENABLE_BT                 1     //开机自动打开经典蓝牙
#define TCFG_USER_BT_CLASSIC_ENABLE               1     //经典蓝牙功能
#define TCFG_USER_BLE_ENABLE                      0     //BLE功能使能
#define TCFG_USER_EMITTER_ENABLE                  1     //蓝牙发射功能
```

* 修改蓝牙初始名称user_cfg.c：
* 可修改bt_get_local_name()中edr_name：JL-AC79XX。
* 在bt_get_pin_code()函数修改设备返回的pin code。
* 如有特殊需求，可在bt_get_mac_addr()函数修改设备的蓝牙mac地址。

```
const char *bt_get_local_name(void)
{
#ifndef CONFIG_RF_TEST_ENABLE
    const u8 *mac_addr;
    mac_addr = bt_get_mac_addr();
    sprintf(edr_name, "JL-AC79XX-%02X%02X", mac_addr[4], mac_addr[5]);//修改edr_name
#endif
    return edr_name;
}

const char *bt_get_pin_code(void)
{
    return pincode;
}

const u8 *bt_get_mac_addr(void)
{
    static u8 mac_addr[6];

#if defined CONFIG_WIFI_ENABLE && !defined CONFIG_RF_TEST_ENABLE
    wifi_get_mac(mac_addr);
    if (bytecmp(mac_addr, 0, 6)) {
        return mac_addr;
    } else
#endif
    {
        if (syscfg_read(CFG_BT_MAC_ADDR, mac_addr, 6) == 6) {
            return mac_addr;
        }

        u8 flash_uid[16];
        memcpy(flash_uid, get_norflash_uuid(), 16);
        do {
            u32 crc32 = rand32()^CRC32(flash_uid, sizeof(flash_uid));
            u16 crc16 = rand32()^CRC16(flash_uid, sizeof(flash_uid));
            memcpy(mac_addr, &crc32, sizeof(crc32));
            memcpy(&mac_addr[4], &crc16, sizeof(crc16));
        } while (!bytecmp(mac_addr, 0, 6));
        //此处用户可自行修改为本地生成mac地址的算法
        mac_addr[0] &= ~((1 << 0) | (1 << 1));
        syscfg_write(CFG_BT_MAC_ADDR, mac_addr, 6);
        return mac_addr;
    }
}
```

## 2.6.2. 操作说明：

按键功能：查看bt_music.c中bt_music_key_event_handler()

* 1.播歌模式

> A ) 暂停或播放：KEY_OK按键。
>
> B ) 音量增大：短按KEY_VOLUME_INC按键。
>
> C ) 音量减小：短按KEY_VOLUME_DEC按键。
>
> D ) 播放上一首：长按KEY_VOLUME_DEC按键。
>
> E ) 播放下一首：长按KEY_VOLUME_INC按键。

* 2.通话模式

> A ) 接听或挂断电话：KEY_OK按键。
>
> B ) 音量增大：短按KEY_VOLUME_INC按键。
>
> C ) 音量减小：短按KEY_VOLUME_DEC按键。

* 3.发射模式

长按KEY_MODE按键切换到蓝牙发射模式，进行设备搜索并根据过滤规则连接指定设备。

* 4.通过spp数传app进行开发板与手机之间的数据传输。发送间隔2ms，sent_len长度660，速率最快150Kbytes。底层限制了每次发送的最大长度，当sent_len超过660时受限制。
* 5.关闭或打开蓝牙，短按KEY_MODE按键。切换蓝牙到发射或者接收模式，长按KEY_MODE按键。

## 2.6.3. 代码流程

* 1.app_main()，调用bt_ble_module_init()进行蓝牙BR协议栈初始化

```
//app_main.c
 /*
 * 应用程序主函数
 */
 void app_main()
 {
     puts("------------- demo_edr app main-------------\n");

     extern void bt_ble_module_init(void);
     bt_ble_module_init();
 }
```

* 2.bt_ble_module_init()

> A ) 调用bt_function_select_init()函数进行经典蓝牙功能配置，包括音量是否同步、是否连接自动播放、是否定时更新电量、回连搜索超时、蓝牙加密等级和蓝牙设备类型等功能。
>
> B ) 调用bredr_handle_register()函数进行协议栈回调函数注册，包括SPP数传数据回调、蓝牙音量同步接口回调、电量显示获取电量的接口、被测试盒链接上进入快速测试回调、样机进入dut被测试仪器链接上回调、获取远端设备蓝牙名字回调、获取歌曲信息回调、发射器设置回调等。
>
> C ) 调用btstack_init()函数进行蓝牙协议栈初始化。
>
> D ) 调用sys_auto_sniff_controle()函数进行自动进入sniff低功耗模式，空闲5s之后进入sniff模式。
>
> E ) bt_connction_status_event_handler()函数负责处理协议栈连接、加密、媒体播放、通话等各种状态的回调。
>
> F ) bt_hci_event_handler()函数负责处理协议栈各种HCI事件的回调。

```
void bt_ble_module_init(void)
{
    bt_function_select_init();
    bredr_handle_register();
    btstack_init();
}

static void bt_function_select_init(void)
{
    __this->media_volume = INIT_VOLUME_VALUE;
    __this->call_volume = INIT_VOLUME_VALUE;

    __set_a2dp_auto_play_flag(1); /* 连接高级音频后自动播放歌曲 */
    __set_support_msbc_flag(1);
#if TCFG_BT_SUPPORT_AAC
    __set_support_aac_flag(1);
#endif
#if BT_SUPPORT_DISPLAY_BAT
    __bt_set_update_battery_time(60);
#else
    __bt_set_update_battery_time(0);
#endif
    __set_page_timeout_value(8000); /*回连搜索时间长度设置,可使用该函数注册使用，ms单位,u16*/
    __set_super_timeout_value(8000); /*回连时超时参数设置。ms单位。做主机有效*/

    __set_simple_pair_flag(1); //是否打开简易配对功能，打开后不需要输入pincode
    ////设置蓝牙加密的level
    //io_capabilities ; /*0: Display only 1: Display YesNo 2: KeyboardOnly 3: NoInputNoOutput*/
    //authentication_requirements: 0:not protect  1 :protect
    __set_simple_pair_param(3, 0, 2);

#if (USER_SUPPORT_PROFILE_PBAP==1)
    ////设置蓝牙设备类型
    __change_hci_class_type(BD_CLASS_CAR_AUDIO);
#endif

#if (TCFG_BT_SNIFF_ENABLE == 0)
    void lmp_set_sniff_disable(void);
    lmp_set_sniff_disable();
#endif
}

static void bredr_handle_register(void)
{
#if USER_SUPPORT_PROFILE_SPP
    extern void user_spp_data_handler(u8 packet_type, u16 ch, u8 * packet, u16 size);
    spp_data_deal_handle_register(user_spp_data_handler);
#endif

#if BT_SUPPORT_MUSIC_VOL_SYNC
    ///蓝牙音乐和通话音量同步
    music_vol_change_handle_register(bt_set_music_device_volume, phone_get_device_vol);
#endif
#if BT_SUPPORT_DISPLAY_BAT
    ///电量显示获取电量的接口
    get_battery_value_register(bt_get_battery_value);   /*电量显示获取电量的接口*/
#endif
    ///被测试盒链接上进入快速测试回调
    /* bt_fast_test_handle_register(bt_fast_test_api); */

    ///样机进入dut被测试仪器链接上回调
    bt_dut_test_handle_register(bt_dut_api);

    ///获取远端设备蓝牙名字回调
    read_remote_name_handle_register(bt_read_remote_name);

    ////获取歌曲信息回调
    /* bt_music_info_handle_register(user_get_bt_music_info); */

#if TCFG_USER_EMITTER_ENABLE
    ////发射器设置回调等
    inquiry_result_handle_register(emitter_search_result);
#endif
}voidbt_ble_module_init(void)
{
bt_function_select_init();
bredr_handle_register();
btstack_init();
}

staticvoidbt_function_select_init(void)
{
__this->media_volume=INIT_VOLUME_VALUE;
__this->call_volume=INIT_VOLUME_VALUE;

__set_a2dp_auto_play_flag(1);/* 连接高级音频后自动播放歌曲 */
__set_support_msbc_flag(1);
#if TCFG_BT_SUPPORT_AAC
__set_support_aac_flag(1);
#endif
#if BT_SUPPORT_DISPLAY_BAT
__bt_set_update_battery_time(60);
#else
__bt_set_update_battery_time(0);
#endif
__set_page_timeout_value(8000);/*回连搜索时间长度设置,可使用该函数注册使用，ms单位,u16*/
__set_super_timeout_value(8000);/*回连时超时参数设置。ms单位。做主机有效*/

__set_simple_pair_flag(1);//是否打开简易配对功能，打开后不需要输入pincode
////设置蓝牙加密的level
//io_capabilities ; /*0: Display only 1: Display YesNo 2: KeyboardOnly 3: NoInputNoOutput*/
//authentication_requirements: 0:not protect  1 :protect
__set_simple_pair_param(3,0,2);

#if (USER_SUPPORT_PROFILE_PBAP==1)
////设置蓝牙设备类型
__change_hci_class_type(BD_CLASS_CAR_AUDIO);
#endif

#if (TCFG_BT_SNIFF_ENABLE == 0)
voidlmp_set_sniff_disable(void);
lmp_set_sniff_disable();
#endif
}

staticvoidbredr_handle_register(void)
{
#if USER_SUPPORT_PROFILE_SPP
externvoiduser_spp_data_handler(u8packet_type,u16ch,u8*packet,u16size);
spp_data_deal_handle_register(user_spp_data_handler);
#endif

#if BT_SUPPORT_MUSIC_VOL_SYNC
///蓝牙音乐和通话音量同步
music_vol_change_handle_register(bt_set_music_device_volume,phone_get_device_vol);
#endif
#if BT_SUPPORT_DISPLAY_BAT
///电量显示获取电量的接口
get_battery_value_register(bt_get_battery_value);/*电量显示获取电量的接口*/
#endif
///被测试盒链接上进入快速测试回调
/* bt_fast_test_handle_register(bt_fast_test_api); */

///样机进入dut被测试仪器链接上回调
bt_dut_test_handle_register(bt_dut_api);

///获取远端设备蓝牙名字回调
read_remote_name_handle_register(bt_read_remote_name);

////获取歌曲信息回调
/* bt_music_info_handle_register(user_get_bt_music_info); */

#if TCFG_USER_EMITTER_ENABLE
////发射器设置回调等
inquiry_result_handle_register(emitter_search_result);
#endif
}
```

* 3.transport_spp_init()函数，初始化spp传输初始化

```
//bt_music.c
static int bt_connction_status_event_handler(struct bt_event *bt)
{
    log_i("-----------------------bt_connction_status_event_handler %d\n", bt->event);

    switch (bt->event) {
    case BT_STATUS_INIT_OK:
        /*
        * 蓝牙初始化完成
        */
        log_i("===================BT_STATUS_INIT_OK\n");
#if SPP_TRANS_DATA_EN
        extern void transport_spp_init(void);
        transport_spp_init();
#endif
        bt_connection_enable();
        break;
```

* 4.蓝牙发射功能(bt_emitter.c)：蓝牙发射搜索结果回调处理，根据过滤规则可以做名字过滤、地址过滤、自定义过滤和无限制规则，也可以保存搜索到的所有设备再选择一个进行连接。

> 提供按键切换发射器或者接收器功能：2:发射 1：接收 0: 关闭。
>
> 发射器设置回调包括设备名字name、设备名字长度len、设备类型class和设备信号强度rssi等。

```
//bt_music.c的bt_music_key_event_handler()长按KEY_MODE切换发射器和接收器
case KEY_MODE:
#if TCFG_USER_EMITTER_ENABLE
            //发射器或者接收器切换
            if (__this->enable) {
                if (__this->emitter) {
                    bt_emitter_disable();
                } else {
                    key_event_disable();
                    bt_connection_disable();
                    sys_timeout_add(NULL, bt_emitter_enable, 1000);
                }
            }
#endif
            break;

//bt_emitter.c
#define  SEARCH_BD_ADDR_LIMITED 0  //搜索蓝牙地址过滤
#define  SEARCH_BD_NAME_LIMITED 1  //搜索蓝牙名称过滤
#define  SEARCH_CUSTOM_LIMITED  2  //自定义搜索
#define  SEARCH_NULL_LIMITED    3  //没有指定限制，则搜到什么就连接什么

#define SEARCH_LIMITED_MODE  SEARCH_BD_NAME_LIMITED

//地址过滤
#if (SEARCH_LIMITED_MODE == SEARCH_BD_ADDR_LIMITED)
static const u8 bd_addr_filt[][6] = {
    {0x8E, 0xA7, 0xCA, 0x0A, 0x5E, 0xC8}, /*S10_H*/
    {0xA7, 0xDD, 0x05, 0xDD, 0x1F, 0x00}, /*ST-001*/
    {0xE9, 0x73, 0x13, 0xC0, 0x1F, 0x00}, /*HBS 730*/
    {0x38, 0x7C, 0x78, 0x1C, 0xFC, 0x02}, /*Bluetooth*/
};

/*----------------------------------------------------------------------------*/
/**@brief    蓝牙发射搜索通过地址过滤
@param    无
@return   无
@note
*/
/*----------------------------------------------------------------------------*/
static u8 search_bd_addr_filt(const u8 *addr)
{
    log_i("bd_addr:");
    put_buf(addr, 6);

    for (u8 i = 0; i < (sizeof(bd_addr_filt) / sizeof(bd_addr_filt[0])); i++) {
        if (memcmp(addr, bd_addr_filt[i], 6) == 0) {
            /* printf("bd_addr match:%d\n", i); */
            return TRUE;
        }
    }
    /*log_i("bd_addr not match\n"); */
    return FALSE;
}
#endif

//名称过滤
#if (SEARCH_LIMITED_MODE == SEARCH_BD_NAME_LIMITED)
#if 0
static const u8 bd_name_filt[][32] = {
    "BeMine",
    "EDIFIER CSR8635",/*CSR*/
    "JL-BT-SDK",/*Realtek*/
    "I7-TWS",/*ZKLX*/
    "TWS-i7",/*ZKLX*/
    "I9",/*ZKLX*/
    "小米小钢炮蓝牙音箱",/*XiaoMi*/
    "小米蓝牙音箱",/*XiaoMi*/
    "XMFHZ02",/*XiaoMi*/
    "JBL GO 2",
    "i7mini",/*JL tws AC690x*/
    "S08U",
    "AI8006B_TWS00",
    "S046",/*BK*/
    "AirPods",
    "CSD-TWS-01",
    "AC692X_wh",
    "JBL GO 2",
    "JBL Flip 4",
    "BT Speaker",
    "CSC608",
    "QCY-QY19",
    "Newmine",
    "HT1+",
    "S-35",
    "T12-JL",
    "Redmi AirDots_R",
    "Redmi AirDots_L",
    "AC69_Bluetooth",
    "FlyPods 3",
    "MNS",
    "Jam Heavy Metal",
    "Bluedio",
    "HR-686",
    "BT MUSIC",
    "BW-USB-DONGLE",
    "S530",
    "XPDQ7",
    "MICGEEK Q9S",
    "S10_H",
    "S10",/*JL AC690x*/
    "S11",/*JL AC460x*/
    "HBS-730",
    "SPORT-S9",
    "Q5",
    "IAEB25",
    "T5-JL",
    "MS-808",
    "LG HBS-730",
    "NG-BT07"
};
#else
static const u8 bd_name_filt[][30] = {
    "JL-AC79XX-AF0B",
    "JL-AC79XX-AAFF",
};
#endif

/*----------------------------------------------------------------------------*/
/**@brief    蓝牙发射搜索通过名字过滤
@param    无
@return   无
@note
*/
/*----------------------------------------------------------------------------*/
u8 search_bd_name_filt(const char *data, u8 len, u32 dev_class, char rssi)
{
    char bd_name[64] = {0};

    if ((len > (sizeof(bd_name))) || (len == 0)) {
        return FALSE;
    }

    memcpy(bd_name, data, len);
    log_i("name:%s,len:%d,class %x ,rssi %d\n", bd_name, len, dev_class, rssi);

    for (u8 i = 0; i < (sizeof(bd_name_filt) / sizeof(bd_name_filt[0])); i++) {
        if (memcmp(data, bd_name_filt[i], len) == 0) {
            log_i("\n*****find dev ok******\n");
            return TRUE;
        }
    }

    return FALSE;
}
#endif

/*----------------------------------------------------------------------------*/
/**@brief    蓝牙发射搜索结果回调处理
@param    name : 设备名字
            name_len: 设备名字长度
            addr:   设备地址
            dev_class: 设备类型
            rssi:   设备信号强度
@return   无
@note
            蓝牙设备搜索结果，可以做名字/地址过滤，也可以保存搜到的所有设备
            在选择一个进行连接，获取其他你想要的操作。
            返回TRUE，表示搜到指定的想要的设备，搜索结束，直接连接当前设备
            返回FALSE，则继续搜索，直到搜索完成或者超时
*/
/*----------------------------------------------------------------------------*/
u8 emitter_search_result(char *name, u8 name_len, u8 *addr, u32 dev_class, char rssi)
{
    if (emitter_or_receiver != BT_EMITTER_EN) {
        return 0;
    }

#if (SEARCH_LIMITED_MODE == SEARCH_BD_NAME_LIMITED)
    if (name == NULL) {
        struct inquiry_noname_remote *remote = zalloc(sizeof(struct inquiry_noname_remote));
        remote->match = 0;
        remote->class = dev_class;
        remote->rssi = rssi;
        memcpy(remote->addr, addr, 6);
        os_mutex_pend(&mutex, 0);
        list_add_tail(&remote->entry, &inquiry_noname_list);
        if (read_name_start == 0) {
            read_name_start = 1;
            user_send_cmd_prepare(USER_CTRL_READ_REMOTE_NAME, 6, addr);
        }
        os_mutex_post(&mutex);
    }
#endif

#if (SEARCH_LIMITED_MODE == SEARCH_BD_NAME_LIMITED)
    return search_bd_name_filt(name, name_len, dev_class, rssi);
#endif

#if (SEARCH_LIMITED_MODE == SEARCH_BD_ADDR_LIMITED)
    return search_bd_addr_filt(addr);
#endif

#if (SEARCH_LIMITED_MODE == SEARCH_CUSTOM_LIMITED)
    /*以下为搜索结果自定义处理*/
    char bt_name[63] = {0};
    u8 len;
    if (name_len == 0) {
        log_i("No_eir\n");
    } else {
        len = (name_len > 63) ? 63 : name_len;
        /* display bd_name */
        memcpy(bt_name, name, len);
        log_i("name:%s,len:%d,class %x ,rssi %d\n", bt_name, name_len, dev_class, rssi);
    }

    /* display bd_addr */
    put_buf(addr, 6);

    /* You can connect the specified bd_addr by below api      */
    //user_send_cmd_prepare(USER_CTRL_START_CONNEC_VIA_ADDR,6,addr);

    return FALSE;
#endif

#if (SEARCH_LIMITED_MODE == SEARCH_NULL_LIMITED)
    /*没有指定限制，则搜到什么就连接什么*/
    return TRUE;
#endif
}
```


# 2.7. DEMO_UI工程说明

## 2.7.1. 工程简介

* 杰理79系列没有硬件图层概念，我们通过软件实现了一个图层的定义，可以做到在显示UI界面的同时显示摄像头图像数据，具体代码在文件夹te_driver下同时在显示摄像头图像时支持无撕裂线显示和无顿挫感（vga图像最高支持320*240 30fps）。
* 杰理UI支持强大的文本显示功能及Windows能显示的字库UI都支持显示。（具体查看JL字库生成工具）`ui_project/字库文件/font_tool` 。
* demo_ui工程为最小ui系统工程，该工程主要用于测试ui函数，测试ui列子，用于ui学习开发使用，该工程主要包含了4个主要要的UI库文件ui.a,res.a,font.a,ui_draw.a。
* 该工程添加了多个测试例子例如ui_demo_1_0主要是基本控件测试demo,通过该工程的 `<span class="pre">app_config.h</span>` 就能看到（如果有开源板可以添加测试文件进行测试需要注意的是测试例子对应着某个UI工程需要点击该ui工程生成资源文件，同事还需要更改ename.h对应的信息每个ui工程中均有对应的ename.h文件点击生成资源文件时批处理会替换掉工程的ename.h文件。）
* 测试例子展示了基本的控件使用，例如图片控件，文本控件，数字控件等等，以及字库的使用。
* 如果自己画板，请参考提供的原理图进行绘制，避免一些接口冲突问题。

## 2.7.2. 示例工程

具体的示例工程代码详见 ``apps/demo/demo_ui `` 。



# 2.8. DEMO_VIDEO工程说明

## 2.8.1. 工程简介

* 该工程主要用于视频方面的测试，为视频的最小系统框架。

## 2.8.2. 示例工程

具体的示例工程代码详见 [`apps/demo/demo_video`](https://doc.zh-jieli.com/AC79/zh-cn/master/project_template/demo/demo_video.html#id5) 



# 2.9. DEMO_UVC工程说明

## 2.9.1. 工程简介

* 该工程主要演示UVC设备使用的示例。

## 2.9.2. 工程配置说明

1.在 `apps/demo/demo_uvc/UVC/user_video_rec.c` 在user_video_rec0_open(void)函数中配置视频的相关参数

> ```
> #ifdef CONFIG_UVC_VIDEO2_ENABLE
> req.rec.uvc_id = uvc_host_online();
> #endif
>
> #ifdef CONFIG_VIDEO_REC_PPBUF_MODE
> req.rec.bfmode = VIDEO_PPBUF_MODE;
> #endif
> #ifdef  CONFIG_VIDEO_SPEC_DOUBLE_REC_MODE
> req.rec.wl80_spec_mode = VIDEO_WL80_SPEC_DOUBLE_REC_MODE; //wl80硬件限制的特殊模式
> #endif
> req.rec.picture_mode = 0;//非绘本模式
>
> req.rec.camera_type =VIDEO_CAMERA_UVC;// 摄像头类型;
> req.rec.channel = 1;
> req.rec.width       = CONFIG_USER_VIDEO_WIDTH;//摄像头的分辨率
> req.rec.height      = CONFIG_USER_VIDEO_HEIGHT;//摄像头的分辨率
> req.rec.state       = VIDEO_STATE_START;//视频状态
> req.rec.fpath       = CONFIG_REC_PATH_0;//储存的地方
> /*req.rec.format    = NET_VIDEO_FMT_AVI;*/
> req.rec.format      = USER_VIDEO_FMT_AVI; //视频格式
> req.rec.quality = VIDEO_LOW_Q;//VIDEO_MID_Q;//图片质量高中低
> req.rec.fps = 0;  //需要录的帧率
> req.rec.real_fps = 15;//帧率
>
> //需要音频：请写audio.sample_rate和audio.buf、audio.buf_len
> req.rec.audio.sample_rate = 0;//8000 音频采样率
> req.rec.audio.channel       = 1;
> req.rec.audio.channel_bit_map = 0;
> req.rec.audio.volume    = 64;//音频增益0-100
> req.rec.audio.buf = NULL;//音频BUFF
> req.rec.audio.buf_len = 0;//音频BUFF长度
>
> req.rec.abr_kbps = user_video_rec_get_abr(req.rec.width);//JPEG图片码率
> req.rec.buf = __this_user->user_video_buf;
> req.rec.buf_len = USER_VIDEO_SBUF_SIZE;
> req.rec.block_done_cb = 0;
> ```

## 2.9.3. 工程操作说明

* 测试前请根据实际原理图配置好相应板级文件，尤其是串口打印的对应IO口配置，还有AD按键对应阻值的配置。
* UVC设备插在开源版背面的USB2.0 type-c接口。
* 如果使用途中拔出了UVC设备，显示屏黑屏了。重新插入UVC设备后可以按下K4按键恢复显示。
* 按键操作说明：* K1：拍照
  * K2：录像模式：按下的第一下是开始录像 ，再一次就是停止录像。
  * K4：UVC设备重新上线后恢复LCD显示。

## 2.9.4. 代码流程

* platform_initcall(ui_demo_task_init)A）创建任务ui_demo
* ui_demo()A）在函数camera_to_lcd_init()中调用uvc_video_test()创建任务uvc_video_task
* uvc_video_task()1.在这里不断地循环检测UVC设备是否在线

  2.检测到UVC设备上线，就打开视频解码等服务和注册回调函数。

  3.若UVC设备断开就关闭视频解码等服务，等待UVC设备重新上线。

## 2.9.5. 示例工程

具体的示例工程代码详见 `apps/demo/demo_uvc`

---
