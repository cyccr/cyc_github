# 3. Wi-Fi部分

# 3.1. AC79 Wi-Fi 说明

## 3.1.1. AC79 Wi-Fi 功能列表

* 兼容IEEE802.11b/g/n标准
* 支持802.11N MCS0~7,数据传输率最高到72.2Mbps
* 支持仅 station 模式（即 STA 模式或 Wi-Fi 客户端模式），此时 AC79 连接到接入点 (AP)
* 支持仅 AP 模式（即 Soft-AP 模式或接入点模式），此时基站连接到 AC79
* 支持WPA、WPA2 及 WEP 等安全模式
* 支持 AMPDU、HT40(AC791系列支持)、QoS
* station 模式下支持低功耗休眠
* 扫描接入点（包括主动扫描及被动扫描）
* 支持混杂模式监听 IEEE802.11 Wi-Fi 数据包

## 3.1.2. AC79 Wi-Fi 编程模型

AC79 Wi-Fi 编程模型如下图所示：

![](img\43.png)

Wi-Fi 驱动程序可以看作是和上层代码（如 TCP/IP 堆栈、应用程序任务等）隔离的组件,通常用户应用程序代码负责调用Wi-Fi初始化以及必要的配置, 然后Wi-Fi 驱动程序接收并处理 API请求的数据，并将相关事件通知到到应用程序去处理.

## 3.1.3. AC79 Wi-Fi 事件描述

> `include_lib/net/wifi/wifi_connect.h` 描述了所有的 WIFI_EVENT ,每个事件会统一发送到用户注册的回调函数 wifi_set_event_callback ,下面具体说明每个事件的具体意义以及用户代码需要作出的响应

**WIFI_EVENT_MODULE_INIT**

Wi-Fi驱动初始化前配置,接收到此事件后用户需要配置Wi-Fi工作模式,例如STA模式连接的SSID和密码, AP模式SSID,IP网关地址等

**WIFI_EVENT_MODULE_START**

Wi-Fi驱动启动成功后的事件,通常不需做任何响应

**WIFI_EVENT_MODULE_STOP**

Wi-Fi驱动关闭成功后的事件,通常不需做任何响应

**WIFI_EVENT_STA_START**

Wi-Fi驱动STA模式启动成功后的事件,通常不需做任何响应

**WIFI_EVENT_STA_STOP**

Wi-Fi驱动STA模式停止后的事件,通常不需做任何响应

**WIFI_EVENT_STA_SCAN_COMPLETED**

扫描完成事件,通常由STA模式连接过程中扫描空中所有信道完成或者用户调用wifi_sta_scan_once请求扫描触发的事件,接收到此事件后，应用程序的事件回调函数可以调用wifi_get_scan_result获取扫描结果

**WIFI_EVENT_STA_CONNECT_SUCC**

STA 已成功连接目标 AP的事件，接收到此事件后，Wi-Fi 驱动程序根据应用程序响应返回结果决定是否启动 DHCP 客户端服务并开始获取 IP 地址,还是说使用静态IP地址

**WIFI_EVENT_STA_CONNECT_TIMEOUT_NOT_FOUND_SSID**

连接目标 AP超时事件,原因是超时时间内扫描不到指定SSID,超时时间应用程序可以通过wifi_set_sta_connect_timeout接口配置

**WIFI_EVENT_STA_CONNECT_TIMEOUT_ASSOCIAT_FAIL**

连接目标 AP超时失败事件,原因是超时时间内关联失败,通常原因是密码错误,或者距离太远/干扰太多导致通信失败

**WIFI_EVENT_STA_DISCONNECT**

STA模式下与AP断开事件,此事件将在以下情况下产生:

* Wi-Fi station 已成功连接至 AP的情况下调用了wifi_enter_ap_mode,wifi_enter_sta_mode,wifi_enter_smp_cfg_mode,wifi_off函数触发
* Wi-Fi 连接因为某些原因而中断，例如：由于信号太差,station 连续多次丢失 太多 beacon帧、AP 脱离 station 连接、AP 验证模式改变等

接收到此事件后，通常需要通知针对基于套接字编写的客户端应用程序关闭套接字.如果此事件不是用户期待的,可以调用wifi_enter_sta_mode进行重新连接

**WIFI_EVENT_STA_NETWORK_STACK_DHCP_SUCC**

当 DHCP 客户端成功从 DHCP 服务器获取 IP 地址，将引发此事件, 意味着应用程序可以获取到设备IP地址,并且可以创建套接字连接服务器

**WIFI_EVENT_STA_NETWORK_STACK_DHCP_TIMEOUT**

当 Wi-Fi station 已成功连接至 AP, 但是DHCP 客户端在指定超时时间内未能够从 DHCP 服务器获取 IP地址，将引发此事件, 通常情况下是由于距离远信号不好,空间干扰大导致的,应用程序可以调用lwip_set_dhcp_timeout设定超时时间,默认不指定为15秒. 引发事件后lwip协议栈内部会不断重试获取 IP地址

**WIFI_EVENT_AP_START**

Wi-Fi驱动AP模式启动成功后的事件,通常不需做任何响应

**WIFI_EVENT_AP_STOP**

Wi-Fi驱动AP模式停止后的事件,通常不需做任何响应

**WIFI_EVENT_AP_ON_ASSOC**

在AP模式下,每当有一个 station 成功连接时，将引发此事件,接收到此事件后，应用程序的回调函数可以直接获取已连接 STA 的MAC地址,和通过wifi_get_sta_entry_rssi获取已连接 STA 的RSSI等。

**WIFI_EVENT_AP_ON_DISCONNECTED**

AP模式下与 station离开事件,此事件将在以下情况下产生:

* Wi-Fi station 已成功连接至 AC79 AP的情况下调用了wifi_enter_ap_mode,wifi_enter_sta_mode,wifi_enter_smp_cfg_mode,wifi_off函数,或者调用wifi_disconnect_station仅断开指定mac地址的station端
* Wi-Fi 连接因为某些原因而中断，例如：由于信号太差,AP太长时间没有接收到station的数据包
* station 主动断开与 AP79 AP 之间的连接

发生此事件时，应用程序的事件回调函数通常需执行一些操作，例如通过dhcps_get_ipaddr获取到离开的station 并且关闭与此 station 相关的套接字等

**WIFI_EVENT_SMP_CFG_START**

Wi-Fi驱动混杂模式启动成功后的事件,通常不需做任何响应,此事件也是意味着,AirKiss配网功能的启动

**WIFI_EVENT_SMP_CFG_STOP**

Wi-Fi驱动混杂模式停止后的事件,通常不需做任何响应

**WIFI_EVENT_SMP_CFG_TIMEOUT**

Wi-Fi驱动混杂模式模式下在指定超时时间内获取不到配网信息的事件,应用程序可以通过wifi_set_smp_cfg_timeout配置超时时间,默认为无限超时时间

**WIFI_EVENT_SMP_CFG_COMPLETED**

Wi-Fi驱动混杂模式下AirKiss配网功能获取到结果引发的事件,通常用户在配网情况下触发此事件,应用程序可以在此事件后获取配网结果信息

**WIFI_FORCE_MODE_TIMEOUT**

若应用程序在WIFI_EVENT_MODULE_INIT事件下配置wifi_set_default_mode的force参数为3-200以内,并且默认配置STA模式下启动,那么在force参数代表的超时时间内未连接上AP,将引发此事件.通常用于给用户配置一个默认连接的SSID,方便客户调试使用, 发生此事件时，一般需要切换到配网模式或者连接其他AP

**WIFI_EVENT_P2P_XXX**

Wi-Fi驱动P2P模式暂时不做说明

## 3.1.4. AC79 Wi-Fi station 模式下正常连接场景示例

![](img\44.png)

**1.Wi-Fi初始化阶段**

* 1.1 app任务调用wifi_set_event_callback注册Wi-Fi事件回调接口, 然后调用wifi_on接口启动Wi-Fi

**2.Wi-Fi配置阶段**

* 2.1 Wi-Fi进入启动流程以后,首先引发WIFI_EVENT_MODULE_INIT事件
* 2.2 用户需要在WIFI_EVENT_MODULE_INIT事件下进行WIFI初始化前的一些配置,例如没记忆的情况下默认进入的WIFI模式,例如如果用户配置默认WIFI模式为配网模式,那么设备首次启动WIFI后进入配网模式,在设备使用过程中如果应用程序调用 wifi_store_mode_info覆盖默认配置为station模式,那么下次启动WIFI后设备就进入station模式.

**3.Wi-Fi启动阶段**

* 3.1 Wi-Fi驱动引发WIFI_EVENT_MODULE_START事件
* 3.2 用户可以在WIFI_EVENT_MODULE_START事件下进行WIFI初始化后的一些配置,例如WIFI的通信速率选择,也可以获取到当前WIFI进入了什么模式
* 3.3 初始化 LwIP 协议栈
* 3.4 此时Wi-Fi事件回调函数可以通知应用程序WIFI启动完成,可以启动网络应用程序任务,同时此刻也是wifi_on接口退出返回的时候

**4.Wi-Fi连接阶段**

* 4.1 Wi-Fi驱动程序启动后根据最后记忆的配置(模式,SSID,密码等)进入对应的模式,这里默认为STA模式
* 4.2 Wi-Fi驱动引发WIFI_EVENT_STA_START事件,代表Wi-Fi驱动内部启动扫描/连接过程
* 4.3 Wi-Fi驱动引发WIFI_STA_SCAN_COMPLETED事件,代表Wi-Fi驱动已经扫描完空中的信道
* 4.4 连接上AP后,Wi-Fi驱动引发WIFI_STA_CONNECT_SUCC事件
* 4.5 Wi-Fi事件回调函数将事件WIFI_STA_CONNECT_SUCC发送到应用程序任务

**5.Wi-Fi获取IP地址阶段**

* 5.1 启动LWIP协议栈的DHCP客户端获取IP地址
* 5.2 获取IP地址成功后,将引发WIFI_EVENT_STA_NETWPRK_STACK_DHCP_SUCC事件
* 5.3 Wi-Fi事件回调函数将事件WIFI_EVENT_STA_NETWPRK_STACK_DHCP_SUCC发送到应用程序任务
* 5.4 此时应用程序可以启动创建 TCP/UDP 套接字进行连接服务器的动作

## 3.1.5. AC79 Wi-Fi station 模式下断开连接场景示例

![](img\45.png)

**1.Wi-Fi断开阶段**

* 1.1 Wi-Fi station 已成功连接至 AP的情况下,应用程序调用wifi_enter_ap_mode,wifi_enter_sta_mode,wifi_enter_smp_cfg_mode,wifi_off函数引发主动断开WIFI的动作
* 1.2 当 Wi-Fi 因为主动断开、AP 离线、RSSI 较弱等原因断开连接，Wi-Fi事件回调函数将引发WIFI_EVENT_STA_DISCONNECTED事件
* 1.3 Wi-Fi事件回调函数将事件WIFI_EVENT_STA_DISCONNECTED发送到应用程序任务处理
* 1.4 应用程序接收到网络断开事件后,进行网络应用程序的清除,例如关闭TCP/UDP客户端套接字等
* 1.5 通常由于不期待的原因导致Wi-Fi 断开, 应用程序会重新调用wifi_enter_sta_mode重新连接Wi-Fi

## 3.1.6. AC79 Wi-Fi station 模式下关闭Wi-Fi场景示例

![](img\46.png)

**1.Wi-Fi关闭阶段**

* 1.1 Wi-Fi station 已成功连接至 AP的情况下,应用程序调用wifi_off函数主动关闭Wi-Fi
* 1.2 Wi-Fi事件回调函数引发WIFI_EVENT_STA_DISCONNECTED事件,如果wifi_off函数是在WIFI_EVENT_STA_DISCONNECTED事件后才被调用的,则直接进入到1.5阶段
* 1.3 Wi-Fi事件回调函数将事件WIFI_EVENT_STA_DISCONNECTED发送到应用程序任务
* 1.4 应用程序接收到网络断开事件后,进行网络应用程序的清除,例如关闭TCP/UDP客户端套接字等
* 1.5 Wi-Fi事件回调函数引发WIFI_EVENT_STA_STOP事件,代表退出STA模式
* 1.6 Wi-Fi事件回调函数将事件WIFI_EVENT_STA_STOP发送到应用程序任务
* 1.7 Wi-Fi事件回调函数引发WIFI_EVENT_MODULE_STOP事件,代表WIFI模块已经关闭完成
* 1.8 Wi-Fi事件回调函数将事件WIFI_EVENT_MODULE_STOP发送到应用程序任务

## 3.1.7. AC79 Wi-Fi AP 模式下场景示例

![](img\47.png)

**1.Wi-Fi初始化阶段**

* 1.1 app任务调用wifi_set_event_callback注册Wi-Fi事件回调接口, 然后调用wifi_on接口启动Wi-Fi

**2.Wi-Fi配置阶段**

* 2.1 Wi-Fi进入启动流程以后,首先引发WIFI_EVENT_MODULE_INIT事件
* 2.2 应用程序需要在此调用wifi_set_lan_setting_info配置IP地址网关信息和DHCP池起始分配地址
* 2.3 用户需要在WIFI_EVENT_MODULE_INIT事件下进行WIFI初始化前的一些配置,例如没记忆的情况下默认进入的WIFI模式(SSID,PWD),例如如果用户配置默认WIFI模式为AP模式(SSID为AC79_WIFI_DEMO_, PWD为空),那么设备首次启动WIFI后进入此AP模式,在设备使用过程中如果应用程序调用 wifi_store_mode_info覆盖默认配置为AP模式(SSID为"AC79_WIFI_CAMERA", PWD为"12345678"),那么下次启动WIFI后设备就进入此AP模式. 需要注意的是,如果AP模式需要配置默认的SSID和MAC地址相关,需要在这里调用init_net_device_mac_addr产生/得到MAC地址.

**3.Wi-Fi启动阶段**

* 3.1 Wi-Fi驱动引发WIFI_EVENT_MODULE_START事件
* 3.2 用户可以在WIFI_EVENT_MODULE_START事件下进行WIFI初始化后的一些配置,例如WIFI的通信速率选择,过滤数据帧类型,也可以获取到当前WIFI进入了什么模式
* 3.3 初始化 LwIP 协议栈
* 3.4 此时Wi-Fi事件回调函数可以通知应用程序WIFI启动完成,可以启动网络应用程序任务,同时此刻也是wifi_on接口退出返回的时候

**4.AP启动阶段**

* 4.1 Wi-Fi驱动引发WIFI_EVENT_AP_START事件,代表Wi-Fi驱动内部AP模式已经启动,空中可以搜索到热点
* 4.2 Wi-Fi事件回调函数将事件WIFI_EVENT_AP_START发送到应用程序任务

**5.Wi-Fi连接阶段**

* 5.1 当有stasion成功连接到AC79 Wi-Fi 的时候,引发WIFI_EVENT_AP_ON_ASSOC事件,此时可以获取到stasion端的mac地址,以及RSSI等信息
* 5.2 Wi-Fi事件回调函数将事件WIFI_EVENT_AP_ON_ASSOC发送到应用程序任务

**6.Wi-Fi分配IP地址阶段**

* 6.1 通常stasion成功连接到AC79 Wi-Fi后,会启用DHCP客户端请求IP地址,此时AC79的DHCP服务器会从IP地址池分配IP给stasion,由于DHCP协议为UDP协议,因此有可能因为RSSI 较弱的原因stasion端获取IP地址失败,而AC79 Wi-Fi得不到事件通知.
  另外AC79的DHCP服务器会针对依次接入的stasion端依次递增分配IP地址,并且对同一个mac地址的stasion端分配相同的IP地址

## 3.1.8. AC79 Wi-Fi AP 模式下断开连接场景示例

![](img\48.png)

**1.Wi-Fi断开阶段**

* 1.1 当Wi-Fi station端已成功连接至 AC79 AP的情况下,应用程序调用wifi_enter_ap_mode,wifi_enter_sta_mode,wifi_enter_smp_cfg_mode,wifi_off函数引发主动断开WIFI的动作,或者调用wifi_disconnect_station仅断开指定mac地址的station端
* 1.2 当 Wi-Fi 因为主动断开、station端 离开、RSSI 较弱等原因断开连接，Wi-Fi事件回调函数将引发WIFI_EVENT_AP_ON_DISCONNECTED事件
* 1.3 Wi-Fi事件回调函数将事件WIFI_EVENT_AP_ON_DISCONNECTED发送到应用程序任务处理
* 1.4 应用程序接收到station端网络断开事件后,进行网络应用程序的清除,通过dhcps_get_ipaddr获取到离开的station 并且关闭与此 station 相关的套接字等

## 3.1.9. AC79 Wi-Fi AP 模式下关闭Wi-Fi场景示例

![](img\49.png)

**1.Wi-Fi关闭阶段**

* 1.1 当Wi-Fi station端已成功连接至 AC79 AP的情况下,应用程序调用wifi_off函数主动关闭Wi-Fi
* 1.2 Wi-Fi事件回调函数引发WIFI_EVENT_AP_STOP事件
* 1.3 Wi-Fi事件回调函数将事件WIFI_EVENT_AP_STOP发送到应用程序任务
* 1.4 应用程序接收到WIFI_EVENT_AP_STOP事件后,进行网络应用程序的清除,关闭与所有 station 端相关的套接字等
* 1.5 Wi-Fi事件回调函数引发WIFI_EVENT_MODULE_STOP事件,代表WIFI模块已经关闭完成
* 1.6 Wi-Fi事件回调函数将事件WIFI_EVENT_MODULE_STOP发送到应用程序任务

## 3.1.10. AC79 Wi-Fi 配网模式下场景示例

![](img\50.png)

**1.Wi-Fi初始化阶段**

* 1.1 app任务调用wifi_set_event_callback注册Wi-Fi事件回调接口, 然后调用wifi_on接口启动Wi-Fi

**2.Wi-Fi配置阶段**

* 2.1 Wi-Fi进入启动流程以后,首先引发WIFI_EVENT_MODULE_INIT事件
* 2.2 用户需要在WIFI_EVENT_MODULE_INIT事件下进行WIFI初始化前的一些配置,例如没记忆的情况下默认进入的WIFI模式,例如如果用户配置默认WIFI模式为配网模式,那么设备首次启动WIFI后进入此配网模式,在设备使用过程中如果应用程序调用 wifi_store_mode_info覆盖默认配置为STA模式,那么下次启动WIFI后设备就进入STA模式

**3.Wi-Fi启动阶段**

* 3.1 Wi-Fi驱动引发WIFI_EVENT_MODULE_START事件
* 3.2 用户可以在WIFI_EVENT_MODULE_START事件下进行WIFI初始化后的一些配置,例如WIFI的通信速率选择,过滤数据帧类型,也可以获取到当前WIFI进入了什么模式
* 3.3 初始化 LwIP 协议栈
* 3.4 此时Wi-Fi事件回调函数可以通知应用程序WIFI启动完成,可以启动网络应用程序任务,同时此刻也是wifi_on接口退出返回的时候

**4.配网阶段**

* 4.1 Wi-Fi驱动引发WIFI_EVENT_SMP_CFG_START事件,代表Wi-Fi驱动内部配网模式已经启动
* 4.2 Wi-Fi事件回调函数将事件WIFI_EVENT_SMP_CFG_START发送到应用程序任务
* 4.3 当Wi-Fi驱动接收到配网信息成功以后,将引发WIFI_EVENT_SMP_CFG_COMPLETED事件,若应用程序通过wifi_set_smp_cfg_timeout配置了超时时间,那么将引发WIFI_EVENT_SMP_CFG_TIMEOUT事件
* 4.4 Wi-Fi事件回调函数将事件WIFI_EVENT_SMP_CFG_COMPLETED/WIFI_EVENT_SMP_CFG_TIMEOUT发送到应用程序任务

## 3.1.11. AC79 Wi-Fi STA/配网模式下启动一次信道扫描场景示例

![](img\51.png)

**1.Wi-Fi处于STA模式或者配网模式**

* 1.1 应用程序调用wifi_sta_scan_once函数启动一次扫描
* 1.2 Wi-Fi驱动内部扫描所有信道
* 1.3 Wi-Fi驱动扫描完成引发WIFI_EVENT_STA_SCAN_COMPLETED事件
* 1.4 Wi-Fi事件回调函数将事件WIFI_EVENT_STA_SCAN_COMPLETED发送到应用程序任务
* 1.5 应用程序通过调用wifi_get_scan_result函数获取扫描结果

## 3.1.12. AC79 Wi-Fi 从配网模式切换到STA模式场景示例

![](img\52.png)

**1.Wi-Fi启动后处于配网模式**

**2.Wi-Fi配网阶段完成后**

* 2.1 应用程序调用wifi_enter_sta_mode函数切换到STA模式
* 2.2 Wi-Fi驱动引发WIFI_EVENT_SMP_CFG_STOP事件,代表配网模式已经停止
* 2.10 当STA模式连接成功后,应用程序调用wifi_store_mode_info保存WIFI模式配置信息,覆盖WIFI启动默认配置模式,下次调用wifi_on函数启动Wi-Fi,驱动程序会根据最后保存的配置(模式,SSID,密码等)进入STA模式

## 3.1.13. AC79 Wi-Fi 从AP模式切换到STA模式场景示例

![](img\53.png)

## 3.1.14. AC79 Wi-Fi 从STA模式切换到STA模式场景示例

![](img\54.png)

## 3.1.15. AC79 Wi-Fi 函数接口使用注意事项

* Wi-Fi提供的函数接口统一在 `include_lib/net/wifi/wifi_connect.h` 头文件,分类了哪些函数是哪个模式下使用的,哪些是公共使用的,每个函数的具体意义都有注释描述
* 应用程序需要注意接口的使用顺序,这部分可以参考当前目录下Wi-Fi提供的例程
* 应用程序调用wifi_set_event_callback注册的事件回调函数是在Wi-Fi驱动内核调度的,而有些函数需要调度到Wi-Fi驱动内核, 为了防止阻塞挂机的情况, 应用程序在使用wifi_enter_sta_mode, wifi_enter_ap_mode, wifi_enter_smp_cfg_mode, wifi_sta_scan_once, wifi_on, wifi_off, wifi_store_mode_info,这些函数的时候不能够直接在事件回调函数内执行,而是在事件回调函数把事件发送到应用程序的任务中执行

## 3.1.16. Wi-Fi 失败代码原因

![](img\55.png)

## 3.1.17. WIFI 基本配置

* `apps/common/net/wifi_conf.c` 的WL_AP_DAT提供了AP模式下的配置,WL_STA_DAT提供了STA模式下的配置,下表详细描述一些常用的配置项

**AP/STA/配网模式公共部分基本配置**

![](img\56.png)

![](img\57.png)

**AP模式专属基本配置**

![](img\58.png)

Note

注意事项：在AP模式使用隐藏SSID时，需要将网络包过滤规则设置为不过滤，如：`wifi_rxfilter_cfg(1)` ;各参数含义如下表：

| 0 | STA模式默认不过滤                        |
| :- | ---------------------------------------- |
| 1 | AP模式默认不过滤                         |
| 2 | STA模式下使用,过滤广播,多播              |
| 3 | STA模式下使用,过滤not_my_bssid           |
| 4 | STA模式下使用,过滤广播+多播+not_my_bssid |
| 5 | AP模式下使用,过滤广播,多播               |
| 6 | AP模式下使用,过滤not_my_bssid            |
| 7 | AP模式下使用,过滤广播+多播+not_my_bssid  |
| 8 | 不过滤crc错误包                          |

**STA模式专属基本配置**

![](img\59.png)

## 3.1.18. Wi-Fi 安全机制

* 支持WEP/WPA-TKIP/WPA2-CCMP传统的安全保障方法,针对AP模式,默认使用WPA2PSK-AES加密方式,用户也可以在 `apps/common/net/wifi_conf.c` 的wl_set_passphrase函数内更改配置,针对STA模式会自动根据AP端加密方式选择匹配的方式

## 3.1.19. Wi-Fi 冷启动快连

* 在app_config.h 使能宏 WIFI_COLD_START_FAST_CONNECTION 和 CONFIG_STATIC_IPADDR_ENABLE 启用冷启动快连,最快可在400ms内连接上路由器进行tpcip通信. 首次连接路由器不会启动快连,需要连接后记忆必要信息,下次重新连接才会启动快连

## 3.1.20. WIFI RF 参数校准

由于Wi-Fi IC在不同的板子上表现的RF性能差异性问题, 需要根据不同的板子测试指标(Power、EVM、Mask、Freq.Error)来重新校准WIFI RF 参数, 分别有晶振电容配置,PA trim值配置, 每个速率的数字增益配置(如果只需要运行蓝牙不运行WIFI此项不需要), 如果测试性能达不达标,客户可以联系FAE支持重新画板

用户可以根据[FCC测试工具和文档]: [sdk_tools/WIFI_MP_TEST_TOOL]() 进行操作,然后把测试好的校准值填写到SDK里面对应board板级文件的wifi_calibration_param参数

```
const struct wifi_calibration_param wifi_calibration_param = {
    .xosc_l     = 0xb,// 调节晶振左电容
    .xosc_r     = 0xa,// 调节晶振右电容
    .pa_trim_data  ={7, 7, 1, 1, 5, 0},// 根据MP测试生成PA TRIM值
    .mcs_dgain     ={
        64,//11B_1M
        64,//11B_2.2M
        64,//11B_5.5M
        64,//11B_11M
        64,//11G_6M
        64,//11G_9M
        64,//11G_12M
        64,//11G_18M
        64,//11G_24M
        38,//11G_36M
        34,//11G_48M
        27,//11G_54M
        64,//11N_MCS0
        64,//11N_MCS1
        64,//11N_MCS2
        64,//11N_MCS3
        40,//11N_MCS4
        34,//11N_MCS5
        29,//11N_MCS6
        25,//11N_MCS7
    }
};
```

## 3.1.21. 如何配置WIFI模拟发射功率

* 在 WIFI_EVENT_MODULE_START 事件之后就可以 调用wifi_set_pwr 配置, WIFI运行过程中可以动态配置, 如果不配置默认使用最大的档位

## 3.1.22. 如何指定WIFI发送速率

* 针对特殊应用场合,用户可以指定选择 B模,G模,N模的Wi-Fi发送速率,例如用户需求带宽比较高,则低速率的调制编码方式不满足需求
* 用户可以在wifi_event_callback的case WIFI_EVENT_MODULE_START:事件下调用wifi_set_tx_rate_control_tab配置,也可以在Wi-Fi运行过程中动态配置,该配置会同时限定重发速率

```
static int wifi_event_callback(void *network_ctx, enum WIFI_EVENT event)
    switch (event) {
    case WIFI_EVENT_MODULE_START:
            u32  tx_rate_control_tab = // 不需要哪个速率就删除掉该行,可以动态设定
            0
            | BIT(0) //0:CCK 1M
            | BIT(1) //1:CCK 2M
            | BIT(2) //2:CCK 5.5M
            | BIT(3) //3:OFDM 6M
            | BIT(4) //4:MCS0/7.2M
            | BIT(5) //5:OFDM 9M
            | BIT(6) //6:CCK 11M
            | BIT(7) //7:OFDM 12M
            | BIT(8) //8:MCS1/14.4M
            | BIT(9) //9:OFDM 18M
            | BIT(10) //10:MCS2/21.7M
            | BIT(11) //11:OFDM 24M
            | BIT(12) //12:MCS3/28.9M
            | BIT(13) //13:OFDM 36M
            | BIT(14) //14:MCS4/43.3M
            | BIT(15) //15:OFDM 48M
            | BIT(16) //16:OFDM 54M
            | BIT(17) //17:MCS5/57.8M
            | BIT(18) //18:MCS6/65.0M
            | BIT(19) //19:MCS7/72.2M
            ;
            wifi_set_tx_rate_control_tab(tx_rate_control_tab);
break;
```

## 3.1.23. Wi-Fi 低功耗模式

**Wi-Fi省电软件策略**

* Wi-Fi低功耗策略可以通过配置更低的模拟发射功率和数字发射功率
* AP模式下增大Beacon帧间隔
* 稍微降低app_config.h的VDC14_VOL_SEL_LEVEL(WIFI电压VDD14)
* 使用wifi_set_tx_rate_control_tab函数配置 Wi-Fi发送datarate,限制在高带宽的速率

**STA节能模式PSMode**

* Wi-Fi station 必须与AP已连接的状态下，station将根据负载情况定期在活动状态和睡眠状态之间切换,
  PSMode 模式下每个 DTIM 间隔，station都将被系统唤醒以接收AP发出的beacon帧, 广播数据在 DTIM 之后传输，因此不会丢失。但是，由于 DTIM 间隔长短由AP决定，如果该间隔时间设置较短，则省电效果不大,一般路由器默认配置为1个DTIM周期即100毫秒
* 具体使用方法请参考[STA节能模式PSMode]: `low_power`

**AP 节能模式**

* 暂不支持AP节能模式

## 3.1.24. WIFI MAC地址配置

WIFI MAC地址配置位于 ``apps/common/net/assign_macaddr.c``, WIFI和BT/BLE MAC地址是一致的, 配置方式有以下几种:

1.使用flash的uuid或者随机数产生mac地址;

2.使用[MAC地址配置工具]: [sdk_tools/地址更新工具]() 烧写MAC地址到FLASH;

3.第一次连上外网后，使用杰理服务器分配WIFI模块的MAC地址,需要在app_config.h 打开宏 CONFIG_ASSIGN_MACADDR_ENABLE, 默认统一分配, 若用户需要指定一批mac地址范围,可以根据[杰理开放平台文档]： `doc/stuff/杰理开放平台文档20201216_136.pdf` 发送邮件到杰理开发团队申请,然后把申请到的客户批次号填写到[platform_cfg.c]: `common/net/platform_cfg.c` 的get_macaddr_auth_key和get_macaddr_code函数

4.用户自行在init_net_device_mac_addr函数实现获取MAC地址的方法

## 3.1.25. WIFI AP模式下获取接入的 stasion 信息

* 获取MAC地址: 可以通过WIFI_EVENT_AP_ON_ASSOC事件获取到连接进来的STA MAC地址, 或者可以通过lwip_get_dest_hwaddr接口,填入IP地址获取对应MAC地址信息
* 获取IP地址:可以通过dhcps_get_ipaddr接口,填入MAC地址获取对应IP地址信息
* 获取RSSI/EVM: 可以通过wifi_get_sta_entry_rssi接口获取连接进来的STA的RSSI/EVM信息

## 3.1.26. Wi-Fi STA模式断线重接问题

* 出于多种原因，Wi-Fi 在STA模式下可能会与AP断开连接，应用程序应负责重新连接, 通常的方法为：应用程序接收到WIFI_EVENT_STA_DISCONNECT事件后调用函数wifi_enter_sta_mode进行重新连接
* 如果应用程序希望重新连接的时候连接记忆保存过的最佳网络,则先调用wifi_set_sta_connect_best_ssid函数后调用函数wifi_enter_sta_mode进行重新连接
* 如果断开连接事件是由应用程序主动引发的，那么应用程序可能不期望立刻重新连接

## 3.1.27. Wi-Fi 直接使用RF收发数据包

* 当用户想绕过802.11协议栈和802.3协议栈,需要直接通过WIFI RF向空中发送和接收一个原始的 802.11 数据包,实现传输私有通信协议,可以参考[Wi-Fi 直接使用RF收发数据包例程]: `private_communication` 提供的方法实现

## 3.1.28. Wi-Fi HT20/40

* AC791N系列 支持 Wi-Fi 带宽 HT20 或 HT40，AC790N系列 不支持 Wi-Fi 带宽 HT40
* 在 AP/Station 模式下,实际带宽首先在 Wi-Fi 连接时协商。只有当 station 和所连 AP 都支持 HT40 时，带宽才为 HT40，否则为 HT20。如果所连的 AP 的带宽发生变化，则在不断开 Wi-Fi 连接的情况下再次协商实际带宽
* 理论上，HT40 可以获得更大的吞吐量，因为 HT40 的最大原始 PHY 数据速率为 150Mbps，而 HT20 为 72Mbps。但是，如果设备在某些特殊环境中使用，例如周围其他 Wi-Fi 设备过多，HT40 的性能可能会降低。因此，如果应用程序需要支持相同或类似的情况，建议始终将带宽配置为 HT20

## 3.1.29. Wi-Fi QoS

* AC79 支持 WFA Wi-Fi QoS 认证所要求的所有必备功能,目前开放的版本为了节省内存消耗,关闭了QoS功能,如果用户有需求可以向杰理AC79开发团队申请开放。
* Wi-Fi 协议中定义了四个 AC （访问类别），每个 AC 有各自的优先级访问 Wi-Fi 信道。此外，还定义了映射规则以映射其他协议的 QoS 优先级，例如 802.11D 或 TCP/IP 到 Wi-Fi AC。
* 下表描述 IP 优先级如何映射到 Wi-Fi AC,该表按优先级降序排列，即 AC_VO 拥有最高优先级。
  > | IP 优先级 | Wi-Fi AC            |
  > | --------- | ------------------- |
  > | 6, 7      | AC_VO (Voice)       |
  > | 4, 5      | AC_VI (Video)       |
  > | 3, 0      | AC_BE (Best Effort) |
  > | 1, 2      | AC_BK (Background)  |
  >
* 应用程序可以通过套接字选项 IP_TOS 配置 IP 优先级使用 QoS 功能。下面是使套接字使用 VI 队列的示例:
  > ```
  > const int ip_precedence_vi = 4;
  > const int ip_precedence_offset = 5;
  > int priority = (ip_precedence_vi << ip_precedence_offset);
  > setsockopt(socket_id, IPPROTO_IP, IP_TOS, &priority, sizeof(priority));
  > ```
  >
* 理论上，高优先级的 AC 比低优先级 AC 具有更好的性能，但并非总是如此，下面是一些关于如何使用 Wi-Fi QoS 的建议：
  * 可以把一些真正重要的应用程序流量放到 AC_VO 队列中, 避免通过 AC_VO 队列发送大流量, 如果流量很大, 性能不会优于其他队列. 另一方面，可能会影响同样使用 AC_VO 队列的管理帧
  * 避免使用 AMPDU 支持的、两个以上的不同优先级，比如 socket A 使用优先级AC_BK，socket B 使用优先级 AC_BE，socket C 使用优先级 AC_VI。因为可能需要更多的内存，不是好的设计。具体来说，Wi-Fi 驱动程序可能会为每个优先级生成一个 Block Ack 会话，则需要更多内存

## 3.1.30. Wi-Fi 缓冲区以及吞吐率性能

* AC79 Wi-Fi 的性能收到许多参数的影响，各参数之间存在相互制约。如果配置地合理，不仅可以提高性能，还可以增加应用程序的可用内存，提高稳定性。
  在本节中，我们将简单介绍 Wi-Fi/LWIP 协议栈的工作模式，并推荐几种配置等级，用户可以根据使用场景选择合适的等级配置
  ![](https://doc.zh-jieli.com/AC79/zh-cn/master/_images/%E5%9B%BE%E7%89%8712.png)

**协议栈数据流路径**

* AC79 网络协议栈分为应用层、LWIP协议层、Wi-Fi协议层和硬件层,在接收过程中，硬件将接收到的数据包放入 DMA BUFFER，然后依次传送到 Wi-Fi 的接收数据缓冲区、LWIP 的接收数据缓冲区进行相关协议处理，最后传送到应用层。在发送过程中，应用程序首先将要发送的消息复制到 LWIP 层的发送数据缓冲区，进行 TCP/IP 封装。然后将消息发送到 Wi-Fi 层的发送数据缓冲区进行 MAC 封装，最后填充到硬件DMA BUFFER发送
* Wi-Fi 的吞吐量很大程度上取决于与收发队列缓存大小相关的配置，如 TCP 窗口大小、Wi-Fi 接收/发送数据动态缓冲区数量等。在考虑内存配置时，应用程序所需的总内存也是一个需要均衡的因素，由于这些原因，不存在一个适合所有应用程序的配置。因此，我们必须为每个不同的应用程序考虑不同的内存配置
* 关于LWIP TCP/IP 层分配缓冲区大小, SDK默认配置了两档预编译好的库文件供用户选择,其中lwip.a库对应配置文件lwipopts.h, lwip_sfc.a库对应配置文件lwipopts_sfc.h,同时[lib/net]： `lib/net` 目录下也开放了LWIP库的源代码,对LWIP内存使用和性能部分配置有了解的用户可以自行修改重编译库
* 关于 WIFI 协议层分配缓冲区大小, SDK默认配置了一些预编译好的库文件供用户选择,用户需要确认当前自己使用的编译工程文件选择的是哪个库文件
* 开辟较小缓冲区的WIFI库与LWIP库组合的吞吐率在500KB/S左右, 开辟更大缓冲区的WIFI库与LWIP库组合的吞吐率在2MB/S. 一般来说, 如果应用方案功能开发完成以后,有较多剩余内存,都应该选择开辟更大缓冲区的WIFI库与LWIP库,如果用户需求更高精度的缓冲区开辟空间,可以联系杰理AC79开发团队支持定制
* 下表具体描述不同名字的wifi库与lwip库代表的具体意义
  > | wl_wifi.a         | 包含AP和STA模式,开辟更大缓冲区,收发吞吐率更高, 建议芯片封装带SDRAM的方案选择 |
  > | ----------------- | ---------------------------------------------------------------------------- |
  > | wl_wifi_sfc.a     | 包含AP和STA模式,开辟较小缓冲区,占据内存小                                    |
  > | wl_wifi_ap.a      | 包含AP和STA模式,收发吞吐率更高, 建议芯片封装带SDRAM的方案选择                |
  > | wl_wifi_ap_sfc.a  | 只包含AP模式,开辟较小缓冲区,占据内存小                                       |
  > | wl_wifi_sta.a     | 只包含STA模式,开辟更大缓冲区,收发吞吐率更高, 建议芯片封装带SDRAM的方案选择   |
  > | wl_wifi_sta_sfc.a | 只包含STA模式,开辟较小缓冲区,占据内存小                                      |
  > | lwip.a            | 开辟更大缓冲区,收发吞吐率更高, 建议芯片封装带SDRAM的方案选择                 |
  > | lwip_sfc.a        | 开辟较小缓冲区,占据内存小                                                    |
  > | wpasupplicant.a   | 如使用STA模式,需要包含, 仅使用AP模式不需要包含                               |
  >
* AP模式下开辟最大缓冲区在无干扰环境下吞吐率测试

![](https://doc.zh-jieli.com/AC79/zh-cn/master/_images/%E5%9B%BE%E7%89%8713.png)

* STA模式下开辟最大缓冲区在无干扰环境下吞吐率测试

![](https://doc.zh-jieli.com/AC79/zh-cn/master/_images/%E5%9B%BE%E7%89%8714.png)

# 3.2. Wi-Fi API接口说明

* wifi 的 API 接口说明如下：

## Defines

**ENC_NONE**
**ENC_WEP**
**ENC_WPA**
**ENC_WPA2**
**ENC_WPA3**
**ENC_MODE_BIT_SET(val, mode)**
**ENC_MODE_BIT_IS_SET(val, mode)**

## Functions

void **wifi_set_event_callback**(int (*cb)(void*, enum WIFI_EVENT))
    wifi_set_event_callback，用于注册（设置）WIFI事件回调函数
**Parameters：**     cb – 指向WIFI事件回调函数，一般为：wifi_event_callback

u8 **wifi_airkiss_calcrc_bytes**(u8 *p, unsigned int num_of_bytes)
    wifi_airkiss_calcrc_bytes，用于计算airkiss接收包crc校验
**Parameters：**     p – 指向设备端扫描到的空中SSID      num_of_bytes – 设备端扫描到的空中SSID长度

void **wifi_set_frame_cb**(void (*cb)(void *rxwi, struct ieee80211_frame *wh, void *data, u32 len, void *priv), void *priv)
    wifi_set_frame_cb，用于注册（设置）WIFI底层接收到802.11数据帧回调函数
**Parameters：**     cb – 指向WIFI底层接收到802.11数据帧回调函数     priv – 用户私有指针传递

void **wifi_set_pwr**(unsigned char pwr_sel)
    wifi_set_pwr，用于设置WIFI 模拟功率等级

**Note**

参数设为0，表示把WIFI模拟功率调整到最低档位节电

**Parameters：** **pwr_sel – 默认为6，范围为0-6**

int **wifi_on**(void)
    wifi_on，用于启动WIFI

int **wifi_is_on**(void)
    wifi_is_on，查询WIFI是否启动

int **wifi_off**(void)
    wifi_off，关闭WIFI

int **wifi_get_mac**(u8 *mac)
    wifi_get_mac，获取WIFI MAC地址
**Parameters：**     mac – 指向存储MAC地址的缓存数组，数组大小为6

int **wifi_set_mac**(char *mac_addr)
    wifi_set_mac，设置WIFI MAC地址
**Parameters：**     mac_addr – 指向要设置的MAC地址缓存数组，数组大小为6

void **wifi_rxfilter_cfg**(char mode)
    wifi_rxfilter_cfg，设置WIFI接收过滤
**Parameters：**     mode – 过滤模式

| mode | 说明                                     |
| ---- | ---------------------------------------- |
| 0    | STA模式默认不过滤                        |
| 1    | AP模式默认不过滤                         |
| 2    | STA模式下使用,过滤广播,多播              |
| 3    | STA模式下使用,过滤not_my_bssid           |
| 4    | STA模式下使用,过滤广播+多播+not_my_bssid |
| 5    | AP模式下使用,过滤广播,多播               |
| 6    | AP模式下使用,过滤not_my_bssid            |
| 7    | AP模式下使用,过滤广播+多播+not_my_bssid  |

void **wifi_set_tx_rate_control_tab**(u32 tab)
    wifi_set_tx_rate_control_tab，用于设置WIFI TX速率
**Parameters：**     tab – 速率表，不需要哪个速率就删除掉,可以动态设定

u32 **wifi_get_channel**(void)
    wifi_get_channel，用于获取WIFI当前信道

void **wifi_get_bssid**(u8 bssid[6])
    wifi_get_bssid，用于获取WIFI当前bssid

u32 **wifi_get_upload_rate**(void)
    wifi_get_upload_rate，用于获取WIFI上行速率

u32 **wifi_get_download_rate**(void)
    wifi_get_download_rate，用于获取WIFI下行速率

void **wifi_get_mode_cur_info**(struct wifi_mode_info *info)
    wifi_get_mode_cur_info，用于获取WIFI当前是什么模式,或者当前指定模式下的配置信息
**Parameters：**     info – 指向一个wifi_mode_info类型的结构体，其包含了变量mode、ssid、pwd

int **wifi_get_mode_stored_info**(struct wifi_mode_info *info)
    wifi_get_mode_stored_info，用于获取WIFI最后记忆的是什么模式,或者最后记忆模式下的配置信息
**Parameters：**     info – 指向一个wifi_mode_info类型的结构体，其包含了变量mode、ssid、pwd

int **wifi_set_default_mode**(struct wifi_store_info *parm, char force, char store)
    wifi_set_default_mode，用于设置WIFI启动默认模式配置

**Note**

配置STA模式情况下,把默认配置SSID也存储起来,以后即使保存过其他SSID,也不会覆盖丢失,使用连接最优信号SSID策略的情况下可以匹配连接**Parameters：**

* parm – 指向一个wifi_store_info类型的结构体      
* force – 配置wifi_on之后的模式      

| force | 说明                                                                 |
| ----- | -------------------------------------------------------------------- |
| 0     | 使用最后记忆的模式                                                   |
| 1     | 强制默认模式                                                         |
| 3-200 | STA连接超时时间多少秒,如果超时都连接不上就连接最后记忆的或者最优网络 |

* store – 选择是否存储默认配置的SSID

| store | 说明                 |
| ----- | -------------------- |
| 0     | 不存储默认配置的SSID |
| 1     | 存储默认配置的SSID   |

int **wifi_store_mode_info**(enum WIFI_MODE mode, char *ssid, char *pwd)
    wifi_store_mode_info，用于保存WIFI模式配置信息,覆盖默认模式
**Parameters：**     mode – 配置的wifi模式 `<br>`     ssid – 配置模式下的SSID `<br>`     pwd – 配置模式下的密码

int **wifi_del_stored_sta_info**(char *ssid)
    wifi_del_stored_ssid，用于删除STA模式下保存过的SSID,仅允许STA模式使用
**Parameters：**     ssid – 删除wifi_get_stored_sta_info存储中的ssid

void **wifi_set_target_mac_for_agc_recv**(char *mac)
    wifi_set_target_mac_for_agc_recv，用于设置目标接收地址,有利于提高抗干扰能力,专门针对目标地址的数据包进行接收AGC和频偏调整
**Parameters：**     mac – 目标接收地址

int **wifi_enter_ap_mode**(char *ap_ssid, char *ap_pwd)
    wifi_enter_ap_mode，用于设置WIFI进入AP模式
**Parameters：**     ap_ssid – AP模式下的SSID `<br>`     ap_pwd – AP模式下的密码

int **wifi_get_sta_entry_rssi**(char wcid, char *rssi, u8 *evm, u8 *mac)
    wifi_get_sta_entry_rssi，用于AP模式下获取接入的每个STA信号质量和MAC地址

void **wifi_disconnect_station**(char *mac, u16 reason)
    wifi_disconnect_station，用于AP模式下断开指定MAC地址的STA
**Parameters：**     mac – 要断开设备的mac地址 `<br>`     reason – 断开的原因，通常填8:Deauthenticated because sending station is leaving

void **wifi_set_store_ssid_cnt**(u32 cnt)
    wifi_set_store_ssid_cnt，用于设置WIFI最多保存多少个连接的SSID数目
**Parameters：**     cnt – sta模式下最多保存的SSID数目，工程中默认为5

void **wifi_set_sta_connect_best_ssid**(u8 enable)
    wifi_set_sta_connect_best_ssid，用于设置WIFI进入STA模式的时候如果匹配到信号最好的网络就去连接
**Parameters：**     enable – 自动连接保存过的信号最好的SSID使能端,置1：使能，置0：不使能

void **wifi_set_sta_connect_timeout**(int sec)
    wifi_set_sta_connect_timeout，用于设置WIFI连接STA超时时间
**Parameters：**     sec – WIFI连接STA超时时间，单位为秒，工程中默认为60秒

void **wifi_set_connect_sta_block**(int block)
    wifi_set_connect_sta_block，用于设置WIFI连接STA是否阻塞, 默认非阻塞通过事件通知
**Parameters：**     block – 使能端，置1：阻塞，置为0：不阻塞

int **wifi_enter_sta_mode**(char *sta_ssid, char *sta_pwd)
    wifi_enter_sta_mode，用于设置WIFI进入STA模式
**Parameters：**     sta_ssid – 配置STA模式的SSID `<br>`     sta_pwd – 配置STA模式的密码

int **wifi_scan_req**(void)
    wifi_scan_req，用于WIFI STA模式或者AP模式下启动一次扫描空中SSID
**Note：**     STA模式下调用返回-1代表WIFI OFF/正在扫描/连接中,无需启动扫描, 可以等待几秒或者扫描完成事件到来获取结果

struct **wifi_scan_ssid_info** *wifi_get_scan_result(u32 *ssid_cnt)
    wifi_get_scan_result，用于启动一次扫描空中SSID后,获取扫描结果

void **wifi_clear_scan_result**(void)
    wifi_clear_scan_result，用于获取扫描结果后,清空上次扫描结果

int **wifi_get_stored_sta_info**(struct wifi_stored_sta_info wifi_stored_sta_info[])
    wifi_get_stored_sta_info，用于获取WIFI保存过的SSID
**Note：**     返回WIFI保存过的SSID数目

char **wifi_get_rssi**(void)
    wifi_get_rssi，用于获取WIFI连接的STA接收信号强度
**Note：**     返回WIFI连接的STA接收信号强度

char **wifi_get_cqi**(void)
    wifi_get_cqi，用于获取WIFI连接的STA信号质量
**Note：**     返回WIFI连接的STA通信丢包质量,0-100,一般认为大于50为较好,20-50之间为一般,小于20较差, decide ChannelQuality based on: 1)last BEACON received time, 2)last RSSI权重50, 3)TxPER权重30, and 4)RxPER权重20

enum **wifi_sta_connect_state** wifi_get_sta_connect_state(void)
    wifi_get_sta_connect_state，用于获取WIFI是连接STA状态
**Note：**     返回WIFI连接STA的状态

int **wifi_enter_smp_cfg_mode**(void)
    wifi_enter_smp_cfg_mode，用于设置WIFI进入配网模式/monitor模式

void **wifi_set_smp_cfg_timeout**(int sec)
    wifi_set_smp_cfg_timeout，用于设置WIFI配网超时事件时间
**Parameters：**     sec – WIFI配网超时时间，单位为秒

void **wifi_set_smp_cfg_scan_all_channel**(char onoff)
    wifi_set_smp_cfg_scan_all_channel，用于设置WIFI配网模式/monitor模式下是否扫描全部信道,默认否
**Parameters：**     onoff – 全扫描开关，1:开启，0:关闭

void **wifi_set_smp_cfg_airkiss_recv_ssid**(char onoff)
    wifi_set_smp_cfg_airkiss_recv_ssid，用于设置WIFI airkiss配网模式下是否接收完整的SSID,默认否,有助于加快配网时效,有概率配网失败
**Parameters：**     onoff – 全扫描开关，1:开启，0:关闭

void **wifi_set_smp_cfg_just_monitor_mode**(char onoff)
    wifi_set_smp_cfg_just_monitor_mode，用于设置WIFI进入配网/monitor模式后,是否只保留monitor模式,默认否
**Parameters：**     onoff – 全扫描开关，1:开启，0:关闭

void **wifi_set_monitor_mode_scan_channel_time**(int time_ms)
    wifi_set_monitor_mode_scan_channel_time，用于在WIFI只保留monitor模式的情况下,设置扫描每个信道的时间间隔
**Parameters：**     time_ms – 扫描每个信道的时间间隔，单位为ms

void **wifi_set_airkiss_key**(u8 key[16])
    wifi_set_airkiss_key，用于设置WIFI配网模式下airkiss的key
**Parameters：**     key – 为WIFI配网模式下airkiss的key数组

int **wifi_get_cfg_net_result**(struct smp_cfg_result *smp_cfg)
    wifi_get_cfg_net_result，用于配网成功后获取WIFI配网信息

void **wifi_set_channel**(u8 ch)
    wifi_set_channel，用于设置WIFI当前信道
**Parameters：**     ch – 要设置的WIFI信道

void **wifi_wsc_start**(const char *ssid, const char *pincode, int mode)
    wifi_wsc_start，用于设置wifi的WSC模式
**Parameters：**     ssid – 要设置的ssid信道      pincode – 设置pincode值     mode – WSC_CFG_MODE

u8 **wifi_get_payload_ptr**(void)
    wifi_get_payload_ptr，用于获取WIFI底层接口填充payload指针

u8 **wifi_get_wifi_send_pkg_ptr**(void)
    wifi_get_payload_ptr，用于获取WIFI底层接口MAC地址配置地址用于双机对传不走wifi私有协议2.4g

void **wifi_send_data**(int len, enum wifi_tx_rate rate)
    wifi_send_data，用于使用WIFI底层接口直接发送数据帧
**Parameters：**     len – 发送数据的长度,最大2510字节     rate – WIFI发送速率

void **wifi_set_long_retry**(u8 retry)
    wifi_set_long_retry，用于设置WIFI底层长帧重传次数
**Parameters：**     retry – 为重传次数

void **wifi_set_short_retry**(u8 retry)
    wifi_set_short_retry，用于设置WIFI底层短帧重传次数
**Parameters：**     retry – 为重传次数

u32 **wifi_get_remain_tx_queue**(char ac_queue)
    wifi_get_remain_tx_queue，用于获取WIFI底层发送队列剩余个数
**Parameters：**     ac_queue – 为Qos优先级,用户无配置就是填0
**Returns：**     剩余多少个包可填充,最大为 MAX_PACKETS_IN_QUEUE

void **wifi_backoff_cfg**(u8 cwmax)
    wifi 最大backoff范围设置
**Parameters：**     cwmax – 为最大backoff范围

u32 **wifi_get_tbtt**(void)
    wifi_get_tbtt 获取 wifi 下一个 beacon 抵达的剩余预测时间
**Returns：**     返回值范围 0 ~ 3FFFFF，单位为 us

u64 **wifi_get_tsf**(void)
    wifi_get_tsf 获取 wifi TSF 计数器的值
**Returns：**     返回值范围 0 ~ FFFFFFFFFFFFFFFF，单位为 us

# 3.3. Wi-Fi AP/STA/MONITOR模式示例说明

本工程展示了wifi模块ap/sta/monitor三种模式切换的使用示例:

* wifi启动STA模式的使用
* wifi启动AP模式的使用
* wifi启动MONITOR模式的使用

## 3.3.1. 工程示例及配置说明

* STA模式example:
  * 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_DEMO_WIFI_TEST`
  * 在 `wifi_demo_task.c` 中打开宏
  * 
  * 定义 `#define STA_MODE_TEST` 配置WIFI工作在STA模式,并且配置好 `STA_SSID` 和 `STA_PWD`
* AP模式example:
  * 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_DEMO_WIFI_TEST`
  * 在 `wifi_demo_task.c` 中打开宏定义 `#define AP_MODE_TEST` 配置WIFI工作在AP模式,并且配置好 `AP_SSID` 和 `AP_PWD`
* MONITOR模式example:
  * 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_DEMO_WIFI_TEST`
  * 在 `wifi_demo_task.c` 中打开宏定义 `#define MONITOR_MODE_TEST` 配置WIFI工作在混杂/监听/配网模式

**Note**

若需要循环模式切换测试同时打开宏WIFI_MODE_CYCLE_TEST

## 3.3.2. 代码流程

* STA_MODE_TEST配置WIFI工作在STA模式:

  * c_main()入口：
    A）创建任务wifi_demo_task
  * wifi_demo_task():
    A）启动WIFI
    B）打印WIFI信号质量信息和吞吐率信息
  * wifi_event_callback():
    A）case WIFI_EVENT_MODULE_INIT: 配置WIFI启动为STA模式和连接路由器的SSID和密码
    B）case WIFI_EVENT_STA_NETWORK_STACK_DHCP_SUCC:连接路由器成功,并且DHCP获取到IP地址
* AP_MODE_TEST配置WIFI工作在AP模式:

  * c_main()入口：
    A）创建任务wifi_demo_task
  * wifi_demo_task():
    A）启动WIFI
    B）打印WIFI信号质量信息和吞吐率信息
  * wifi_event_callback():

  > A）case WIFI_EVENT_MODULE_INIT: 调用wifi_set_lan_setting_info();配置AP模式的IP地址信息和DHCP池起始分配地址, 配置WIFI启动为AP模式和热点SSID和密码
  >
  > B）case WIFI_EVENT_AP_START:AP模式启动成功,此时手机端可以搜索到对应SSID的热点
  >
  > C）case WIFI_EVENT_AP_ON_ASSOC:当有手机成功连接到WIFI,引发事件
  >
  > D）case WIFI_EVENT_AP_ON_DISCONNECTED:当有手机断开WIFI,引发事件
  >
* MONITOR_MODE_TEST配置WIFI工作在混杂/监听/配网模式:

  * c_main()入口：

  > A）创建任务wifi_demo_task
  >

  * wifi_demo_task():

  > A）启动WIFI
  >
  > B）打印WIFI信号质量信息和吞吐率信息
  >

  * wifi_event_callback():

  > A）case WIFI_EVENT_MODULE_INIT: 配置WIFI启动为MONITOR模式
  >
  > B）case WIFI_EVENT_SMP_CFG_START:注册接收802.11数据帧回调wifi_rx_cb
  >
  > C）case WIFI_EVENT_SMP_CFG_STOP:关闭接收802.11数据帧回调
  >

  * wifi_rx_cb():

  > A）打印接收到的802.11数据帧
  >

# 3.4. Wi-Fi IPERF示例说明

本工程展示了使用iperf测试wifi吞吐率的使用示例:

* WIFI STA模式测试IPERF。
* WIFI AP模式测试IPERF。
* IPERF的上下行吞吐率测试以及参数配置。

## 3.4.1. 工程示例及配置说明

**example:**

* 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_DEMO_WIFI_TEST` 和 `USE_WIFI_IPERF_TEST`
* 在 `app_config.h` 中打开宏定义 `#define CONFIG_WIFI_ENABLE` 和 `#define CONFIG_IPERF_ENABLE`
  ![i_1.png](https://doc.zh-jieli.com/AC79/zh-cn/master/_images/i_1.png)
* 在 `wifi_demo_task.c` 中进行如下配置：

  * 打开宏定义 `AP_MODE_TEST` 或者 `STA_MODE_TEST` 配置WIFI工作模式
  * 配置AP模式和STA模式的 `SSID` （名称）和 `PWD` （密码）

  ![i_2.png](https://doc.zh-jieli.com/AC79/zh-cn/master/_images/i_2.png)

## 3.4.2. 模块依赖

* 如果只需要测试STA模式和MONITOR模式, 工程文件或者Makefile包含wl_wifi_sta.a, wpasupplicant.a
* 如果只需要测试AP模式, 工程文件或者Makefile包含wl_wifi_ap.a
* 如果STA和AP模式均要测试, 工程文件或者Makefile包含wl_wifi.a,wpasupplicant.a
* 其中wl_wifi_ap_sfc.a,wl_wifi_sta_sfc.a,wl_wifi_sfc.a为节省内存/降低性能版本的WIFI库

## 3.4.3. 代码流程

* demo_wifi()入口：
  A）创建WIFI启动任务wifi_demo_task
  B）打印WIFI信号质量信息和吞吐率信息
  ![](https://doc.zh-jieli.com/AC79/zh-cn/master/_images/i_3.png)
* wifi_event_callback()：
  A）case WIFI_EVENT_MODULE_INIT: 配置WIFI启动前的必要配置, 例如WIFI MP测试后校准PA参数, WIFI启动前的默认模式, 配置信息等
  B）case WIFI_EVENT_MODULE_START:配置WIFI启动后的配置
  ![](https://doc.zh-jieli.com/AC79/zh-cn/master/_images/i_4.png)
* wifi_demo_task()函数流程:
  A）注册WIFI事件回调函数
  B）启动WIFI
  C）启动IPERF测试
  ![](https://doc.zh-jieli.com/AC79/zh-cn/master/_images/i_5.png)

## 3.4.4. 常见问题

* iperf测试工具的下载和命令说明：
  点击 [iperf下载]() 进行下载，点击 [iperf工具说明]() 查看使用说明。
* WIFI库选择说明：

| 库文件            | 说明                                                 |
| ----------------- | ---------------------------------------------------- |
| wl_wifi.a         | 包含AP和STA模式,占据大内存,性能强悍                  |
| wl_wifi_sfc.a     | 包含AP和STA模式,占据内存小                           |
| wl_wifi_ap.a      | 只包含AP模式,占据大内存,性能强悍                     |
| wl_wifi_ap_sfc.a  | 只包含AP模式,占据内存小                              |
| wl_wifi_sta.a     | 只包含STA模式,占据大内存,性能强悍                    |
| wl_wifi_sta_sfc.a | 只包含STA模式,占据内存小                             |
| lwip.a            | 占据大内存,性能强悍                                  |
| lwip_sfc.a        | 占据内存小                                           |
| wpasupplicant.a   | 如果需要使用STA模式,需要包含, 仅使用AP模式不需要包含 |

* iperf测试吞吐率一般结果为多少?
  答：AP模式下一般TX/RX速率有800KB/S-2MB/S,STA模式下一般有200KB-1MB/S
* 影响iperf测试吞吐率的因素有哪些?
  答：
  1.WIFI RF校准参数有没有进行仪器测试调整到SDK里面
  2.板子天线是否有调试好
  3.AP模式比STA模式吞吐率要高
  4.空中信道是否有比较大的干扰
  5.SDK运行过程中剩下的CPU使用率是否足够
  6.测试手机,路由器,设备,距离是否足够小
  7.使用占据资源多的高性能的WIFI库与LWIP库有利于提高吞吐率
  8.程序运行在SDRAM模式比在SFC模式吞吐率要高

# 3.5. Wi-Fi 扫描示例工程说明

本工程展示了使用STA/AP模式下启动扫描空中SSID并获取扫描结果的使用示例:

* STA模式下启动扫描空中SSID并获取扫描结果
* AP模式下启动扫描空中SSID并获取扫描结果

## 3.5.1. 工程示例及配置说明

* STA模式扫描example:
  * 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_DEMO_WIFI_TEST` 和 `USE_WIFI_SCAN_TEST`
  * 在 `wifi_demo_task.c` 中打开宏定义 `#define STA_MODE_TEST` 配置WIFI工作在STA模式,并且配置好 `STA_SSID` 和 `STA_PWD`
* AP模式扫描example:
  * 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_DEMO_WIFI_TEST` 和 `USE_WIFI_SCAN_TEST`
  * 在 `wifi_demo_task.c` 中打开宏定义 `#define AP_MODE_TEST` 配置WIFI工作在AP模式,并且配置好 `AP_SSID` 和 `AP_PWD`
  * 在 `wifi_conf.c` 中打开AP扫描开关 `const char wifi_ap_scan_support = 1;`

## 3.5.2. 代码流程

* demo_wifi()入口：
  > A）创建任务wifi_demo_task
  >
* wifi_demo_task():
  > A）启动WIFI
  >
  > B）打印WIFI信号质量信息和吞吐率信息
  >
  > C）循环调用扫描函数 `wifi_scan_test()`
  >
* wifi_scan_test():
  > A）STA模式或者AP模式下启动一次扫描空中SSID
  >
  > B）打印WIFI信号质量信息和吞吐率信息
  >
  > C）启动一次扫描空中SSID后,获取扫描结果
  >
  > D）打印扫描到的空中SSID结果
  >

## 3.5.3. 常见问题

* 若使用连接最优WIFI(connect_best_network)的情况下,如果不使用等待WIFI_STA_SCAN_COMPLETED事件的方式, 在WIFI还未连接成功的情况下,有概率会造成wifi内部获取的结果被这里清空导致当次获取不到空中准备WIFI列表,需要等到下次扫描结果,因此如果使用connect_best_network的情况下,推荐使用等待事件 WIFI_STA_SCAN_COMPLETED 扫描完成之后才去获取结果。

# 3.6. STA节能模式PSMode示例工程说明

本工程展示了使用STA节能模式PSMode的使用示例:

* STA节能模式PSMode使用的方法
* 一段时间内程序限定WIFI不进入休眠的方法

## 3.6.1. 工程示例及配置说明

**example:**

* 具体示例代码详见 `apps/common/example/wifi/low_power/main.c`，示例工程实现需在 `apps/demo/demo_DevKitBoard/include/demo_config.h` 中开启宏 `USE_DEMO_WIFI_TEST` 和 `USE_LOW_POWER_TEST`。
* 在 `app_config.h` 中打开宏定义 `#define CONFIG_LOW_POWER_ENABLE` 和 `#define TCFG_LOWPOWER_LOWPOWER_SEL (RF_SLEEP_EN|RF_FORCE_SYS_SLEEP_EN|SYS_SLEEP_EN)`。
* 在 `wifi_demo_task.c` 中进行如下配置：
  * 打开宏定义 `#define STA_MODE_TEST` 配置WIFI工作在STA模式
  * 配置STA模式的 `STA_SSID` （名称）和 `STA_PWD` （密码）

## 3.6.2. 代码流程

* c_main()入口：
  > A）创建任务sta_low_power_test_task
  >
* sta_low_power_test_task():
  > A）循环定时去允许和不允许WIFI 进行休眠
  >

## 3.6.3. 休眠策略说明

针对不同的应用场景， 具备如下四种休眠间隔策略：

* DTIM 间隔，默认使用该策略，只会在 DTIM 周期计数为0 时唤醒进行 beacon 的监听，休眠间隔由连接的 AP 所设置的 DTIM 周期决定，可主动配置 AP 为 DTIM10 的模式，实现 1s 的休眠间隔
* TIM 间隔，即每个 beacon 都会唤醒进行 TIM 监听，当系统需要进行高吞吐的业务时，可以使用该策略。通过函数 `wl_enabled_listen_each_tim` 和 `wl_disenabled_listen_each_tim` 开启或关闭该策略，退出该策略时模式默认回到 DTIM 监听
* 自定义监听间隔， 该策略允许用户设置自己的休眠时间，但是这个间隔只有 STA 自己知道， AP 只知道关联时的默认监听间隔，因此设置过长的话可能会导致断连或者响应不及时，通过 `wl_set_custom_listen_interval` 允许设置 1s、2s 甚至更高的休眠间隔， `wl_enabled_listen_custom_intervals` 和 `wl_disenabled_listen_custom_intervals` 开启或关闭该策略，退出该策略时模式默认回到 DTIM 监听
* 不监听 DTIM 间隔，该策略的休眠间隔是设备关联时配置的默认监听间隔， 通过函数 `wl_set_default_listen_interval` 设置默认间隔，这个间隔时间需要在连接之前进行配置才能生效，关联后 STA 和 AP 双方都知道这个间隔，但是不建议设置太长，因为休眠间隔太长同样会导致响应不及时。该策略优先级最低，只有关闭 DTIM 监听是才使用该策略， 即可以通过 `wl_disenabled_listen_dtim` 开启该策略

举例： 使用默认监听间隔，并配置休眠间隔为 10 个 Beacon Interval （通常情况下一个 Beacon Interval 大概是 102.4ms, 本例的休眠监听间隔大概是 1s 左右，功耗测试情况请参考 `doc/stuff/Wi-Fi场景功耗评估`）步骤如下：

> * 配置 `app_config.h` 打开宏定义 `#define CONFIG_LOW_POWER_ENABLE` 和 `#define TCFG_LOWPOWER_LOWPOWER_SEL (RF_SLEEP_EN|RF_FORCE_SYS_SLEEP_EN|SYS_SLEEP_EN)`
> * 在 `board.c` 中， `power_init` 之后调用 `power_keep_state(POWER_KEEP_RESET | POWER_KEEP_FLASH | POWER_KEEP_SYSPLL);` 保证休眠时不降频和不下电 flash
> * 调用 `low_power_hw_unsleep_unlock` 使能休眠动作
> * 在 `WIFI_EVENT_STA_CONNECT_SUCC` 事件之后调用 `wifi_rxfilter_cfg(3);` ,过滤not_my_bssid,如果需要使用扫描空中SSID就不要过滤
> * 调用如下方式启动默认监听间隔策略：
>
> ![](img\68.png)

## 3.6.4. 其他说明：

* 唤醒响应慢：
  > A）可以在唤醒之后，通过 `low_power_hw_unsleep_lock` 和 `low_power_hw_unsleep_unlock` 来开关休眠
  >
  > B）可以通过函数 `wl_set_active_wait_interval` 配置每次唤醒之后保持活跃的 Beacon Interval ；防止来不及接收数据或者发送数据又再次睡下去，比如配置休眠间隔是 10 个 Beacon Interval ，则可以将唤醒后的活跃间隔配置成 2~4 个 Beacon Interval
  >
* 降频操作会导致对补偿时间变长，同时在保活休眠状态降频会引入额外的 RX idle 等待时间和 RX 执行时间。具体实现需要用户自行权衡；降低系统频率之后需要使用函数 `power_set_sys_sleep_compensate_us` 和 `power_set_rf_sleep_compensate_us` 对系统休眠和 RF 休眠的补偿值进行微调
* 休眠补偿时间微调说明：

![](img\69.png)

* 低功耗模式下，统计从休眠唤醒到再次休眠这段时间内的收发包动作的功能可以在 `net/wifi_conf.c` 下通过将 `wifi_psmode_transfer_statistics_enable` 赋值为 1 打开；理想的低功耗保活状态下只会收到一个 rx 包，这个包是 AP 发来的 beacon 帧，不会出现发包；偶尔的一次 tx 是 AP 和 STA 之间的 NULL DATA 保活包，属于正常保活流程；其他的收发包动作，如 arp、正常收发数据帧等都会延迟系统进入休眠的流程而引入功耗；
* 收发数据动作需要保持清醒一段时间进行监听和发送，这个清醒时间的默认是 12 * 100ms（见 `net/wifi_conf.c` 的 `wl_transmit_keep_awake_time` 变量）；ARP 等传输量很小的动作并不需要 1200ms 那么长的清醒时间，在低功耗流程中，可以通过 `wl_set_transmit_keep_awake_time` 缩短清醒时间将休眠期间的功耗维持在理想保活的状态而不至于引入过多的 rx idle 时间，最小保持清醒时间为 100ms；当不进行休眠时，建议将保持清醒时间延长，例如恢复到默认的 1200 ms；

## 3.6.5. 常见问题：

* 测试低功耗时，功耗没变是什么原因？

答：可能是连接的路由器不支持PSmode模式，需要换一个其他路由器重新进行测试。

* AC79 WiFi 支持AP模式低功耗吗？

答：目前只支持STA模式下的节能模式。

# 3.7. Wi-Fi 抓包使用说明

**Overview**

WIFI抓包教程

## 3.7.1. Ominpeek安装及使用教程

(具体说明，请参考 `doc/stuff/Ominpeek使用教程.pdf`

其中：抓包器的驱动位于： `sdk_tools\RTLWlanU_WindowsDriver_sniffer_20130124.zip`

## 3.7.2. wifi连接认证流程抓包分析例子

(具体说明，请参考 `doc/stuff/wifi连接认证流程抓包分析.pdf`

## 3.7.3. 常见问题

**(1) 设备发送数据包，对方接收不到？**

答：通过抓包看看设备有没有成功发送的数据包，如果设备发送了数据包，但是没有接收到对方的ACK，证明对方接收不到数据包，此时需要对方进行故障排查。

**(2) 设备发送数据包后，还是不断进行数据包重发？**

答：通过抓包看看对方是否已经发送了ACK，如果对方已经发送了ACK，但是设备还是不断重发，证明设备没有接受到对方的ACK回复，此时需要对设备进行故障排查。

**(3) 对方发送数据包后，设备没有接受到？**

答：通过抓包分析对方是否已经成功发送了数据包，如果对方已经成功发送了数据包，证明设备接收不到数据包，此时需要对设备进行故障排查。

**(4) 设备不断接收到对方的同一个数据包？**

答：通过抓包分析设备是否接收到数据包后，回复对方ACK，如果设备成功回复了ACK，证明对方没有接收到ACK，此时需要对方进行故障排查。

**(5) 设备经常接收不到数据包？**

答：适当调整设备的接收灵敏度。

**(6) wifi连接不成功？**

答：参考 `doc/stuff/Ominpeek使用教程.pdf` , 通过抓包查看是扫描阶段（SCAN）、认证阶段（Authentication）、关联（Association）中的那一阶段造成的，再在该阶段中进行细化分析； 例如如果是在扫描阶段造成的，通过抓包看看STA是否成功发送了probe req，如果STA成功发送了probe req，再确认AP是否成功发送了probe rsp。 通过这种方式确认是那类型数据包丢失造成的，从而进行故障排查。

# 3.8. Wi-Fi AIRKISS配网示例说明

本工程展示了AirKiss配网接口的使用方法:

* AirKiss配网流程示例
* 杰理配网APP配网流程示例

**Note**

在使用AirKiss配网接口前，需要对AirKiss配网技术有一定的了解，详细可参考：https://iot.weixin.qq.com/wiki/new/index.html?page=4-1-1

AirKiss基本原理是，设置芯片在monitor模式下，通过抓取空中的包，利用数据帧的长度来承载有效信息 ，从而达到配网的目的。

## 3.8.1. 工程示例及配置说明

**example:**

* 进入 `apps/demo/demo_DevKitBoard/wifi_demo_task.c` ，开启宏 `#define MONITOR_MODE_TEST` 配置WIFI工作在混杂/监听/配网模式

## 3.8.2. 操作说明

* 编译工程，烧录镜像，复位启动后, 会自动进入配网模式
* 安装并打开 `sdk_tools/airkiss.apk` 软件,手机连接到某个用于AirKiss配网测试的wifi,在AirKissDebugger.apk软件中，填入要配网的wifi名、wifi密码及AES Key(默认不配置)，点击发送
* 等待串口打印配网结果并且连接上对应的路由器

## 3.8.3. 代码流程

* demo_wifi()入口：
  A）创建WIFI启动任务wifi_demo_task
* wifi_demo_task函数流程
  A）打开wifi并且进入配网模式
* wifi_event_callback()：
  A）case WIFI_EVENT_SMP_CFG_COMPLETED: 收到配网信息, 发送事件NET_SMP_CFG_COMPLETED到app_demo_event_handler,根据SSID完整性决定是否需要扫描空中SSID进行匹配
  B）case WIFI_EVENT_STA_SCAN_COMPLETED:扫描空中SSID完成,调用airkiss_ssid_check检测是否扫描到匹配的SSID, 然后发送NET_EVENT_SMP_CFG_FINISH事件到app_demo_event_handler进行连接对应的路由器
  C）case WIFI_EVENT_STA_NETWORK_STACK_DHCP_SUCC:连接路由器成功,发送事件NET_EVENT_CONNECTED到app_demo_event_handler,调用config_network_broadcast发送广播信号（告诉手机端AirKissDebugger.apk软件已经配网成功了）

## 3.8.4. 常见问题

* airkiss连接不上或连接超时怎么解决？
  答：1.检查aes_key是否设置正确；

  2.检查路由器是否是2.4G；

  3.检查路由器是否设置为支持20M或20M/40M。

# 3.9. Wi-Fi 使用底层RF搭建私有通信示例工程

当用户想绕过802.11和802.3协议栈,需要直接通过WIFI RF向空中发送一个原始的 802.11 数据包,实现传输私有通信协议,可以使用本工程提供的方法实现

## 3.9.1. 工程示例及配置说明

**example:**

* 具体的示例代码参考： `apps/common/example/wifi/private_communication/main.c`
* 工程实现：进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_Private_Communication`

## 3.9.2. 操作说明

* 编译工程，烧录镜像，复位启动
* 使用WIFI捉包工具可以看到如下图所示发出的数据包
  ![](https://doc.zh-jieli.com/AC79/zh-cn/master/_images/%E6%8A%93%E5%8C%85%E5%9B%BE.png)

## 3.9.3. 代码流程

* c_main()入口：
  > A）创建任务wifi_private_communication_test_task
  >
* wifi_private_communication_test_task
  > A）进入混杂模式,并且配置为只监听一个信道
  >
  > B） 注册接收802.11数据帧回调
  >
  > C） 配置WIFI RF 通信信道
  >
  > D） 配置底层重传次数
  >
  > E） 定时发送数据包测试
  >
* wifi_rx_cb入口：
  > A）打印接收到的数据帧
  >

# 3.10. Wi-Fi 路由器兼容性测试

请参考 `doc/stuff/Wi-Fi路由器测试表格`

# 3.11. Wi-Fi 场景功耗评估

请参考 `doc/stuff/Wi-Fi场景功耗评估`

# 3.12. Wi-Fi 吞吐率高低温测试

请参考 `doc/stuff/Wi-Fi吞吐率高低温测试`

# 3.13. Wi-Fi FCC 指标测试

**Overview**

基于FCC_Assist工具测试Wi-Fi的各项性能指标。

## 3.13.1. 工具概述

[![](img\71.png)](https://doc.zh-jieli.com/AC79/zh-cn/master/module_example/wifi/wifi_fcc_test.html)

FCC_Assist是一款由杰理科技开发，用于RF性能指标测试的专用软件，界面简洁、操作简单，支持EDR/BLE/Wi-Fi的性能指标测试。FCC_Assist工具获取路径 `sdk_tools/rf_fcc_test_tool`。

* (1)串口设置栏，用于配置串口参数；
* (2)指令菜单栏，用于切换不同的RF模式，支持EDR/BLE/Wi-Fi(打开串口后,也需要手动点击切换一下模式,点击后,日志栏会有红色提示出现)；
* (3)指令参数栏，用于选择具体的测试项及其对应的参数；
* (4)说明栏，选择测试指令后，会显示指令的具体用法，方便用户使用；
* (5)日志栏，显示测试指令的发送状态、运行状态。

## 3.13.2. 软件配置(以故事机工程 `app_config.h` 为例)

> ```
> #define RF_FCC_TEST_ENABLE       //使能RF_FCC测试
>
> #ifdef RF_FCC_TEST_ENABLE
> // #define RF_FCC_IN_NORNAL_WORK    //使能在正常工作模式下进行RF_FCC测试
>
> #define IO_TRIGGER_MODE      (0)    //"IO检测"方式触发进入RF_FCC测试模式
> #define UART_CMD_MODE        (1)    //"串口指令"方式触发进入RF_FCC测试模式
> #define USER_DEF_MODE        (2)    //"用户定义"方式触发进入RF_FCC测试模式
>
> #define CONFIG_RF_FCC_TRIGGER_MODE      UART_CMD_MODE   //RF_FCC触发方式配置
> #define CONFIG_RF_FCC_TRIGGER_IO_PORT   IO_PORTA_03    //RF_FCC触发IO配置
> #define CONFIG_RF_FCC_TRIGGER_IO_STATE  (0)            //RF_FCC触发IO的状态配置，0:低电平触发，1:高电平触发
>
> #endif //RF_FCC_TEST_ENABLE
> ```

* 宏 `RF_FCC_TEST_ENABLE`为FCC测试总开关，使能该宏后SDK将支持FCC测试，代码量额外增加32K；
* 宏 `CONFIG_RF_FCC_TRIGGER_MODE`用于配置进入FCC测试的触发方式，支持以下三种触发方式：

1)IO检测：上电检测指定IO的电平状态，当IO处于指定状态时将进入FCC测试模式。

2)串口指令： 通过串口发送特定指令给被测设备，从而进入FCC测试模式，相应指令如下:

```
static u8 FCC_WIFI_ARRAY[] = {0x01, 0xA1, 0xA2, 0x06, 0x01, 0x02, 0x03, 0x04, 0x05, 0x01}; //进入wifi模式
static u8 FCC_BT_ARRAY[]   = {0x01, 0xA1, 0xA2, 0x06, 0x01, 0x02, 0x03, 0x04, 0x05, 0x02}; //进入bt模式
static u8 FCC_RSP_ARRAY[]  = {0x04, 0x0E, 0x01, 0x01, 0xA1, 0xA2, 0x00};                   //指令响应
```

3)用户定义：用户可根据自身硬件情况，选择其他触发方式；用户定义并实现函数 `u8 fcc_enter_user_def(void)`，该函数将在上电过程中运行一次，返回TRUE即可进入FCC测试模式。

## 3.13.3. 测试步骤

* (1)建立硬件连接，如下图所示；

![](img\72.png)

* (2)进入测试模式，按照设定的测试模式触发方式进入测试模式；
* (3)点击指令菜单栏中的“WIFI”项，日志栏显示“成功切换到WIFI模式”，“设备启动成功”，如下图所示；

[![](img\73.png)](https://doc.zh-jieli.com/AC79/zh-cn/master/module_example/wifi/wifi_fcc_test.html)

* (4)选择相应的测试命令，配合仪器完成Wi-Fi指标的测试。

# 3.14. 外挂WiFi模组

**Overview**

AC79支持以SDIO接口外挂WiFi模组，目前已支持WiFi模组型号：RTL8189E / RTL8822ES_10M / RTL8822CS。参考工程demo_ext_wifi

## 3.14.1. 配置说明

- （1）添加库文件

[![](img\74.png)](https://doc.zh-jieli.com/AC79/zh-cn/master/module_example/wifi/wifi_ext.html)

库文件说明如上。 同时，需要在编译选项中加入对应WiFi模组的全局宏：CONFIG_RTL8189E_ENABLE / CONFIG_RTL8822ES_10M_ENABLE / CONFIG_RTL8822CS_ENABLE。

* （2） 板级文件配置

配置参数如下：

> ```
> struct wifi_platform_data {
> enum WIFI_MODULE module;
> u32 sdio_parm;
> int wakeup_port;
> int cs_port;
> int power_port;
> };
> ```

* 1)WiFi模组名称配置

module配置对应的模组名称。

* 2)SDIO引脚配置

> [![](img\75.png)](https://doc.zh-jieli.com/AC79/zh-cn/master/module_example/wifi/wifi_ext.html)
>
> SDIO_GRP_x和SDIO_PORT_x用于配置SDIO引脚，引脚定义顺序（cmd/clk/data0/data1/data2/data3），引脚定义如上。

* 3)SDIO数据位配置 SDIO支持1Bit和4Bit，使用1Bit数据宽度配置为SDIO_1_BIT_DATA，使用4Bit数据宽度则配置为SDIO_4_BIT_DATA。
* 4)SDIO数据接收方式配置 SDIO支持中断方式和轮询方式接收数据，使用中断方式配置为SDIO_DATA1_IRQ，使用轮询方式配置为SDIO_POLLING。
* 5)SDIO时钟配置 SDIO时钟配置项：SDIO_CLOCK_80M / SDIO_CLOCK_40M / SDIO_CLOCK_26M / SDIO_CLOCK_20M / SDIO_CLOCK_16M / SDIO_CLOCK_8M / SDIO_CLOCK_4M / SDIO_CLOCK_2M，根据需要选配。
* 6)WiFi引脚配置 wakeup_port / cs_port / power_port与WiFi模组引脚对应，若这些引脚接固定电平，则无需配置
* （3） LWIP配置

进入LWIP工程，在lwip.c文件中打开宏”HAVE_EXT_WIRELESS_NETIF”，以增加支持外挂WiFi模组，Rebuild工程。

* （4） WiFi基本配置

在apps/common/net/ext_wifi_conf.c文件中，提供了AP模式下的配置hostapd_config_file，STA模式下的配置wps_hostapd_config_file，可根据需要修改相应的配置文件。

## 3.14.2. WiFi事件状态

[![](img\76.png)](https://doc.zh-jieli.com/AC79/zh-cn/master/module_example/wifi/wifi_ext.html)

在WiFi工作工程中，驱动会将WiFi当前的事件状态通过回调函数返回至应用层，用户可以在回调函数中添加事件状态的自定义处理，demo_wifi_ext/ext_wifi_app_task.c->network_user_callback()，WiFi事件状态定义如上。

## 3.14.3. WiFi控制

在板级文件中，已将外挂WiFi模组注册到系统设备列表中，因此可通过设备控制指令对WiFi模组进行操作，示例如下:

```
static void *wifi_dev = NULL;
struct cfg_info info = {0};
wifi_dev = dev_open("wifi", NULL);
info.cb = network_user_callback;
info.net_priv = NULL;
dev_ioctl(wifi_dev, DEV_SET_CB_FUNC, (u32)&info);
dev_close(wifi_dev);
```

[![](img\77.png)](https://doc.zh-jieli.com/AC79/zh-cn/master/module_example/wifi/wifi_ext.html)

WiFi模组控制指令定义如上。
