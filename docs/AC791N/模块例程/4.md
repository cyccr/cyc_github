# 4. 蓝牙部分

# 4.1. 概述

# 4.2. 蓝牙接口

# 4.3. SPP协议

**概述**

提供蓝牙串口SPP协议的配置接口和测试例程

## 4.3.1. 测试例程

* 1. 进入 `apps/demo/demo_edr/include/app_config.h` ，开启宏 `SPP_TRANS_DATA_EN`
* 2. 进入 `apps/demo/demo_edr/spp_trans_data.c` ，开启宏 `TEST_SPP_DATA_RATE`
* 3. 设备烧录固件后上电，打开手机app里的SppTestDemo.apk（SDK的工具目录有安装包），扫描到设备后点击连接
* 4. 设备每秒打印一次发送速率 ``-spp_data_rate: 162360 bytes, 158 kbytes-``

## 4.3.2. 常见问题

**Note**

1.测试例程的SPP传输速率大概平均150kbytes

2.接收数据时可根据需要选择是否使能流控功能

3.若发送过程中出现 `pend_for_tx_bulk` 的打印，可在app_config.h适当增大底层缓存BUF `CONFIG_BT_TX_BUFF_SIZE` ，例如改成12K，但最大不能超过20K

4.#define TEST_SPP_SEND_SIZE 660 //660字节为一包发送最大数据

5.使用调用transport_spp_send_data发送数据要检查一下返回值，返回值失败的要应用层重发，防止丢失数据

## 4.3.3. API参考

流控配置

**SPP_DATA_RECIEVT_FLOW**
确定配置接口transport_spp_flow_cfg被调用后，在连接过程中通过接口transport_spp_flow_enable来控制流控开关

**FLOW_SEND_CREDITS_NUM**
流控速度控制，控制命令中控制可接收的数据包个数，发送给对方的range(1~32)

**FLOW_SEND_CREDITS_TRIGGER_NUM**
触发更新控制命令的阈值，range(1 to <= FLOW_SEND_CREDITS_NUM)

int **transport_spp_send_data** (u8 *data, u16 len)
spp传输发送数据

Parameters：

* **data** – **[in]** 准备发送的数据指针
* **len** – **[in]** 准备发送的数据长度

Returns：	0: 发送成功
Returns：	other: 发送失败

int **transport_spp_send_data_check**(u16 len)
检查spp是否允许发送数据

Parameters：
**len** – **[in]** 准备发送的数据长度

Returns：	1: 允许发送
Returns：	0: 发送忙碌

static void **transport_spp_state_cbk**(u8 state)
spp传输状态回调

Parameters：	**state** – **[in]** 连接状态

static void **transport_spp_send_wakeup**(void)
spp传输唤醒回调

static void **transport_spp_recieve_cbk**(void *priv, u8 *buf, u16 len)**
spp数据接收回调

Parameters：

* **priv** – **[in]** spp_channel
* **buf** – **[in]** 接收到的数据指针
* **len** – **[in]** 接收到的数据长度

void **transport_spp_init**(void)
初始化spp传输接口

**Note**
需要在蓝牙协议栈初始化btstack_init()成功后收到BT_STATUS_INIT_OK消息后调用

**void transport_spp_disconnect(void)**
断开SPP传输连接

**static void timer_spp_flow_test(void)**

**void transport_spp_flow_cfg(void)**
配置SPP传输接收流控控制参数

**Note**
需要在蓝牙协议栈初始化btstack_init()前调用

int **transport_spp_flow_enable**(u8 en)
SPP传输接收流控开关

Parameters：	**en** – **[in]** 1-打开 0-关闭

Returns：	0: 成功
Returns：	other: 失败

# 4.4. 蓝牙发射器

**概述**

简单介绍蓝牙发射器的使用流程

## 4.4.1. 操作说明

* 1. 在app_config.h中打开宏

> * #define TCFG_USER_BT_CLASSIC_ENABLE 1 //经典蓝牙功能
> * #define TCFG_USER_EMITTER_ENABLE 1 //蓝牙发射功能
> * #define CONFIG_POWER_ON_ENABLE_BT 1 //开机自动打开经典蓝牙（demo_edr默认开启，wifi_story_machine未开启需使用时通过按键开启蓝牙）

* 2. 蓝牙发射功能(bt_emitter.c)：蓝牙发射搜索结果回调处理，根据过滤规则可以做名字过滤、地址过滤、自定义过滤和无限制规则，也可以保存搜索到的所有设备再选择一个进行连接
* 3. 在选择使用的过滤方式下填入所需连接的蓝牙参数（名称或地址）
* 4. 蓝牙发射 提供按键切换发射器或者是音箱功能：2:发射 1：接收 0: 关闭
* 5. 发射器设置回调包括设备名字name、设备名字长度len、设备类型class和设备信号强度rssi等

```
//bt_emitter.c
//首先通过宏选择使用的过滤方式
#define  SEARCH_BD_ADDR_LIMITED 0  //搜索蓝牙地址过滤
#define  SEARCH_BD_NAME_LIMITED 1  //搜索蓝牙名称过滤
#define  SEARCH_CUSTOM_LIMITED  2  //自定义搜索
#define  SEARCH_NULL_LIMITED    3  //没有指定限制，则搜到什么就连接什么

#define SEARCH_LIMITED_MODE  SEARCH_BD_NAME_LIMITED    //选择过滤方式

//地址过滤
#if (SEARCH_LIMITED_MODE == SEARCH_BD_ADDR_LIMITED)
static const u8 bd_addr_filt[][6] = {
    {0x8E, 0xA7, 0xCA, 0x0A, 0x5E, 0xC8}, /*S10_H*/
    {0xA7, 0xDD, 0x05, 0xDD, 0x1F, 0x00}, /*ST-001*/
    {0xE9, 0x73, 0x13, 0xC0, 0x1F, 0x00}, /*HBS 730*/
    {0x38, 0x7C, 0x78, 0x1C, 0xFC, 0x02}, /*Bluetooth*/
    //{0xXX, 0xXX, 0xXX, 0xXX, 0xXX, 0xXX}, /*填入所需搜索连接蓝牙地址*/
};

/*----------------------------------------------------------------------------*/
/**@brief    蓝牙发射搜索通过地址过滤
@param    无
@return   无
@note
*/
/*----------------------------------------------------------------------------*/
static u8 search_bd_addr_filt(const u8 *addr)
{
    log_i("bd_addr:");
    put_buf(addr, 6);

    for (u8 i = 0; i < (sizeof(bd_addr_filt) / sizeof(bd_addr_filt[0])); i++) {
        if (memcmp(addr, bd_addr_filt[i], 6) == 0) {
            /* printf("bd_addr match:%d\n", i); */
            return TRUE;
        }
    }
    /*log_i("bd_addr not match\n"); */
    return FALSE;
}
#endif

//名称过滤
#if (SEARCH_LIMITED_MODE == SEARCH_BD_NAME_LIMITED)
#if 0
static const u8 bd_name_filt[][32] = {
    "BeMine",
    "EDIFIER CSR8635",/*CSR*/
    "JL-BT-SDK",/*Realtek*/
    "I7-TWS",/*ZKLX*/
    "TWS-i7",/*ZKLX*/
    "I9",/*ZKLX*/
    "小米小钢炮蓝牙音箱",/*XiaoMi*/
    "小米蓝牙音箱",/*XiaoMi*/
    "XMFHZ02",/*XiaoMi*/
    "JBL GO 2",
    "i7mini",/*JL tws AC690x*/
    "S08U",
    "AI8006B_TWS00",
    "S046",/*BK*/
    "AirPods",
    "CSD-TWS-01",
    "AC692X_wh",
    "JBL GO 2",
    "JBL Flip 4",
    "BT Speaker",
    "CSC608",
    "QCY-QY19",
    "Newmine",
    "HT1+",
    "S-35",
    "T12-JL",
    "Redmi AirDots_R",
    "Redmi AirDots_L",
    "AC69_Bluetooth",
    "FlyPods 3",
    "MNS",
    "Jam Heavy Metal",
    "Bluedio",
    "HR-686",
    "BT MUSIC",
    "BW-USB-DONGLE",
    "S530",
    "XPDQ7",
    "MICGEEK Q9S",
    "S10_H",
    "S10",/*JL AC690x*/
    "S11",/*JL AC460x*/
    "HBS-730",
    "SPORT-S9",
    "Q5",
    "IAEB25",
    "T5-JL",
    "MS-808",
    "LG HBS-730",
    "NG-BT07"
};
#else
static const u8 bd_name_filt[][30] = {
    "JL-AC79XX-AF0B",
    "JL-AC79XX-AAFF",
    //"填入所需搜索连接蓝牙名称"
};
#endif

/*----------------------------------------------------------------------------*/
/**@brief    蓝牙发射搜索通过名字过滤
@param    无
@return   无
@note
*/
/*----------------------------------------------------------------------------*/
u8 search_bd_name_filt(const char *data, u8 len, u32 dev_class, char rssi)
{
    char bd_name[64] = {0};

    if ((len > (sizeof(bd_name))) || (len == 0)) {
        return FALSE;
    }

    memcpy(bd_name, data, len);
    log_i("name:%s,len:%d,class %x ,rssi %d\n", bd_name, len, dev_class, rssi);

    for (u8 i = 0; i < (sizeof(bd_name_filt) / sizeof(bd_name_filt[0])); i++) {
        if (memcmp(data, bd_name_filt[i], len) == 0) {
            log_i("\n*****find dev ok******\n");
            return TRUE;
        }
    }

    return FALSE;
}
#endif

/*----------------------------------------------------------------------------*/
/**@brief    蓝牙发射搜索结果回调处理
@param    name : 设备名字
            name_len: 设备名字长度
            addr:   设备地址
            dev_class: 设备类型
            rssi:   设备信号强度
@return   无
@note
            蓝牙设备搜索结果，可以做名字/地址过滤，也可以保存搜到的所有设备
            在选择一个进行连接，获取其他你想要的操作。
            返回TRUE，表示搜到指定的想要的设备，搜索结束，直接连接当前设备
            返回FALSE，则继续搜索，直到搜索完成或者超时
*/
/*----------------------------------------------------------------------------*/
u8 emitter_search_result(char *name, u8 name_len, u8 *addr, u32 dev_class, char rssi)
{
    if (emitter_or_receiver != BT_EMITTER_EN) {
        return 0;
    }

#if (SEARCH_LIMITED_MODE == SEARCH_BD_NAME_LIMITED)
    if (name == NULL) {
        struct inquiry_noname_remote *remote = zalloc(sizeof(struct inquiry_noname_remote));
        remote->match = 0;
        remote->class = dev_class;
        remote->rssi = rssi;
        memcpy(remote->addr, addr, 6);
        os_mutex_pend(&mutex, 0);
        list_add_tail(&remote->entry, &inquiry_noname_list);
        if (read_name_start == 0) {
            read_name_start = 1;
            user_send_cmd_prepare(USER_CTRL_READ_REMOTE_NAME, 6, addr);
        }
        os_mutex_post(&mutex);
    }
#endif

#if (SEARCH_LIMITED_MODE == SEARCH_BD_NAME_LIMITED)
    return search_bd_name_filt(name, name_len, dev_class, rssi);
#endif

#if (SEARCH_LIMITED_MODE == SEARCH_BD_ADDR_LIMITED)
    return search_bd_addr_filt(addr);
#endif

#if (SEARCH_LIMITED_MODE == SEARCH_CUSTOM_LIMITED)
    /*以下为搜索结果自定义处理*/
    char bt_name[63] = {0};
    u8 len;
    if (name_len == 0) {
        log_i("No_eir\n");
    } else {
        len = (name_len > 63) ? 63 : name_len;
        /* display bd_name */
        memcpy(bt_name, name, len);
        log_i("name:%s,len:%d,class %x ,rssi %d\n", bt_name, name_len, dev_class, rssi);
    }

    /* display bd_addr */
    put_buf(addr, 6);

    /* You can connect the specified bd_addr by below api      */
    //user_send_cmd_prepare(USER_CTRL_START_CONNEC_VIA_ADDR,6,addr);

    return FALSE;
#endif

#if (SEARCH_LIMITED_MODE == SEARCH_NULL_LIMITED)
    /*没有指定限制，则搜到什么就连接什么*/
    return TRUE;
#endif
}
```

```
//demo_edr在bt_music.c的bt_music_key_event_handler()长按KEY_MODE切换发射器和接收器
case KEY_MODE:
#if TCFG_USER_EMITTER_ENABLE
            //发射器或者接收器切换
            if (__this->enable) {
                if (__this->emitter) {
                    bt_emitter_disable();
                } else {
                    key_event_disable();
                    bt_connection_disable();
                    sys_timeout_add(NULL, bt_emitter_enable, 1000);
                }
            }
#endif
            break;

//wifi_story_machine在app_music.c的app_music_key_long（）中切换发射器和接收器
static int app_music_key_long(struct key_event *key)
{
    switch (key->value) {
    case KEY_OK:
#if TCFG_USER_EMITTER_ENABLE
        if (__this->bt_music_enable) {
            if (__this->bt_emitter_enable) {
                app_music_play_voice_prompt("BtClose.mp3", bt_emitter_switch_to_receiver);
            } else {
                app_music_play_voice_prompt("BtOpen.mp3", bt_emitter_enable);
                bt_connection_disable();
            }
        }
#endif
        break;
```

## 4.4.2. 效果展示

* 1. demo_edr工程将主机的mic采集数据通过发射器传输到从机播放
* 2. wifi_story_machine工程将主机播放的数据通过发射器传输到从机播放

## 4.4.3. 接口说明

* 1. emitter代码文件：bt_emitter.c
* 2. bt_emitter接口说明

> * （1）emitter_rx_avctp_opid_deal ：蓝牙发射接收到设备按键消息
> * （2）emitter_rx_vol_change ：蓝牙发射接收设备同步音量
> * （3）emitter_media_source ：蓝牙发射开启关闭通道

## 4.4.4. 代码流程

* 1. demo_edr工程

> * （1）app_main.c：在app_main函数中调用bt_ble_module_init函数初始化蓝牙模块
> * （2）bt_music.c：在蓝牙开启的状态长按KEY_MODE按键进行发射器跟接收器的切换,初始化蓝牙发射器
> * （3）bt_emitter.c：在开启发射器后,设备会先轮询保存在vm中的设备是否可连接,如果是则连接最近的一台接收器,否则从设备过滤清单中找出可连接的设备

* 2. wifi_story_machine工程

> * （1）app_music.c：通过按键打开蓝牙功能app_music_key_click（）的KEY_MDOE
> * （2）app_music.c: 通过长按按键切换到发射器模式app_music_key_long的KEY_OK
> * （3）bt_emitter.c：在开启发射器后,设备会先轮询保存在vm中的设备是否可连接,如果是则连接最近的一台接收器,否则从设备过滤清单中找出可连接的设备

# 4.5. 蓝牙低功耗

**概述**

使用demo_edr工程配置蓝牙低功耗。

## 4.5.1. 操作说明

* 1. 在app_config.h文件中修改以下宏：

```
#define CONFIG_LOW_POWER_ENABLE              //软关机/睡眠开关
#define TCFG_LOWPOWER_LOWPOWER_SEL                  (RF_SLEEP_EN | SYS_SLEEP_EN | RF_FORCE_SYS_SLEEP_EN | SYS_SLEEP_BY_IDLE)
```

* 2. 设置蓝牙功率接口( 详情查询[btcontroller_modules.h]() )

```
/* --------------------------------------------------------------------------*/
/**
* @brief 初始化配置蓝牙发射功率最大值范围
*
* @param pwr    edr 连接后发射功率(range:0~9)
* @param pg_pwr edr page 可连接状态发射功率
* @param iq_pwr edr inquiry 可发现状态发射功率
* @param ble_pwr ble 发射功率
*/
/* ----------------------------------------------------------------------------*/
/*
蓝牙TX发射功率档位, 参考功率值(dbm) ,超过等级范围默认设置为最高档
BD29: rang(0~8)  {-18.3,  -14.6,  -12.1, -8.5,  -6.0,  -4.1,  -1.1,  +1.1,  +4.0,  +6.1}
BD19: rang(0~10) {-17.6,  -14.0,  -11.5, -9.6,  -6.6,  -4.4,  -0.79, +1.12, +3.8,  +5.65, +8.04}
BR23: rang(0~9)  {-15.7,  -12.5,  -10.0, -6.6,  -4.4,  -2.5,  -0.1,  +2.1,  +4.6,  +6.4}
BR25: rang(0~9)  {-15.7,  -12.5,  -10.0, -6.6,  -4.4,  -2.5,  -0.1,  +2.1,  +4.6,  +6.4}
BR30: rang(0~8)  {-17.48, -11.46, -7.96, -3.59, -0.79, +1.12, +3.8,  +6.5,  +8.44}
BR34: rang(0~10) {-17.6,  -14.0,  -11.5, -9.6,  -6.6,  -4.4,  -1.8,  0,     +2.1,  +4,    +6.3}
*/

void bt_max_pwr_set(u8 pwr, u8 pg_pwr, u8 iq_pwr, u8 ble_pwr);

/* --------------------------------------------------------------------------*/
/**
* @brief ble_set_fix_pwr
*
* @param fix (0~max)
* 动态调整BLE的发射功率
*/
/* ----------------------------------------------------------------------------*/
void ble_set_fix_pwr(u8 fix);


/* --------------------------------------------------------------------------*/
/**
* @brief bredr_set_fix_pwr
*
* @param fix (0~max)
* 动态调整EDR的发射功率
*/
/* ----------------------------------------------------------------------------*/
void bredr_set_fix_pwr(u8 fix);
```

* 3. 蓝牙低功耗设置IO唤醒

  > 在第一点的基础上, 在班级文件中, 定义如下:
  >

```
/************************** PWR config ****************************/
#define PORT_WAKEUP_IO                      IO_PORTB_01                                     //软关机和休眠唤醒引脚
#define PORT_WAKEUP_NUM                     (PORT_WAKEUP_IO/IO_GROUP_NUM)//默认:0-7:GPIOA-GPIOH, 可以指定0-7组

static const struct port_wakeup port0 = {
    .edge       = FALLING_EDGE,                            //唤醒方式选择,可选：上升沿\下降沿
    .attribute  = BLUETOOTH_RESUME,                        //蓝牙低功耗唤醒 BLUETOOTH_RESUME 参数必须保留
    .iomap      = PORT_WAKEUP_IO,                          //唤醒口选择
    .low_power      = POWER_SLEEP_WAKEUP|POWER_OFF_WAKEUP,    //低功耗IO唤醒,不需要写0
};

static const struct wakeup_param wk_param = {
.port[PORT_WAKEUP_NUM] = &port0,
.sub = &sub_wkup,
.charge = &charge_wkup,
.lpres = &lpres_port,
};

//-------------------------分割线--------------------

static void board_power_init(void)
{
    power_init(&power_param);

    power_keep_state(POWER_KEEP_RESET);

    power_wakeup_init(&wk_param);
}
```

板级设置完成后, 还需要设置在IO唤醒后的回调, 在程序进入低功耗前注册即可

```
void callback()
{
    //自行实现
}

//可以在app_main.c中调用
set_port_wakeup_cb(callback);     //该回调为在低功耗sleep模式下的时候IO唤醒调用
    port_wakeup_reg(EVENT_IO_0, IO_PORTA_00, 0,     callback);    //该回调为程序正常运行模式idle下IO唤醒调用, IO口自行配置
```

应用: 可以在IO唤醒后锁住不继续进入低功耗, 则callback可以设置为 `low_power_sys_unsleep_lock` ,该函数可以锁住系统不再进入低功耗; 可以调用 `low_power_sys_unsleep_unlock` 退出锁, 函数参考 `include_lib/driver/cpu/wl82/asm/power_interface.h`

# 4.6. RF共存

**概述**

> 当要求wifi和蓝牙同时工作时，针对实际环境中不同的应用场景，提供相应的RF共存参数，达到最佳的匹配效果。

## 4.6.1. 应用场景

* 参数表0：均衡模式1-适用于wifi连接路由器后且edr未连接的场景
* 参数表1：均衡模式2-适用于edr配对后(接收模式)，适用于蓝牙接收多，发送少的场景，wifi此时保持路由器的连接
* 参数表2：蓝牙绝对优先模式-wifi只能在蓝牙空闲的片段里工作，对wifi的带宽有较大影响
* 参数表3：wifi绝对优先模式-常用于要求开机后wifi快速连上路由器，不受蓝牙回连干扰，但不抢BLE的带宽，对edr的带宽有较大影响
* 参数表4：wifi相对优先模式-优先保证wifi的收发，但蓝牙媒体播放和通话会可能卡顿，不抢BLE的带宽
* 参数表5：均衡模式3-适用于edr配对后(发送模式)，适用于蓝牙发送多，接收少的场景
* 参数表6：均衡模式4-791x新增细调优先级测试，用于替代参数表1，适用于edr接收多的均衡共存模式
* 参数表7：均衡模式5-常用于设备edr主动回连和搜索空中设备时释放部分带宽给wifi使用

## 4.6.2. 常见问题

**Note**

1.只要开机初始化了wifi和蓝牙模块，就需要RF共存调节模块的参与，默认使用参数表0

2.RF共存模块的工作原理实际上就是调整wifi和蓝牙各自占用RF的带宽比例，当要求保证一方的性能时，肯定会以牺牲另外一方的性能为条件

## 4.6.3. API参考

**void switch_rf_coexistence_config_table(u8 index)**
切换RF共存参数表

Parameters：
**index** – **[in]** 参数表序号

**void switch_rf_coexistence_config_lock(void)**
锁定RF共存参数表

**Note**
锁定后再切换参数表将无效

**void switch_rf_coexistence_config_unlock(void)**
解锁RF共存参数表

**u8 get_rf_coexistence_config_index(void)**
获取当前RF共存参数表的序号

Returns：
当前参数表的序号

# 4.7. BLE应用接口

**概述**

介绍BLE的应用层的接口使用方法

## 4.7.1. API参考

**ble_op_set_own_address_type(address_type)**
配置设备的地址类型，默认为 0(public address).

**Note**
!!!注意:设置的时候必须在、设置广播参数、或者扫描参数、或者创建连接参数前配置好.

Parameters：

* **address_type** – **[in]** Range: 0x00 to 0x03.

Returns：
see ble_cmd_ret_e.

**ble_op_adv_enable(enable)**
开关BLE广播.

**Note**
!!!注意：开广播前必现先配置好广播的参数.

Parameters：

* **enable** – **[in]** 广播使能 :0(dis) or 1(en).

Returns：
see ble_cmd_ret_e.

**ble_op_set_adv_filter_policy(type)**
配置广播过滤策略(决定链路层如何处理扫描、连接请求);默认为 0.

**Note**
!!!注意：设置的时候必须在"设置广播参数ble_op_set_adv_param前配置好.

Parameters：

* **type** – **[in]** 类型 :Range: 0x00 to 0x03.

Returns：
see ble_cmd_ret_e.

**ble_op_set_adv_param(adv_interval, adv_type, adv_channel)**
配置广播参数.

**Note**
!!!注意：设置的时候必现在广播关闭的状态下.

Parameters：

* **adv_interval** – **[in]** 广播周期,Range: 0x0020 to 0x4000 (unit: 0.625ms).
* **adv_type** – **[in]** 广播类型,Range: 0x00 to 0x04.
* **adv_channel** – **[in]** 广播类型通道,range:Range: 0x01 to 0x07.

Returns：
see ble_cmd_ret_e.

**ble_op_set_adv_param_ext(adv_interval, adv_type, adv_channel, peer_info)**
配置广播参数+配对信息(相比配对广播参数,这个函数主要是针对定向广播使用).

**Note**
!!!注意：设置的时候必现在广播关闭的状态下.

Parameters：

* **adv_interval** – **[in]** 广播周期,Range: 0x0020 to 0x4000 (unit: 0.625ms).
* **adv_type** – **[in]** 广播类型,Range: 0x00 to 0x04.
* **adv_channel** – **[in]** 广播类型通道,range:Range: 0x01 to 0x07.
* **peer_info** – **[in]** (全局变量地址),定向广播时，填入对方的地址信息.

Returns：
see ble_cmd_ret_e.

**ble_op_set_adv_data(adv_len, adv_data)**
配置广播 Advertising Data内容.

**Note**
!!!注意：设置的时候必现在广播关闭的状态下.

Parameters：

* **adv_len** – **[in]** adv 数据包长度，Range: 0x00 to 0x1f.
* **adv_data** – **[in]** (全局变量地址)，adv数据包地址.

Returns：
see ble_cmd_ret_e.

**ble_op_set_rsp_data(rsp_len, rsp_data)**
配置广播 Scan Response Data内容.

**Note**
!!!注意：设置的时候必现在广播关闭的状态下.

Parameters：

* **rsp_len** – **[in]** rsp 包长度，Range: 0x00 to 0x1f.
* **adv_data** – **[in]** (全局变量地址)，rsp数据包地址.

Returns：
see ble_cmd_ret_e.

**ble_op_disconnect(con_handle)**
请求断开 ble 连接.

Parameters：

* **con_handle** – **[in]** range: >0.

Returns：
see ble_cmd_ret_e.

**ble_op_disconnect_ext(con_handle, reason)**
请求断开 ble 连接,by reason

Parameters：

* **con_handle** – **[in]** range: >0.
* **reason** – **[in]** range: see spec.

Returns：
see ble_cmd_ret_e.

**ble_op_att_send_init(con_handle, att_ram_addr, att_ram_size, att_payload_size)**
配置ATT发送模块RAM大小.

Parameters：

* **con_handle** – **[in]** range: >0.
* **att_ram_addr** – **[in]** 传入ATT发送模块ram地址，地址按4字节对齐.
* **att_ram_size** – **[in]** 传入ATT发送模块ram大小.
* **att_payload_size** – **[in]** 发送ATT包payload的最大长度 <= MTU的payload,range：20 to MTU的payload size.

Returns：
see ble_cmd_ret_e.

**ble_op_multi_att_send_init(att_ram_addr, att_ram_size, att_payload_size)**
MULTI API: 配置ATT发送模块初始化.

**Note**
多机处理,只需要初始化一次就可以.

Parameters：

* **att_ram_addr** – **[in]** 传入ATT发送模块ram地址，地址按4字节对齐.
* **att_ram_size** – **[in]** 传入ATT发送模块ram大小.
* **att_payload_size** – **[in]** 发送ATT包payload的最大长度 <= MTU的payload，range：20 to MTU的payload size.

Returns：
see ble_cmd_ret_e.

**ble_op_multi_att_send_conn_handle(con_handle, handle_index, role)**
MULTI API: 配置ATT模块 使用的连接con_handle.

**Note**
多机处理.

Parameters：

* **con_handle** – **[in]** range：>0.
* **handle_index** – **[in]** range: 0~7 //多连接的hanlde id.
* **role** – **[in]** range: 0-gatt_sever,1-gatt_client.

Returns：
see ble_cmd_ret_e.

**ble_op_att_set_send_mtu(mtu)**
根据对方的接收MTU大小，配置本地可发送MTU的payload大小.

Parameters：

* **mtu** – **[in]** 对方mtu payload的大小.

Returns：
see ble_cmd_ret_e.

**ble_op_multi_att_set_send_mtu(con_handle, mtu)**
MULTI API: 根据对方的接收MTU大小，配置本地可发送的MTU的大小.

Parameters：

* **con_handle** – **[in]** 连接 con_handle,range：>0.
* **mtu** – **[in]** 对方mtu payload的大小.

Returns：
see ble_cmd_ret_e.

**ble_op_att_get_remain(remain_size_ptr)**
获取ATT发送模块，cbuffer可写入数据的长度.

Parameters：

* **remain_size_ptr** – **[out]** 输出可写入长度值.

Returns：
see ble_cmd_ret_e.

**ble_op_multi_att_get_remain(con_handle, remain_size_ptr)**
MULTI API: 获取ATT发送模块，cbuffer 可写入数据的长度.

Parameters：

* **con_handle** – **[in]** range：>0.
* **remain_size_ptr** – **[out]** 输出可写入长度值.

Returns：
see ble_cmd_ret_e.

**ble_op_att_send_data(att_handle, data, len, att_op_type)**
ATT操作handle发送数据.

Parameters：

* **att_handle** – **[in]** att操作的handle.
* **data** – **[in]** 数据地址.
* **len** – **[in]** 数据长度 <= cbuffer 可写入的长度.
* **att_op_type** – **[in]** see att_op_type_e (att.h).

Returns：
see ble_cmd_ret_e.

**ble_op_multi_att_send_data(con_handle, att_handle, data, len, att_op_type)**
MULTI API: ATT操作handle发送数据.

**Note**
多机处理.

Parameters：

* **con_handle** – **[in]** 连接 con_handle,range：>0.
* **att_handle** – **[in]** att操作handle.
* **data** – **[in]** 数据地址.
* **len** – **[in]** 数据长度 <= cbuffer 可写入的长度.
* **att_op_type** – **[in]** see att_op_type_e (att.h).

Returns：
see ble_cmd_ret_e.

**ble_op_att_clear_send_data(void)**
ATT操作,清缓存发送的数据缓存

Returns：
see ble_cmd_ret_e.

**ble_op_conn_param_request(con_handle, con_param)**
从机请求更新连接参数,走l2cap命令.

Parameters：

* **con_handle** – **[in]** 连接 con_handle,range：>0.
* **con_param** – **[in]** (全局变量地址),连接参数.

Returns：
see ble_cmd_ret_e.

**ble_op_set_data_length(con_handle, tx_octets, tx_time)**
发起data length 交换.(btctrl的feature打开支持DLE)

Parameters：

* **tx_octets** – **[in]** DLE发送长度.
* **tx_time** – **[in]** DLE发送事件.

Returns：
see ble_cmd_ret_e.

**ble_op_set_ext_adv_param(param, param_len)**
ble5.0 配置广播参数.

Parameters：

* **param** – **[in]** 广播参数.
* **tx_time** – **[in]** 参数长度.

Returns：
see ble_cmd_ret_e.

**ble_op_set_ext_adv_data(data, data_len)**
ble5.0 配置 adv 数据包.

Parameters：

* **data** – **[in]** 数据包内容.
* **data_len** – **[in]** 数据包长度.

Returns：
see ble_cmd_ret_e.

**ble_op_set_ext_rsp_data(data, data_len)**
ble5.0 配置 respond 数据包.

Parameters：

* **data** – **[in]** 数据包内容.
* **data_len** – **[in]** 数据包长度.

Returns：
see ble_cmd_ret_e.

**ble_op_set_ext_adv_enable(cmd, cmd_len)**
ble5.0 开关广播.

Parameters：

* **cmd** – **[in]** 命令信息.
* **cmd_len** – **[in]** 命令长度.

Returns：
see ble_cmd_ret_e.

**ble_op_set_ext_phy(con_handle, all_phys, tx_phy, rx_phy, phy_options)**
ble5.0 配置phy.

Parameters：

* **con_handle** – **[in]** 连接 con_handle,range：>0.
* **all_phys** – **[in]** 0.
* **tx_phy** – **[in]** CONN_SET_CODED_PHY.
* **rx_phy** – **[in]** CONN_SET_CODED_PHY.
* **phy_options** – **[in]** CONN_SET_PHY_OPTIONS.

Returns：
see ble_cmd_ret_e.

**ble_op_set_ext_scan_param(param, param_len)**
ble5.0 配置 主机scan 参数.

Parameters：

* **param** – **[in]** 参数内容.
* **param_len** – **[in]** 参数长度.

Returns：
see ble_cmd_ret_e.

**ble_op_ext_scan_enable(cmd, cmd_len)**
ble5.0 配置 主机scan 开关.

Parameters：

* **cmd** – **[in]** 命令信息.
* **cmd_len** – **[in]** 命令长度.

Returns：
see ble_cmd_ret_e.

**ble_op_ext_create_conn(conn_param, param_len)**
ble5.0 配置 主机创建连接监听.

Parameters：

* **conn_param** – **[in]** 连接参数信息.
* **param_len** – **[in]** 参数长度.

Returns：
see ble_cmd_ret_e.

**ble_op_latency_skip(con_handle, skip_interval)**
忽略进入latency 作用的次数

**Note**
!!!注意：让设备不进入latency模式，加快响应速度，但会耗电.

Parameters：

* **con_handle** – **[in]** range：>0.
* **skip_interval** – **[in]** 忽略的interval的次数.

Returns：
see ble_cmd_ret_e.

**ble_op_test_key_num(con_handle, key_num)**
测试盒识别按键测试.

Parameters：

* **con_handle** – **[in]** range：>0.
* **key_num** – **[in]** 按键.

Returns：
see ble_cmd_ret_e.

**ble_op_stack_exit(control)**
退出ble协议栈.

**Note**
若已调用btstack_exit退出,则无需调用此接口

Parameters：

* **control** – **[in]** : 0—退出stack(默认),1—退出stack + controller.

Returns：
see ble_cmd_ret_e.

**ble_op_regist_thread_call(thread_callback)**
挂载协议栈线程调用.

**Note**
用于同步线程处理，慎用

Parameters：

* **thread_callback** – **[in]** 回调函数.

Returns：
see ble_cmd_ret_e.

**ble_op_scan_enable(enable)**
开关BLE搜索扫描.

**Note**
filter_duplicate 默认为 1.

**Note**
!!!注意：开搜索前必现先配置好搜索的参数ble_op_set_scan_param.

Parameters：

* **enable** – **[in]** 0 or 1.

Returns：
see ble_cmd_ret_e.

**ble_op_scan_enable2(enable, filter_duplicate)**
开关BLE搜索扫描2.

**Note**
filter_duplicate 默认为 1.

**Note**
!!!注意：开搜索前必现先配置好搜索的参数ble_op_set_scan_param.

Parameters：

* **enable** – **[in]** 0 or 1.
* **filter_duplicate** – **[in]** 0 or 1.

Returns：
see ble_cmd_ret_e.

**ble_op_set_scan_filter_policy(type)**
配置scan filter policy,默认type为0.

**Note**
!!!注意：设置的时候必须在 设置扫描参数 ble_op_set_scan_param 前配置好.

Parameters：

* **type** – **[in]** Range: 0x00 to 0x03.

Returns：
see ble_cmd_ret_e.

**ble_op_set_scan_param(scan_type, scan_interval, scan_window)**
配置搜索参数.

Parameters：

* **scan_type** – **[in]** 搜索类型 Range: 0x00 to 0x01 (unit: 0.625ms).
* **scan_interval** – **[in]** 搜索周期 Range: 0x0004 to 0x4000 (unit: 0.625ms) >= scan_window.
* **scan_window** – **[in]** 搜索窗口 Range: 0x0004 to 0x4000 (unit: 0.625ms), <= scan_interval.

Returns：
see ble_cmd_ret_e.

**ble_op_set_create_filter_policy(type)**
配置creat filter policy,默认type: 0.

**Note**
!!!注意：设置的时候必须在 设置创建连接参数 ble_op_create_connection 前配置好.

Parameters：

* **type** – **[in]** Range: 0x00 to 0x03.

Returns：
see ble_cmd_ret_e.

**ble_op_create_connection(create_conn_param)**
BLE创建连接监听.

Parameters：

* **create_conn_param** – **[in]** 连接参数.

Returns：
see ble_cmd_ret_e.

**ble_op_create_connection_ext(create_conn_param_ext)**
BLE创建连接监听,扩展传入参数

Parameters：

* **create_conn_param_ext** – **[in]** 连接参数.

Returns：
see ble_cmd_ret_e.

**ble_op_create_connection_cancel()**
取消BLE连接监听.

Returns：
see ble_cmd_ret_e.

**ble_op_search_profile_all()**
ble 主机搜索所有服务.

Returns：
see ble_cmd_ret_e.

**ble_op_search_profile_uuid16(uuid16)**
ble 主机搜索指定UUID16服务.

Parameters：

* **uuid16** – **[in]** uuid.

Returns：
see ble_cmd_ret_e.

**ble_op_search_profile_uuid128(uuid128_pt)**
ble 主机搜索指定UUID128服务.

Parameters：

* **uuid128_pt** – **[in]** uuid.

Returns：
see ble_cmd_ret_e.

**ble_op_conn_param_update(con_handle, con_param)**
ble 主机更新连接参数.

Parameters：

* **con_handle** – **[in]** range：>0.
* **con_param** – **[in]** (全局变量地址)，连接参数.

Returns：
see ble_cmd_ret_e.

Enums

enum **ble_cmd_type_e**
ble命令请求类型

**Note**
用户不能自己在中间添加值

*Values:*

* **BLE_CMD_ADV_ENABLE**
* **BLE_CMD_ADV_PARAM**
* **BLE_CMD_ADV_DATA**
* **BLE_CMD_RSP_DATA**
* **BLE_CMD_DISCONNECT**
* **BLE_CMD_REGIEST_THREAD**
* **BLE_CMD_ATT_SEND_INIT**
* **BLE_CMD_ATT_MTU_SIZE**
* **BLE_CMD_ATT_VAILD_LEN**
* **BLE_CMD_ATT_SEND_DATA**
* **BLE_CMD_REQ_CONN_PARAM_UPDATE**
* **BLE_CMD_SCAN_ENABLE**
* **BLE_CMD_SCAN_PARAM**
* **BLE_CMD_STACK_EXIT**
* **BLE_CMD_CREATE_CONN**
* **BLE_CMD_CREATE_CONN_CANCEL**
* **BLE_CMD_ADV_PARAM_EXT**
* **BLE_CMD_SEND_TEST_KEY_NUM**
* **BLE_CMD_LATENCY_HOLD_CNT**
* **BLE_CMD_SET_DATA_LENGTH**
* **BLE_CMD_SET_HCI_CFG**
* **BLE_CMD_SCAN_ENABLE2**
* **BLE_CMD_ATT_SERVER_REQ_RESUME**
* **BLE_CMD_MULTI_ATT_SEND_INIT**
* **BLE_CMD_MULTI_ATT_SET_CONN_HANDLE**
* **BLE_CMD_MULTI_ATT_SEND_DATA**
* **BLE_CMD_MULTI_ATT_MTU_SIZE**
* **BLE_CMD_MULTI_ATT_VAILD_LEN**
* **BLE_CMD_SM_REQ_RESUME**
* **BLE_CMD_CREATE_CONN_EXT**
* **BLE_CMD_DISCONNECT_EXT**
* **BLE_CMD_ATT_CLEAR_SEND_DATA**
* **BLE_CMD_EXT_ADV_PARAM**
* **BLE_CMD_EXT_ADV_DATA**
* **BLE_CMD_EXT_RSP_DATA**
* **BLE_CMD_EXT_ADV_ENABLE**
* **BLE_CMD_SET_PHY**
* **BLE_CMD_EXT_SCAN_PARAM**
* **BLE_CMD_EXT_SCAN_ENABLE**
* **BLE_CMD_EXT_CREATE_CONN**
* **BLE_CMD_PERIODIC_ADV_PARAM**
* **BLE_CMD_PERIODIC_ADV_DATA**
* **BLE_CMD_PERIODIC_ADV_ENABLE**
* **BLE_CMD_PERIODIC_ADV_CREAT_SYNC**
* **BLE_CMD_PERIODIC_ADV_TERMINATE_SYNC**
* **BLE_CMD_PERIODIC_ADV_CREATE_SYNC_CANCEL**
* **BLE_CMD_SEARCH_PROFILE**
* **BLE_CMD_WRITE_CCC**
* **BLE_CMD_ONNN_PARAM_UPDATA**
  enum **ble_cmd_ret_e**
  ble命令请求返回值

**Note**
用户不能自己在中间添加值

*Values:*

* **BLE_CMD_RET_SUCESS** - 执行成功
* **BLE_CMD_RET_BUSY** - 命令处理忙
* **BLE_CMD_PARAM_OVERFLOW** - 传数溢出
* **BLE_CMD_OPT_FAIL** - 操作失败
* **BLE_BUFFER_FULL** - 缓存满了
* **BLE_BUFFER_ERROR** - 缓存出错
* **BLE_CMD_PARAM_ERROR** - 传参出错
* **BLE_CMD_STACK_NOT_RUN** - 协议栈没有运行
* **BLE_CMD_CCC_FAIL** - 没有使能通知，导致NOTIFY或INDICATE发送失败

enum **search_profile_type_e**
搜索profile的方式

**Note**
用户不能自己在中间添加值

*Values:*

* **PFL_SERVER_UUID16** - 指定16bit UUID搜索方式
* **PFL_SERVER_UUID128** - 指定128bit UUID搜索方式
* **PFL_SERVER_ALL** - 搜索所有的UUID

enum **hci_cfg_par_e**
设置过滤规则

**Note**
用户不能自己在中间添加值

*Values:*

* **HCI_CFG_OWN_ADDRESS_TYPE** - 设置mac地址过滤规则
* **HCI_CFG_ADV_FILTER_POLICY** - 设置广播包过滤规则
* **HCI_CFG_SCAN_FILTER_POLICY** - 设置扫描过滤规则
* **HCI_CFG_INITIATOR_FILTER_POLICY** - 设置连接发起的过滤规则

enum **remote_type_e**
对方主机的系统类型

**Note**
用户不能自己在中间添加值

*Values:*

* **REMOTE_TYPE_UNKNOWN** - 未查询or查询对方未响应
* **REMOTE_TYPE_ANDROID** - 安卓系统
* **REMOTE_TYPE_IOS** - ios系统

Functions

**ble_user_cmd_prepare(cmd, argc, ...)**
[ble_cmd_ret_e](ble_cmd_ret_e) [ble_cmd_type_e]() **cmd**, **int** **argc**, **...**
ble命令请求.

Parameters* **cmd** – **[in]** 命令类型.

* **argc** – **[in]** 命令个数.

Returnsble_cmd_ret_e

**gatt_client_init(void)**
Gatt client角色初始化.

**gatt_client_register_packet_handler(handler)**
注册gatt client角色,事件回调函数.

Parameters：

* **handler** – **[in]** 事件处理函数.

**le_device_db_init(void)**
初始化配对表.

Note
上电初始化一次.

void **reset_PK_cb_register**(**void** **(*reset_pk)**(**u32*****)**)
注册passkey输入回调.

Parameters

* **reset_pk** – **[in]** 复位按键输入.

int **le_controller_set_mac**(**void** *****addr**)
设置ble蓝牙的public地址.

Note

可以结合接口 ble_op_set_ownaddress_type 配置选择地址类型.

Note

修改地址必须在ble非工作状态下才能生效( 没有scan,没有adv,没有connected).

Parameters**addr** – **[in]** public地址.

Returns0->success ,非0->fail.

**le_controller_get_mac(addr)**
获取ble蓝牙的public地址.

Parameters：

* **addr** – **[out]** pulic地址.

Returns：
0->success ,非0->fail.

**le_controller_set_random_mac(addr)**
初始化ble蓝牙random地址.

**Note**
结合接口ble_op_set_own_address_type 配置选择地址类型.

**Note**
修改地址必须在ble非工作状态下才能生效(内有scan,没有adv,没connected).

Parameters：

* **addr** – **[in]** random地址.

Returns：
0->success ,非0->fail.

**le_controller_get_random_mac(addr)**
获取ble蓝牙的random地址.

Parameters：

* **conn_handle** – **[in]** range :>0。
* **enable** – **[in]** 1 or 0。

Returnstrue or false。

u16 **ble_vendor_set_default_att_mtu(mtu_size)**
配置协议栈ATT默认的MTU大小。

Parameters：

* **mtu_size** – **[in]** 配置MUT大小 ,range :23 ~517。

Returns配置后mtu_size的值。

void **user_client_set_search_complete()**
设置 client 搜索结束。

bool **ble_vendor_random_address_generate(address, type)**
提供生成ble对应的类型地址。

Parameters**con_handle** – **[in]** range :>0.

Returnsrssi 强度 ,range :-127 ~128 dbm.

**ble_vendor_interval_event_enable(conn_handle, enable)**
使能周期interval事件上报.

Parameters：

* **conn_handle** – **[in]** range :>0.
* **enable** – **[in]** 1 or 0.

Returns：
true or false.

**ble_vendor_random_address_generate(address, type)**
提供生成ble对应的类型地址.

**Note**
生成RESOLVABLE_PRIVATE_ADDR,需要等协议栈初始化IRK后才能生成.

Parameters：

* **address** – **[out]** 类型对应地址.
* **type** – **[in]** ble_type (eg:1.STATIC_DEVICE_ADDR. 2.NON_RESOLVABLE_PRIVATE_ADDR. 3.RESOLVABLE_PRIVATE_ADDR).

Returns：
true or false.

**lib_make_ble_address(ble_address, edr_address)**
根据提供的edr地址生成唯一对应的ble地址.

**Note**
用户可以自定义edr和ble地址关联规则,重写这个接口

Parameters：

* **ble_adress** – **[out]** BLE_address.
* **edr_adress** – **[in]** EDR_address.

**ble_list_config_reset(pair_devices_count, is_allow_cover)**
ble master&slave 配置配对表(可以不设置,使用sdk默认值).

**Note**
上电调用配置,若配置的个数跟之前不一样，默认清所有的配对表数据.

**Note**
VM 掉电记录保护.

**Note**
主从机共用一个配对表.

Parameters：

* **pair_devices_count** – **[in]** 记录配对设备,range: 0~10,默认10.若配置为0:则不使用配对表记录管理，不限制配对个数.
* **is_allow_cover** – **[in]** 是否允许循环覆盖记录 1 or 0,默认1.

Returns：
true or false.

**ble_list_pair_accept(enable)**
配置是否接受新设备请求配对,记录在VM,(可以不设置,使用sdk默认值).

**Note**
VM 掉电记录保护.

**Note**
是否覆盖是由接口 ble_list_config_reset 的参数 is_allow_cover 决定.

Parameters：

* **enable** – **[in]** 允许新设备配对开关,1 or 0,默认1.

Returns：
true or false.

**ble_list_get_count()**
获取配对表已有配对个数.

Returns：
0~10.

**ble_list_bonding_remote(conn_addr, conn_addr_type)**
绑定已配对的指定设备,清除其他配对设备.

**Note**
VM 掉电记录保护.

Parameters：

* **conn_addr** – **[in]** 对方地址6bytes.
* **conn_addr_type** – **[in]** 对方地址类型range: 0~1.

Returns：
true or false.

**ble_list_clear_all()**
ble 清空配对表.

Returns：
true or false.

**ble_list_check_addr_is_exist(conn_addr, conn_addr_type)**
ble 检测连接地址是否在已配对表中.

Parameters：

* **conn_addr** – **[in]** 对方地址6bytes.
* **conn_addr_type** – **[in]** 对方地址类型range: 0~1.

Returns：
true or false.

**ble_list_delete_device(conn_addr, conn_addr_type)**
ble 把设备从配对表中删除.

Parameters：

* **conn_addr** – **[in]** 对方地址6bytes.
* **conn_addr_type** – **[in]** 对方地址类型range: 0~1.

Returns：
true or false.

**ble_list_get_last_id_addr(id_addr)**
ble 获取配对表中最后连接设备的 id_address (public address).

Parameters：

* **id_addr** – **[out]** 输出最后连接设备的id地址.

Returns：
true or false.

**ble_list_get_id_addr(conn_addr, conn_addr_type, id_addr)**
ble 获取已配对设备连接地址对应的 id_address (public address or static address).

Parameters：

* **conn_addr** – **[in]** 对方连接地址6bytes.
* **conn_addr_type** – **[in]** 对方连接地址类型range: 0~1.
* **id_addr** – **[out]** 输出已配对设备的id地址.

Returns：
true or false.

**ble_list_get_remote_type(conn_addr, conn_addr_type, output_type)**
ble 获取已配对设备的系统类型.

**Note**
只支持作为从机获取手机类型.

Parameters：

* **conn_addr** – **[in]** 对方连接地址6bytes.
* **conn_addr_type** – **[in]** 对方连接地址类型range: 0~1.
* **output_type** – **[out]** 见 remote_type_e 定义.

Returns：
true or false.

**att_server_set_exchange_mtu(con_handle)**
ble slave: att server 连接后主动发起请求MTU交换流程.

Parameters：

* **handle** – **[in]** range：>0.

**att_server_flow_enable(enable)**
ble slave: att server 使能流控功能.

**Note**
蓝牙初始化后可调用.

Parameters：

* **handle** – **[in]** range：>0.
* **enable** – **[in]** 1 or 0.

**att_server_flow_hold(con_handle, hold_flag)**
ble slave: att server 控制收数流控.

**Note**
蓝牙初始化后可调用,对方client要使用write的方式发送数据才能有流控生效

Parameters：

* **handle** – **[in]** range：>0.
* **hold_flag** – **[in]** 1—停止收发数据，0—开始正常收发数.

**att_server_set_check_remote(con_handle, callback)**
ble slave: server 配对连接时，检查对方操作系统。

**Note**
在第一次配对连接时调用，HCI_EVENT_ENCRYPTION_CHANGE 事件后.

Parameters：

* **handle** – **[in]** range：>0.
* **callback** – **[in]** 检查完回调.

**att_send_check_multi_dev(server_max, client_max)**
检测协议栈att模块是否支持多机.

Parameters：

* **server_max** – **[in]** 传入判断的从机个数.
* **client_max** – **[in]** 传入判断的主机个数.

Returns：
0->success ,非0->fail.

**att_server_change_profile(profile_data)**
可修改GATT服务的profile.

**Note**
蓝牙未连接状态下,可调用修改.

Parameters：

* **profile_data** – **[in]** gatt profile.

Returns：
0->success ,非0->fail.

Variables

struct **create_conn_param_t** **_GNU_PACKED_**

struct **conn_update_param_t**
*#include <ble_api.h>*

更新连接参数

**Public Members**

* **interval_min** - 连接周期范围最小值(unit:1.25ms)
* **interval_max** - 连接周期范围最大值(unit:1.25ms)
* **latency** - 忽略通信次数(unit: interval)
* **timeout** - (unit:10ms)

struct **create_conn_param_t**
*#include <ble_api.h>*

连接创建时的连接参数

**Public Members**

* **conn_interval** - 连接周期(unit:1.25ms)
* **conn_latency** - 忽略通信次数(unit: interval)
* **supervision_timeout** - (通信超时 unit:10ms)
* **peer_address_type** - 对方地址类型：0—public address,1—random address
* **peer_address[6]** - 对方地址address

struct **create_conn_param_ext_t**
*#include <ble_api.h>*

扩展类型BLE 5.0连接创建时的连接参数

**Public Members**

* **le_scan_interval** - scan 周期(unit: 0.625ms)
* **le_scan_window** - scan 窗口(unit: 0.625ms)
* **initiator_filter_policy** - 过滤,set 0
* **peer_address_type** - 对方地址类型:0—public address,1—random address
* **peer_address[6]** - 对方地址
* **own_address_type** - 本地地址类型:0—public address,1—random address
* **conn_interval_min** - 连接周期最小值(unit:1.25ms)
* **conn_interval_max** - 连接周期最大值(unit:1.25ms)
* **conn_latency** - 忽略通信次数(unit: interval)
* **supervision_timeout** - 通信超时 unit:10ms
* **minimum_ce_length** - set 1
* **maximum_ce_length** - set 1

struct **adv_report_t**
#include <ble_api.h>
广播包信息

Public Members

* **event_type** - 对方广播包类型: 0—ADV_IND,1—ADV_DIRECT_IND,2—ADV_SCAN_IND,3—ADV_NONCONN_IND,4—SCAN_RSP
* **address_type** - 对方地址类型：0—public address,1—random address
* **address[6]** - peer_address
* **rssi** - range:-127 ~128 dbm
* **length** - 广播包长度
* **data[0]** - 广播包内容

struct  **sm_just_event_t**
#include <ble_api.h>
安全认证确认信息

Public Members

* **type** - See <btstack/hci_cmds.h> SM_…
* **size** - 信息长度
* **con_handle** - connection 's handle, >0
* **addr_type** - 对方地址类型:0—public address,1—random address
* **address[6]** - 对方地址
* **data[4]** - 扩展信息

---


# 4.8. BLE传输的影响因素及测速结果

**概述** 使用demo_ble进行设备收发数据测速

## 4.8.1. 操作说明

* 1. 在手机端安装BLE测速工具[JL_RSSI_Test-V1.2.0-tool-debug.apk]()
* 2. 在app_config.h文件中，使能以下宏

```
#define TCFG_USER_BLE_ENABLE                      1     //BLE功能使能
#define TRANS_DATA_EN                             1     //从机 传输数据
```

* 3. 在 le_trans_data.c 文件中，使能以下宏

```
#define TEST_SEND_DATA_RATE          1  //测试上行发送数据
#define TEST_TRANS_CHANNEL_DATA      1  /*测试记录接收数据速度*/
```

* 4. 编译工程，烧录镜像，复位启动
* 5. 如下图进行手机app端操作：（所需点击的按钮均在图中标注）

> * （1）在手机端运行 BLE 测速工具 APP，选择扫描界面中要连接的设备
> * （2）点击连接以后会跳转到参数设置界面，可以设置MTU大小（23-517），设置PHY，查看连接参数，修改主机端连接参数
> * （3）选择服务列表uuid：00ae30-0000-1000-8000-00805f9b34fb
> * （4）选择uuid：0XAE01，点击右侧盘装指针图案查看设备接收测速数据
> * （5）选择uuid：0XAE02，打开notify（点击三个向下箭头）之后value会自动更改为enable,点击最右测的盘状指针图案查看设备发送测速数据

[![](img\78.png)](https://doc.zh-jieli.com/AC79/zh-cn/master/module_example/bluetooth/ble_test_speed.html)

[![](img\79.png)](https://doc.zh-jieli.com/AC79/zh-cn/master/module_example/bluetooth/ble_test_speed.html)

[![](img\80.png)](https://doc.zh-jieli.com/AC79/zh-cn/master/module_example/bluetooth/ble_test_speed.html)

## 4.8.2. ble传输要素说明

* 1. BLE传输带宽主要跟两个要素有关： 通信周期和每个通信点可传输的数据量

> * （1）通信周期： 安卓手机一般可支持到10ms，苹果一般可支持到15ms
> * （2）每个通信点可传输的数据量： 就是指每包的长度以及可以传多少包

* 2. BLE理论带宽传输计算如下

> * （1）按15毫秒通信周期，每次基本通信能发4包（发包个数取决于主机）
> * （2）若PDU长为27， 即payload长是 20 byte，那传输速度是 (1000/15)204 约= 5K byte 速度
> * （3）若PDU长为251，即payload长是 244 byte，那传输速度是 (1000/15)2444 约= 63K byte 速度（要双方同时支持DLE和2M属性）

## 4.8.3. ble传输速率影响的参数及功能

* 1. 改大本地ATT协议MTU的大小和应用层cbuf的大小
* 注意：实际使用的ATT_MTU大小，一般由主机进行与从机协商交换，取两者较小作为传输ATT_MTU大小，协商交换后可看打印”ATT MTU = xxx”
* 传输速率与设备端设置的ATT_MTU大小与下列第四点中使用DLE配置中config_btctler_le_acl_packet_length长度配置也有关系，并不是ATT_MTU越大速率越快，测速时设备端设置最大517是因为测速软件在主机端可进行MTU修改设置
* 传输速率与设备设置的ATT_MTU大小与下列第三点设置能收发到的最大包数有关，每包的ATT_MTU越大，每次通信能收发的实际包数可能越少

```
//ATT的包长,    note: 20 <=need >= MTU
#define ATT_LOCAL_MTU_SIZE    (517)
/*本地MTU的长度，范围range:23~517,会通过接口ble_vendor_set_default_att_mtu配置*/
//ATT缓存的buffer大小,  note: need >= 20,可修改
#define ATT_SEND_CBUF_SIZE  (ATT_LOCAL_MTU_SIZE*5)
/*cbuf是contoller发包的二级缓存*/

/*一般情况是client端主动发起MTU交换；但如果client没发起，server角色也可以使用接口发起MTU交换(ble_api.h)*/
void att_server_set_exchange_mtu(u16 con_handle);
```

* 2.调整连接参数。改小蓝牙的通信周期interval的值，最小周期是7.5 ms。从机只请求，通信周期由主机决定。客户可以根据实际需求来修改连接参数、interval越小、功耗越高、BLE通信速度越快；latency越小、功耗越高、BLE通信速度越快。BLE连接参数是主机和从机通过协商的方式确定的。trans_connection_param_table数组中每一行代表一组连接参数分别代表interval_min、interval_max、latency、timeout。连接以后主机会拿从机中第一组连接参数，如果主机不支持改参数会自动拿第二组、如果三组都不支持则连接参数由手机确定。
* 注意：传输速率有关连接周期与每次通信最多收发数据包个数有关。
* 发送时当连接周期过短，每次通信发送数据包未达到设置最大发送包数，增加连接周期，可发包数越多，速率越快，当连接周期过大，已达到最大发送包数，传输速率开始下降。
* 接收时当达到最大接收包数时，连接周期越短，单位时间内通信次数越多，速率越快。

> * （1）主从对传最小到6 slots(7.5ms)
> * （2）安卓最小到9 slots（11.25ms），不排除有些手机不支持9 slots
> * （3）苹果最小到12 slots（15ms）

```
struct conn_update_param_t {
    u16 interval_min;  //连接周期范围最小值(unit:1.25ms)
    u16 interval_max;  //连接周期范围最大值(unit:1.25ms)
    u16 latency;       //忽略通信次数(unit: interval)
    u16 timeout;       //(unit:10ms)
};

static const struct conn_update_param_t trans_connection_param_table[] = {
    {6, 9, 0, 400},  /*Android请求的连接参数*/
    {6, 12, 0, 400}, /*ios请求的连接参数*/
    {16, 24, 0, 400},/*ios请求的连接参数*/
};

/*客户可以根据实际需求来修改连接参数、interval越小、功耗越高、BLE通信速度越快；latency越小、功耗越高、BLE通信速度越快。*/
/*功耗优先*/
static const struct conn_update_param_t trans_connection_param_table[] = {
    {60, 80, 19, 2000},
    {40, 60, 19, 2000},
    {20, 40, 19, 1500},
}；

/*兼容性优先*/
static const struct conn_update_param_t trans_connection_param_table[] = {
    {16, 24, 10, 600},
    {12, 28, 10, 600},
    {8,  20, 10, 600},
};

/*性能优先*/
static const struct conn_update_param_t trans_connection_param_table[] = {
    {6,  10, 0, 100},
    {10, 14, 0, 100},
    {14, 20, 0, 100},
};
```

* 3. 修改每次通信最多收发数据包的个数，contoller的一级缓存。（建议<=10，能收发多少包最终由主机决定），当连接周期变长时，可发的包数越多，传输速率越大，当连接周期过长，收发包已达到设置最大数，传输速率会下降

```
const int config_btctler_le_rx_nums =10; /*空中1次通信可接收最多的数据包个数*/
const int config_btctler_le_acl_total_nums =10; /*空中1次通信可发送最多的数据包个数*/
```

* 4. 开启 Data Length Extension supported (LE_DATA_PACKET_LENGTH_EXTENSION)，简称DLE ，ACL层的每个数据包PDU的长度可配置范围 27~251 bytes（主机要支持蓝牙v4.2或以上版本）

```
/*蓝牙版本features*/
const uint64_t config_btctler_le_feature =  LE_ENCRYPTION|LE_DATA_PACKET_LENGTH_EXTENSION;
const int config_btctler_le_acl_packet_length = 251;/*数据包payload长度，range:27~251*/

/*主从机都可以发起DLE请求交换，一般是主机发起，可调用接口*/
int ble_comm_set_connection_data_length(u16 conn_handle, u16 tx_octets, u16 tx_time)
ble_comm_set_connection_data_length（conn_handle,config_btctler_le_acl_packet_length ,2120）；
```

* 注意：如果从设备支持DLE特性，一般手机可用的ATT MTU大小也会跟着变大。另外ATT_LOCAL_MTU_SIZE 和 config_btctler_le_acl_packet_length的配置关系，ATT层 MTU_SIZE 对应配置ATT_LOCAL_MTU_SIZE空中包PDU长度 对应配置 config_btctler_le_acl_packet_length
* （1）ATT_LOCAL_MTU_SIZE 是配置ATT协议的最大包长，配置范围 23~517，实在应用最大的有效数据长度 PAYLOAD_SIZE = ATT_LOCAL_MTU_SIZE -3。
* （2）config_btctler_le_acl_packet_length 是配置空中包的PDU长度，配置范围 27~251。
* （3）ATT_LOCAL_MTU_SIZE 配置不受 config_btctler_le_acl_packet_length 配置影响。如果 ATT_LOCAL_MTU_SIZE > （config_btctler_le_acl_packet_length-4）;ATT层传输过程就会根据 （config_btctler_le_acl_packet_length-4）的值来对ATT的包做拆包和组包的动作。
* （4）改大 config_btctler_le_acl_packet_length 会提升空中传输包长，减少拆包和组包的耗时。理想状态是ATT_LOCAL_MTU_SIZE 是 （config_btctler_le_acl_packet_length-4） 的倍数关系，这样在发送最大payload数据的时候，效率就会最高，耗时较少。
* 5. 开启2M包的支持，提升物理传输速率，配置feature属性LE_2M_PHY（主机要支持蓝牙v5.0或以上版本）

```
/*蓝牙版本features*/
const uint64_t config_btctler_le_features = LE_ENCRYPTION|LE_2M_PHY ;

/*主从机都可以发起2M包请求交换，一般是主机发起，可调用接口*/
int ble_comm_set_connection_data_phy(u16 conn_handle, u8 tx_phy, u8 rx_phy, u16 phy_options);
ble_comm_set_connection_data_phy(conn_handle,CONN_SET_2M_PHY,CONN_SET_2M_PHY,CONN_SET_PHY_OPTIONS_NONE);
```

* 6. 可同时使用修改点4使用DLE和修改点5开启2M包支持，在config_btctler_le_features或上相应参数开启，DLE和2M包一般主机蓝牙版本支持都会进行主动发起

## 4.8.4. 设备ble发送测速结果

* 1. 依照上一部分”ble传输速率影响的参数及功能”所给出的设置对SDK进行修改

```
/*1.设置ATT_SIZE*/
#define ATT_LOCAL_MTU_SIZE    (517)
#define ATT_SEND_CBUF_SIZE  (ATT_LOCAL_MTU_SIZE*5)

/*2.设置连接参数*/
static const struct conn_update_param_t trans_connection_param_table[] = {
    {6, 10, 0, 100},
    {10, 14, 0, 100}，
    {14, 20, 0, 100}，
    //{16, 24, 10, 600}，
    //{60, 80, 19, 2000}，
};

/*3.设置每次通信最多收发数据包个数*/
const int config_btctler_le_rx_nums =10; /*空中1次通信可接收最多的数据包个数*/
const int config_btctler_le_acl_total_nums =10; /*空中1次通信可发送最多的数据包个数*/

/*4&5.开启DLE和2M包支持*/
const uint64_t config_btctler_le_feature =  LE_ENCRYPTION | LE_DATA_PACKET_LENGTH_EXTENSION | LE_2M_PHY;
const int config_btctler_le_acl_packet_length = 251;/*数据包payload长度，range:27~251*/
```

* 2. 主机（手机端）操作修改

> * （1）设置MTU_SIZE
> * （2）PHY设置成支持1M包或2M包测试（主机即手机要支持蓝牙v5.0）

* 3. 测速结果

> * （1）以调整连接周期时间支持1M包进行测速结果：

![](img\81.png)

> * （2）以调整连接周期时间支持2M包进行测速结果：

![](img\82.png)

> * 说明：当连接周期变长，在达到可发送最大包数之前，可发送的包数越多，速率越快

> * （3）以调整ATT_MTU支持1M包进行测速结果：

![](img\83.png)

> * （4）以调整ATT_MTU支持2M包进行测速结果：

![](img\84.png)

> * （5）以上数据仅供参考，可根据需要对于影响因素”ble传输速率影响的参数及功能”中五个点进行调整测试所需速度，使用测速软件的手机不同、距离信号强度和干扰信号等也会带来测速差异

## 4.8.5. 设备ble接收测速结果

* 1. 依照上一部分”ble传输速率影响的参数及功能”所给出的设置对SDK进行修改

```
/*1.设置ATT_SIZE*/
#define ATT_LOCAL_MTU_SIZE    (517)
#define ATT_SEND_CBUF_SIZE  (ATT_LOCAL_MTU_SIZE*5)

/*2.设置连接参数*/
static const struct conn_update_param_t trans_connection_param_table[] = {
    {6, 10, 0, 100},
    {10, 14, 0, 100}，
    {14, 20, 0, 100}，
    //{16, 24, 10, 600}，
    //{60, 80, 19, 2000}，
};

/*3.设置每次通信最多收发数据包个数*/
const int config_btctler_le_rx_nums =10; /*空中1次通信可接收最多的数据包个数*/
const int config_btctler_le_acl_total_nums =10; /*空中1次通信可发送最多的数据包个数*/

/*4&5.开启DLE和2M包支持*/
const uint64_t config_btctler_le_feature =  LE_ENCRYPTION | LE_DATA_PACKET_LENGTH_EXTENSION | LE_2M_PHY;
const int config_btctler_le_acl_packet_length = 251;/*数据包payload长度，range:27~251*/
```

* 2. 主机（手机端）操作修改

> * （1）设置MTU_SIZE
> * （2）PHY设置成支持1M包或2M包测试（主机即手机要支持蓝牙v5.0）
> * （3）设置连接参数（连接参数主机决定可修改）

* 3. 测速结果

> * （1）以调整连接周期时间支持1M包进行测速结果：

![](img\85.png)

> * （2）以调整连接周期时间支持2M包进行测速结果：

![](img\86.png)

> * 说明：当连接周期变长，查看蓝牙包，手机发的包数固定没变(与手机性质有关)，连接周期越长，速率越慢

> * （3）以调整ATT_MTU支持1M包进行测速结果：

![](img\87.png)

> * （4）以调整ATT_MTU支持2M包进行测速结果：

![](img\88.png)

> * （5）以上数据仅供参考，可根据需要对于影响因素”ble传输速率影响的参数及功能”中五个点进行调整测试所需速度，使用测速软件的手机不同、距离信号强度和干扰信号等也会带来测速差异

* 说明：以上设备发送和接收测速，另一端均为华为P40 pro

## 4.8.6. 参考

> 更多详细说明请点击参考 [提升ble传输速率方法]()




# 4.9. BLE透传

**概述**

使用demo_ble工程的BLE透传功能的使用说明

## 4.9.1. 操作说明

* 1. 在app_config.h文件中使能以下宏

> * #define TCFG_USER_BLE_ENABLE 1 //BLE功能使能
> * #define TRANS_DATA_EN 1 //从机 传输数据

* 2. 配置GATT服务和属性

> * （1）修改profile_data数据表，通过工具[make_gatt_services]()进行自定义修改，将新的profile_data数据表和对应的handle编号存放在le_trans_data.h。详细操作请参考[make_gatt_services工具说明]()。
> * （2）带有READ属性的handle放到 att_read_callback 函数中

```
static uint16_t att_read_callback(hci_con_handle_t connection_handle, uint16_t att_handle, uint16_t offset, uint8_t *buffer, uint16_t buffer_size)
{
    //......省略
    switch (handle) {
        //带有READ权限的handle
        case ATT_CHARACTERISTIC_2a00_01_VALUE_HANDLE:
            //以下为对应属性的操作处理
            att_value_len = gap_device_name_len;
            if ((offset >= att_value_len) || (offset + buffer_size) > att_value_len) {
                break;
            }
            if (buffer) {
                memcpy(buffer, &gap_device_name[offset], buffer_size);
                att_value_len = buffer_size;
                log_info("\n------read gap_name: %s \n", gap_device_name);
            }
            break;
    //......省略
    }
}
```

> * （3）将带有WRITE属性的handle放到 att_write_callback 函数中

```
static int att_write_callback(hci_con_handle_t connection_handle, uint16_t att_handle, uint16_t transaction_mode, uint16_t offset, uint8_t *buffer, uint16_t buffer_size)
{
    //......省略
    switch (handle) {
        //带有WRITE权限的handle
        case ATT_CHARACTERISTIC_ae03_01_VALUE_HANDLE:
                //以下为对应属性的操作处理
                printf("\n-ae03_rx(%d):", buffer_size);
                //收发测试，自动发送收到的数据;for test
                if (app_send_user_data_check(buffer_size)) {
                    app_send_user_data(ATT_CHARACTERISTIC_ae05_01_VALUE_HANDLE, buffer, buffer_size, ATT_OP_AUTO_READ_CCC);
                }
                break;
    //......省略
}
```

> * （4）将带有NOTIFY或者INDICATION属性的 handle 通过传参到发送数据的函数中。对于带有NOTIFY或者INDICATION属性的characteristic，主机端需要使能CCCD才能接收notify和indicate命令。

```
app_send_user_data(ATT_CHARACTERISTIC_ae05_01_VALUE_HANDLE, buffer, buffer_size, ATT_OP_AUTO_READ_CCC);
```

* 3. 编译工程，烧录镜像，复位启动
* 4. 在手机或其他终端打开BLE助手；连接成功后，在通过BLE助手进行收发测试

> * （1）蓝牙连接成功后，点击“蓝牙服务”查看当前蓝牙设备的service列表，如图1所示；
> * （2）点击第二项service，点击UUID为ae03的characteristic对应的箭头，表示发送该characteristic对应的数据，如图2所示；
> * （3）点击UUID为ae05的characteristic对应的按钮，表示使能该characteristic的CCD，即接收其indicate命令，如图2所示；
> * （4）点击“实时日志”，在发送栏编辑数据后点击“发送”，通过日志可看到BLE助手发送数据成功，并且成功接收到从机发送的数据，如图3所示。
>
>> * 图1
>>

[![](img\89.png)](https://doc.zh-jieli.com/AC79/zh-cn/master/_images/BLE_Utility_1.jpg)

> * 图2

[![](img\90.png)](https://doc.zh-jieli.com/AC79/zh-cn/master/_images/BLE_Utility_2.jpg)

> * 图3

[![](img\91.png)](https://doc.zh-jieli.com/AC79/zh-cn/master/_images/BLE_Utility_3.jpg)




# 4.10. BLE配网

**概述**

使用wifi_story_machine工程通过BLE对WiFi进行网络配置的方法

## 4.10.1. 操作说明

* 1. 在app_config.h文件中，使能以下宏，确保 `CONFIG_NET_ENABLE `宏有定义

```
#define BT_NET_CFG_EN                             1     //从机 杰理配网专用
```

* 2. 在le_net_cfg.c文件中，可更改BLE设备名称，注意名称前缀 `<span class="pre">JL</span>` 不可更改，否则小程序搜索不出设备

```
staticchargap_device_name[BT_NAME_LEN_MAX]="JL-AC79XX-BLE";
```

* 3. 长按按键KEY_MODE，进入配网模式，详情参考 `WIFI_STORY_MACHINE工程说明` 的 `wifi_story_machine工程操作说明 `的 `按键操作说明`
* 4. 打开手机的蓝牙开关，通过微信扫描二维码进入杰理小程序，二维码如图所示

![](img\92.png)

* 5. 进入小程序后，在界面中填写新的WiFi名称、WiFi密码。点击“搜索蓝牙设备”，等待蓝牙设备连接成功，如图所示

![](img\93.png)

* 6. 点击“蓝牙设备配网”，设备即可获取到WiFi名称、WiFi密码数据

![](img\94.png)



# 4.11. BLE开发常见问题

**概述**

汇总用户在BLE的应用开发过程中遇到的常见问题

## 4.11.1. 问题汇总

* 1.手机连接带绑定配对功能的BLE从机设备时会弹两次配对框

> * 可能是手机主动发起了加密配对后，设备端又发起安全加密请求命令，出现重复的行为
> * 设备端有重复配置加密的行为，配置了请求安全加密命令，又在profile加密安全加密认证，详见问题2的说明

```
//方式1：配从机默认发请求加密命令
void sm_set_request_security(int enable);
//方式2：指定链接发加密请求命令
bool sm_api_request_pairing(hci_con_handle_t con_handle);
```

* 2. [BLE配对加密功能的配置使用]()
* 3. [蓝牙双模获取对方的RSSI信号强度说明]()
* 4. 关于att操作读时att_read_callback回调会出现两次的解答

> * att_read_callback会出现两次回调，第一次buffer=0，第二次buffer为非0，这是一个正常的流程控制方式，支持read、read_blob等操作
> * 两次回调都需要返回长度，第一次返回characteristic内容的总长度，第二次返回真正写入buffer数据的长度
> * 第一次回调获取characteristic的内容长度，用来决定第二次回调的操作方式，例如申请buffer大小和offset的偏移等

* 5. [提升BLE传输速率方法]()
* 6. [BLE中ATT层MTU_SIZE和空中包PDU长度两者的配置关系]()
* 7. [降低BLE功耗方法]()
* 8. BLE从机设备拒绝配对方法

> * 不调用接口sm_just_works_confirm确认即可，然后发送断开命令

* 9. 中途更改BLE广播数据的方法

```
ble_op_adv_enable(0);
ble_op_set_adv_data(offset, buf);
ble_op_adv_enable(1);ble_op_adv_enable(0);
ble_op_set_adv_data(offset,buf);
ble_op_adv_enable(1);
```

* 10. BLE接收数据被分包问题

> * 首先默认传输时支持20byte的长度，按打印信息，确认对方是不是做了分包的行为
> * 先确定有没有做MTU交换的行为
> * 如果有交换还是20bytes payload长度，那就是对方不支持大于20byte的传输，需要对方修改支持

* 11. 蓝牙通话时，数传BLE的传输速率下降

> * 手机是会有带宽仲裁策略，通话是同步传输，固定要占用带宽，而手机是优先通话，剩下的带宽才给BLE通信，所以这时候建议不要做大数据量的传输操作，可以尝试调整一下BLE的发包的包长和interval，看看有没有提升

* 12. [BLE从机修改连接参数意义（提升BLE发包速度、降低连接后的功耗）]()
* 13. 动态修改BLE的mac地址

```
ble_module_enable(0);

u8 addr[6];
le_controller_get_mac(addr); //获取当前的地址
put_buf(addr, 6);
addr[0]++; //例子：自增加1
//需要下次开机生效，需要新定义一个VM ID来记忆
//系统现有的CFG_BT_MAC_ADDR字段，不能用，只能写一次，无法修改，需要重新定义一个ID
/* int ret = syscfg_write(CFG_USER_DEFINE_MAC, addr, 6); */
/* printf("syscfg_write(CFG_USER_DEFINE_MAC):%d", ret); */
le_controller_set_mac((void *)addr); //重设给底层
ble_module_enable(1);
```

* 14. [BLE广播包查看方式及填充其他字段]()
