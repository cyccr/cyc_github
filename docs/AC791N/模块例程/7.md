## 7. 系统部分

# 7.1. AI SDK

**Overview**

AI_SDK常用于接入第三方服务器播歌,读绘本等抽象出来统一网络云平台服务功能的接口;外部直接调用功能接口有可能存在互斥的问题,引入AI_SDK是为了解决这个问题,应用程序无需关心使用互斥问题, ai_server任务统一了事件的操作,用户操作对应AI_SDK消息时候只需要将对应的AI_SDK名字传入即可;

## 7.1.1. DEMO

使用工程：示例代码见 `apps/common/example/system/ai_sdk/main.c` ，测试时需要在 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_AI_SDK_DEMO` 。

## 7.1.2. AI Server

AI Server用于对注册的AI Sdk进行统一的调度管理，无需关心互斥问题。示例中各个接口含义：

* SERVER_REGISTER：创建ai_test_server
* ai_test_server_open：查询AI_SDK是否存在,是则存储到结构体中,并且返回结构体
* ai_test_server_init：初始化变量
* ai_test_server_close：在ai_test_server服务关闭时调用，AI_SDK的disconnect函数并且初始化变量
* ai_server_request: 分发处理各类型的消息
* ai_test_req_connect: 处理ai_server连接请求
* ai_test_req_disconnect:处理ai_server断开连接请求
* ai_test_req_listen: 处理ai_server监听请求
* ai_test_req_event:处理ai_server事件请求
* ai_test_server_event_notify: 用于下发notify事件给AI_SDK
* ai_test_server_event_url: 用于下发url事件给AI_SDK
* ai_test_check_connect_state: 用于下发连接或断开事件给AI_SDK

## 7.1.3. AI Sdk

AI Sdk为统一的网络云平台功能接口主要提供开启、断开、状态检测和事件处理的接口。示例中各个接口含义：

结构体

> ```
> struct ai_test_sdk_api {
>     const char *name;
>     int (*connect)(void);
>     int (*state_check)(void);
>     int (*do_event)(int event, int arg);
>     int (*disconnect)(void);
> };
> ```

* ai1_sdk_open : 对应的ai_sdk的connect函数
* ai1_sdk_check: 对应的ai_sdk的state_check函数
* ai1_sdk_do_event : 对应的ai_sdk的do_event函数
* ai1_sdk_disconnect: 对应的ai_sdk的disconnect函数
* REGISTER_AI_SDK :创建AI_SDK

# 7.2. APP_STATE_MACHINE

**Overview**

提供展示了app_state_machine接口应用示例和常见问题。

## 7.2.1. 应用示例

**示例演示：**

* app_state_machine的创建
* app_state_machine的使用与切换,具体流程如图：

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_APP_STATE_MACHINE_TEST_DEMO` 。

## 7.2.2. 常见问题

* 为什么要使用app_state_machine?
  答:
  > * 1.使用app_state_machine可以使得所有执行的action都在 “app_core”任务执行,所有动作和事件都是单线程运转,不需要考虑互斥问题;
  > * 2.当客户应用方案,存在多个模式,并且多个模式之间是互斥关系(非后台)的情况下, 建立多个app_state_machine切换可以使得系统资源合理利用和降低CPU的消耗;
  > * 3.系统所有事件产生都会发送到当前app_state_machine的event_handler;
  >

## 7.2.3. API Reference

# 7.3. CPU性能测试

**Overview**

本示例展示了CPU性能指标的测试

## 7.3.1. DEMO

使用工程：示例代码见 `apps/common/example/third_party/BenchMark/main.c` ，测试时需要在 `apps/demo/demo_hello` 添加相应代码。

## 7.3.2. 示例说明

* 在嵌入式处理器领域最为知名和常见测试CPU性能的就是：Dhrystone 和 CoreMark。
* CoreMark是由EEMBC(Embedded Microprocessor Benchmark Consortium)的Shay Gla-On于2009年提出的一项基准测试程序，CoreMark的主要目标是简化操作，并提供一套测试单核处理器核心的方法。测试标准是在配置参数的组合下单位时间内运行的CoreMark程序次数（单位：CoreMark/MHz），该数字值越大则说明测试的性能越好。 Dhrystone的重要性在于其能作为处理器整数计算性能的指标, 与Coremark不同的是，Dhrystone的主要部分实际上暴露了编译器优化工作负载的能力，而不是实际MCU或CPU的能力的性能;
* DMIPS： Dhrystone MIPS，并非字面上每秒百万条指令的意思。它是一个测量CPU运行一个叫Dhrystone(整数运算)的测试程序时表现出来的相对性能高低的一个单位(很多场合人们也习惯用MIPS作为这个性能指标的单位);
* Dhrystone： 是于1984年由Reinhold P. Weicker设计的一套综合的基准程序，该程序用来测试CPU(整数)计算性能。其名“Dhrystone”是与另一算法“Whetsone”区分而设计的名字。与Whetsone不同，Dhrystone并不包括浮点运算，其输出结果为每秒钟运行Dhrystone的次数，即每秒钟迭代主循环的次数;
* 
* Linpack测试系统浮点性能;
* pi_css5_src 测试CPU的浮点运算能力,测试CPU计算特定位数圆周率所需的时间;
* whetstone测试浮点运算效率和速度;
* 
* 
* STM32F4和ESP32芯片在 eembc官网 分数对比

## 7.3.3. 示例流程

* `c_main()` 入口1. 创建 `BenchMark_test_task` 任务
* `BenchMark_test_task` 函数流程1. 测试 `coremark`

  1. 测试 `dhrystone`
  2. 测试 `Linpack`
  3. 测试 `whetstone`
  4. 测试 `pi_css5_src`

  跑SFC无SDRAM, CPU时钟320M, SDRAM时钟192M,SFC时钟80M, flash 2线模式的coremark双核测试结果

  跑SFC有SDRAM, CPU时钟320M, SDRAM时钟192M,SFC时钟80M, flash 2线模式的coremark双核测试结果

  跑SDRAM, CPU时钟320M, SDRAM时钟192M, SFC时钟80M, flash 2线模式的coremark双核测试结果

  [超频测试,不可取] 跑SDRAM, CPU时钟396M, SDRAM时钟240M, SFC时钟99M, flash 2线模式的coremark双核测试结果

## 7.3.4. 常见问题

* AC791N CoreMark/MHz 基本在2.41的水平;
* 通常影响CPU性能测试结果的因素有:
  * 代码运行在内部ram,sdram,flash会依次降低cpu性能;
  * flash时钟,双/四线,sdram时钟,系统时钟影响cpu性能；
  * 由于硬件只支持单精度浮点指令, 因此双精度浮点影响cpu性能

# 7.4. CRYPTO

**Overview**

提供展示了展示了硬件加密接口应用示例和常见问题。

## 7.4.1. 应用示例

**示例演示：**

* AES128编解码使用
* SHA1编码
* SHA256编码
* example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_CRYPTO_TEST_DEMO` 。
* apps/common/example/system/crypto/main.c
* WL82 MBEDTLS中的SHA1/SHA256和AES均默认使用硬件计算
* WL82 LSB 53M时钟的硬件 SHA128性能:12.5MB/s; SHA256性能:12.9MB/s
* WL82 CPU主频320M跑软件 SHA128性能:10.5MB/s; SHA256性能:4.5MB/s

## 7.4.2. 常见问题

* AES能256bit吗
  答:能，jl_aes_encrypt_hw 的key和key长度改成32
* 可以使用HMAC 或 MD5之类的吗？
  答:可以使用mbedtls，在工程中添加mbedtls.a即可

## 7.4.3. API Reference

# 7.5. EVENT

**Overview**

提供系统事件接口应用示例和常见问题。

## 7.5.1. 应用示例

**示例演示：**

* 系统事件event如何发送;
* 系统事件event响应流程;

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_EVENT_TEST_DEMO` 。

## 7.5.2. 常见问题

* 系统事件有哪些
  答:utils/event/目录下包含了所有事件头文件, 分别有蓝牙,WIFI,按键,设备的事件
* 用户如何最简单的处理事件
  答:在对应app的event_handler处理事件

## 7.5.3. API Reference

# 7.6. 异常定位与分析

**Overview**

本示例模拟了多种情况下程序异常的情况,以及异常分析与定位的方法， 更多详细软件调试相关方法（请点击跳转） 。

## 7.6.1. DEMO

使用工程：示例代码见 `apps/common/example/system/exception/main.c` ，测试时需要在 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_EXCEPTION_TEST_DEMO` 。

## 7.6.2. 操作流程

* 根据示例中的注释链入对应的代码进行编译测试。
* 查看串口打印中的exception error，对比不同情况下的死机打印信息，如：
* 如果异常为axi_rd_inv或者axi_wr_inv,可以通过id号来确定最后一个运行地址在那个cpu中，这样可以更准确地确定异常地址，如：
* 通过 `cpu/wl82/tools/定位异常地址.bat` 输入reti或者rets地址（注意：输入的地址必须要要有0x开头 ）定位到对应地址的函数。

## 7.6.3. 常见问题

**(1) 通常程序异常情况有哪些?**

答：非对齐访问,指令非法,读写访问非法地址,除0异常,栈溢出,程序卡死看门狗复位

**(2) 有时候定位到对应地址的函数不准确怎么办?**

* 1. 需要用户根据代码目前正在运行的功能流程推测死机范围
* 2. 有时候内存被篡改,并不是马上出发异常,而且当被篡改的内存访问的时候才触发
* 3. 寻求FAE援助

**(3) 有时候发现内存被篡改,但是没有造成异常,应该如何查找?**

答：使用硬件保护软件不能够改写的地址范围, 如果软件改写就触发异常

**(4) 栈溢出 stackoverflow 怎么办?**

答：增大异常打印中current_task指出的任务

**(4) 如果出现死机不复位的情况怎么办?**

答：调用wdt_reset_enable,让看门狗溢出不经过异常函数直接复位, 并且需要打开宏EXPCPTION_IN_SRAM,防止flash挂了,进入异常函数失败复位不了

# 7.7. INIT_CALL

**Overview** 提供init_call接口应用示例、常用相关 API 介绍和常见问题。

## 7.7.1. 应用示例

**示例演示：**

* 各种init_call在系统内部调用顺序

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，中开启宏 `USE_INIT_CALL_TEST_DEMO` 。

**Note**

init_call都是初始化,只不过有顺序之分,它们的顺序排列如下图：

## 7.7.2. 常见问题

* init_call注册的函数什么时候运行,在哪里运行
  答:在app_core任务 app_task_handler 入口顺序执行
* 什么情况下使用init_call
  答:如果想隐式调用一个功能模块的初始化,可以使用init_call.类似于C++的构造函数
* init_call 顺序问题
  答: 因为同一类型init_call是无法区分顺序, 增加多种init_call是为了某些init_call需要依赖某些模块先初始化
* init_call仅仅为初始化，禁止在initcall函数程序代码中进行while死循环和长时间延时

## 7.7.3. API Reference

**Defines**

void **__initcall**(void *fn)
void **early_initcall**(void *fn)
void **late_initcall**(void *fn)
void **platform_initcall**(void *fn)
void **module_initcall**(void *fn)
void **__do_initcall**(const char *prefix)

**Typedefs**

typedef int **initcall_t**(void)

# 7.8. OS API

**Overview**

SDK中提供了两种操作系统API，一种是基于FreeRTOS原接口进行再次封装的API（这里简称为OS API）， 在SDK有更好的兼容性，所以SDK中大量采用了这类API；另一种为POSIX Threads（这里简称为pthread api）,（具体请参考 PTHREAD API ）；

## 7.8.1. DEMO

使用工程： 示例代码见 `apps/common/example/system/os/os_api/main.c`，测试时需要在 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_OS_API_TEST` 。

**示例说明**

展示了OS API基本使用方法，包括任务创建（动态任务创建和静态任务创建）、信号量、互斥量的使用和消息队列的使用等，主要示例包括：

* mutex_test()； 互斥量使用示例
* queue_test(); 消息队列使用示例
* sem_test(); 信号量使用示例
* static_task_test(); 静态任务创建示例
* thread_can_not_kill_test(); 模拟线程无法杀死示例

---

## 7.8.2. 线程(Task)

**任务创建**

| **项目**   | **内容**                                                                                                                                                       |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **函数**   | int thread_fork(const char* thread_name, int prio, int stk_size, u32 q_size, int* pid, void (*func)(void*), void* parm);                                           |
| **描述**   | 创建线程                                                                                                                                                             |
| **参数**   | thread_name：标识此线程的字符串 prio：优先级 stk_size：堆栈空间的大小 q_size: 消息队列空间的大小 pid: 线程号 func： 线程入口函数地址 parm： 传递给线程入口函数的参数 |
| **返回值** | 0：成功 其他：失败                                                                                                                                                   |

**例子**

> ```
> #include "os_api.h"
> #define TASK_STK_SIZE 256
> #define TASK_Q_SIZE 0
> #define TASK_PRIO 12
>
> static int task_pid;
>
> static void task_entry(void *p)
> {
>   //获取当前线程
>   printf("task_entry (%s) task\n", os_current_task());
>
>   while(1)
>   {
>     printf("running...\n");
>     os_time_dly(50);
>   }
> }
>
> void task_test(void)
> {
>   thread_fork("task_entry", TASK_PRIO, TASK_STK_SIZE, TASK_Q_SIZE, &task_pid, task_entry, NULL);
> }
> ```

**任务列表使用**

务列表的作用可以对任务进行统一管理，方便对任务的优先级（优先级范围为0~31，数值越大优先级越高）、任务堆栈大小和消息队列大小进行调整，同时支持动态任务注册和静态任务注册,例如：

**例子**

> ```
> /***********************************静态任务创建步骤********************************************
> *1.创建使用  thread_fork 接口的 静态任务堆栈
> *  (1)在app_main.c中创建静态任务堆栈:
> *      #define STATIC_TASK_CREATE_STK_SIZE 256
> *      #define STATIC_TASK_CREATE_Q_SIZE 0
> *      #static u8 test_stk_q[sizeof(struct thread_parm) + STATIC_TASK_CREATE_STK_SIZE * 4 + \
> *                                            (STATIC_TASK_CREATE_Q_SIZE ? (sizeof(struct task_queue) + APP_CORE_Q_SIZE) : 0 )] ALIGNE(4);
> *
> *  (2)在app_main.c中将静态任务加入任务列表const struct task_info task_info_table[]：
> *      {任务名,        任务优先级,      任务堆栈大小,   任务消息队列大小,  任务堆栈},
> *      {"task_create_static_test", STATIC_TASK_CREATE_PRIO, STATIC_TASK_CREATE_STK_SIZE, STATIC_TASK_CREATE_Q_SIZE, test_stk_q},
> *********************************************************************************************/
> #include "os_test.h"
> #define STATIC_TASK_CREATE_STK_SIZE 256
> #define STATIC_TASK_CREATE_Q_SIZE 0
> #define STATIC_TASK_CREATE_PRIO 12
>
> static int task_pid;
> static int kill_req = 0;
>
> static void task_create_static_test(void *p)
> {
>   //获取当前线程
>   printf("task_create_static_test in (%s) task\n", os_current_task());
>
>   while(1)
>   {
>     printf("Use static task stack to create task test!");
>     os_time_dly(50);
>
>     if(kill_req)
>     {
>       //退出任务前必须释放占用的资源
>       os_time_dly(1000);
>       break;
>     }
>   }
> }
>
> void static_task_test(void)
> {
>   thread_fork("task_create_static_test", STATIC_TASK_CREATE_PRIO, STATIC_TASK_CREATE_STK_SIZE, STATIC_TASK_CREATE_Q_SIZE, &task_pid, task_create_static_test, NULL);
>
>   os_time_dly(50);
>
>     puts("Exiting the task_create_static_test thread!\n");
>
>   //退出线程请求
>   kill_req = 1;
>
>   //阻塞等待线程退出
>     thread_kill(&task_pid, KILL_WAIT);
>   puts("Exit the task_create_static_test thread successfully!");
> }
> ```

---

## 7.8.3. 消息队列(Queue)

**消息队列创建**

| **项目**   | **内容**                                                                                                      |
| ---------------- | ------------------------------------------------------------------------------------------------------------------- |
| **函数**   | int os_taskq_post_type(const char* name, int type, int argc, int* argv);                                            |
| **描述**   | 创建消息队列                                                                                                        |
| **参数**   | name：消息接收方的线程名称 type：消息类型 argc：消息个数 argv: 指向要发送的消息的指针                               |
| **返回值** | 0：成功 ；OS_TASK_NOT_EXIST： 任务不存在； OS_ERR_POST_NULL_PTR： 任务消息队列不存在； OS_Q_FULL： 任务消息队列已满 |

**例子**

> ```
> /***********************************消息队列测试说明********************************************
> *说明：
> *     设置queue_task任务和task3_task任务为同等优先级，queue_task任务阻塞等到消息，当收到task3_task
> *   任务的消息后，向task3_task发送接收到消息通知。
> *********************************************************************************************/
>
> #include "os_test.h"
>
> #define QUEUE_TASK_PRIO 10        //任务优先级大小
> #define QUEUE_STACK_SIZE 512      //任务堆栈大小
> #define QUEUE_QUEUE_SIZE 256      //消息队列大小，注意任务间需要通过消息队列通讯时必须分配足够的消息队列大小，否则接收不到消息。
> static int queue_pid;
>
> #define TASK3_TASK_PRIO 10
> #define TASK3_STACK_SIZE 512
> #define TASK3_QUEUE_SIZE 256
> static int task3_pid;
>
> //消息类型
> enum {
>     MESSAGE_1     = 0x01,
>     MESSAGE_2     = 0x02,
>     MESSAGE_3     = 0x03,
> };
>
> enum {
>     GET_MESSAGE_1     = 0x01,
>     GET_MESSAGE_2     = 0x02,
>     GET_MESSAGE_3     = 0x03,
> };
>
> static char *message1 = "Message1 received!";
> static char *message2 = "Message2 received!";
> static char *message3 = "Message3 received!";
>
> //等待消息队列任务
> static void queue_task(void *priv)
> {
>   int argc = 2;  //消息个数
>   int argv[4];
>     int msg[32];   //接收消息队列buf
>     int err;
>   char *ptr = NULL;
>
>   //获取当前线程
>   printf("queue_task in (%s) task\n", os_current_task());
>
>     while (1) {
>     //阻塞等待消息
>         err = os_taskq_pend("taskq", msg, ARRAY_SIZE(msg));
>         if (err != OS_TASKQ || msg[0] != Q_USER) {
>             continue;
>         }
>
>         switch (msg[1]) {
>         case MESSAGE_1:
>       printf("get MESSAGE_1, data : %d\n", msg[2]);
>       ptr = message1;
>             break;
>
>         case MESSAGE_2:
>       printf("get MESSAGE_2, data : %d\n", msg[2]);
>       ptr = message2;
>             break;
>
>         case MESSAGE_3:
>       printf("get MESSAGE_3, data : %d\n", msg[2]);
>       ptr = message3;
>             break;
>
>             default:
>                 break;
>         }
>
>     argv[0] = msg[1];
>     argv[1] = (int)ptr;
>
> _retry1:
>     //向任务task3_task发送接收到消息通知
>     err = os_taskq_post_type("task3_task", Q_USER, argc, argv);
>     //err = os_taskq_post("task3_task", argc, argv[0], argv[1]);//采用该接口发送信息时可变参数个数不能超过8个
>     if(err == OS_Q_FULL)
>     {
>       os_time_dly(10);
>       goto _retry1;
>     }
>     }
> }
>
> static void task3_task(void *priv)
> {
>   int err;
>   int argc = 2;  //消息个数
>   int argv[4];
>     int msg[32];   //接收消息队列buf
>   char *ptr = NULL;
>
>   //获取当前线程
>   printf("task3_task in (%s) task\n", os_current_task());
>
>     //发送的消息内容
>   argv[0] = MESSAGE_1;
>   argv[1] = 12;
>
>   while(1)
>   {
>     //向任务queue_task发送消息
>     err = os_taskq_post_type("queue_task", Q_USER, argc, argv);
>     //err = os_taskq_post("queue_task", argc, argv[0], argv[1]);//采用该接口发送信息时可变参数个数不能超过8个
>     if(err == OS_Q_FULL)
>     {
>       os_time_dly(10);
>       continue;
>     }
>
>     os_time_dly(20);
>
> _retry2:
>     //等待queue_task任务回复
>         err = os_taskq_pend("taskq", msg, ARRAY_SIZE(msg));
>         if (err != OS_TASKQ || msg[0] != Q_USER) {
>             goto _retry2;
>         }
>
>         switch (msg[1]) {
>         case GET_MESSAGE_1:
>       ptr = (char *)msg[2];
>       printf("%s\n", ptr);
>
>       argv[0] = MESSAGE_2;
>       argv[1] = 10;
>             break;
>
>         case GET_MESSAGE_2:
>       ptr = (char *)msg[2];
>       printf("%s\n", ptr);
>
>       argv[0] = MESSAGE_3;
>       argv[1] = 11;
>             break;
>
>         case GET_MESSAGE_3:
>       ptr = (char *)msg[2];
>       printf("%s\n", ptr);
>
>       argv[0] = MESSAGE_1;
>       argv[1] = 12;
>             break;
>
>             default:
>                 break;
>         }
>
>     os_time_dly(100);
>   }
> }
>
> //队列测试
> void queue_test(void)
> {
>     if (thread_fork("queue_task", QUEUE_TASK_PRIO,  QUEUE_STACK_SIZE, QUEUE_QUEUE_SIZE, &queue_pid, queue_task, NULL) != OS_NO_ERR) {
>         printf("thread fork fail\n");
>     }
>
>   //创建任务2
>     if (thread_fork("task3_task", TASK3_TASK_PRIO, TASK3_STACK_SIZE, TASK3_QUEUE_SIZE, &task3_pid, task3_task, NULL) != OS_NO_ERR) {
>         printf("thread fork fail\n");
>     }
> }
> ```

---

## 7.8.4. 信号量(Semaphore)

**信号量创建**

| **项目**   | **内容**                           |
| ---------------- | ---------------------------------------- |
| **函数**   | int os_sem_create(OS_SEM* sem, int cnt); |
| **描述**   | 创建信号量                               |
| **参数**   | sem：信号量 cnt： 初始计数值             |
| **返回值** | 0：成功 ；其他：失败                     |

**例子**

> ```
> #include "os_test.h"
>
> static OS_SEM psem;
>
> static void thread_pend_sem(void *priv)
> {
>   //获取当前线程
>   printf("thread_pend_sem in (%s) task\n", os_current_task());
>
>     while (1) {
>     puts(">>>>>>>[0]thread_pend_sem : wait sem!");
>
>         os_sem_pend(&psem, 0); //获取信号量
>
>     puts(">>>>>>>[2]thread_pend_sem : get sem!");
>     }
> }
>
> static void thread_post_sem(void *priv)
> {
>   //获取当前线程
>   printf("thread_post_sem in (%s) task\n", os_current_task());
>
>     while (1) {
>         os_time_dly(1000);  //延时模拟任务执行一段时间后释放信号量
>
>         os_sem_post(&psem); //释放信号量
>
>     puts(">>>>>>>[1]thread_post_sem : post sem!");
>     }
> }
>
> void sem_test(void)
> {
>     os_sem_create(&psem, 0);
>
>     if (thread_fork("thread_pend_sem", 10,  256, 0, NULL, thread_pend_sem, NULL) != OS_NO_ERR) {
>         printf("thread fork fail\n");
>     }
>
>     if (thread_fork("thread_post_sem", 10, 256, 0, NULL, thread_post_sem, NULL) != OS_NO_ERR) {
>         printf("thread fork fail\n");
>     }
>
> }
> ```

---

## 7.8.5. 互斥量(Mutex)

**互斥量创建**

**例子**

> ```
> #include "os_test.h"
>
> #define TASK1_TASK_PRIO 10     //任务优先级
> #define TASK1_STACK_SIZE 512   //任务栈大小
> #define TASK1_QUEUE_SIZE 0     //消息队列大小
> static int task1_pid = 0;      //任务pid
>
> #define TASK2_TASK_PRIO 10
> #define TASK2_STACK_SIZE 512
> #define TASK2_QUEUE_SIZE 0
> static int task2_pid = 0;
>
> static OS_MUTEX mutex;
> static int value = 0;
>
> char *str1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
> char *str2 = "abcdefghijklmnopqrstuvwxyz";
>
> #if 0
> /***********************************互斥量测试说明********************************************
> *说明：
> *     设置task1_task任务和task2_task任务为同等优先级，获取到互斥量的任务拥有该互斥量的使用权，
> *其他任务想获取该互斥量必须等获取到互斥量的任务完成其工作并释放该互斥量才行。
> *********************************************************************************************/
> static void task1_task(void *priv)
> {
>     char *str = (char *)str1;
>
>     os_mutex_pend(&mutex, 0);
>
>     while (*str != '\0') {
>         printf("%c\n", *str);
>         str++;
>     }
>     puts("\n");
>
>   os_mutex_post(&mutex);
> }
>
> static void task2_task(void *priv)
> {
>     char *str = (char *)str2;
>
>     os_mutex_pend(&mutex, 0);
>
>     while (*str != '\0') {
>         printf("%c\n", *str);
>         str++;
>     }
>     puts("\n");
>
>   os_mutex_post(&mutex);
> }
> #else
> /***********************************互斥量测试说明********************************************
> *说明：
> *     设置task1_task任务和task2_task任务为同等优先级，某个任务在执行期间对value的值进行修改
> *  只有获取到互斥量的任务能获得value的使用权，其他任务需要等待该互斥量释放并获取到互斥量才
> *   能对value进行修改, 从而可以通过互斥量来处理共享资源，防止多线程重入。
> *********************************************************************************************/
> static void task1_task(void *priv)
> {
>   //获取当前线程
>   printf("task1_task in (%s) task\n", os_current_task());
>   printf("task1_task pid : 0x%x\n", task1_pid);
>
>   while(1)
>   {
>     os_mutex_pend(&mutex, 0);
>     value = 100;
>     printf("==========>Task1 gets the mutex!");
>
>     for(int i = 0; i < 8; i++)
>     {
>       printf("task1 is running...\n");
>       printf("value : (%d)\n", value);
>       os_time_dly(20);
>     }
>
>     printf("==========>Task1 post the mutex!");
>     os_mutex_post(&mutex);
>     os_time_dly(100);
>   }
> }
>
> void task2_task(void *priv)
> {
>   //获取当前线程
>   printf("task2_task in (%s) task\n", os_current_task());
>   printf("task2_task pid : 0x%x\n", task2_pid);
>
>   while(1)
>   {
>     os_mutex_pend(&mutex, 0);
>     value = 200;
>     printf("==========>Task2 gets the mutex!");
>     for(int i = 0; i < 8; i++)
>     {
>       printf("task2 is running...\n");
>       printf("value : (%d)\n", value);
>       os_time_dly(20);
>     }
>
>     printf("==========>Task2 post the mutex!");
>     os_mutex_post(&mutex);
>     os_time_dly(100);
>   }
> }
> #endif
>
> void mutex_test(void)
> {
>   os_mutex_create(&mutex);
>
>   //创建任务1
>     if (thread_fork("task1_task", TASK1_TASK_PRIO, TASK1_STACK_SIZE, TASK1_QUEUE_SIZE, &task1_pid, task1_task, NULL) != OS_NO_ERR) {
>         printf("thread fork fail\n");
>     }
>
>   //创建任务2
>     if (thread_fork("task2_task", TASK1_TASK_PRIO, TASK1_STACK_SIZE, TASK1_QUEUE_SIZE, &task2_pid, task2_task, NULL) != OS_NO_ERR) {
>         printf("thread fork fail\n");
>     }
> }
> ```

---

## 7.8.6. 常见问题

* 创建静态任务和创建动态任务有什么区别，该如何选择？

答：静态任务创建时采用的是静态内存，而动态任务创建时采用的动态内存。采用静态任务创建可以减小内存碎片；动态任务创建由于会频繁分配和释放内存，容易产生内存碎片。因此系统运行期间都必须存在的任务可采用静态任务创建，而运行周期较短的任务采用动态任务创建，这样一定程度上可以减小内存碎片和内存开销。

* `task_create` 、 `thread_fork` 、 `os_task_create` 有什么区别，使用场合有哪些不同？

答：task_create创建线程到指定的任务列表的任务中。thread_fork创建的线程如果没有死循环执行完成后就会自动kill。os_task_create创建的线程一定要有死循环，不然概率触发死机重启。

* 程序运行时出现thread can’t kill! pid : 0x400ce5c,rets_addr = 0x20110e6，怎么解决？如何正确退出线程？

答：出现这个打印是因为对应的线程无法退出导致的，thread_kill会阻塞等待线程退出，通过pid可找到对应的线程，或通过rets_addr地址找到阻塞的位置。需要退出线程时可通过设置标志位的方法，可参考 `static_task_test.c` 例程，或通过消息队列给对应线程发送特定消息，线程收到该消息后进行退出操作。

## 7.8.7. API Reference

**Defines**

Q_MSG
普通消息

Q_EVENT
事件消息

Q_CALLBACK
回调消息

Q_USER
用户消息

OS_DEL_NO_PEND
OS_DEL_ALWAYS

OS_TASK_DEL_REQ
OS_TASK_DEL_RES
OS_TASK_DEL_OK

OS_TASK_SELF
OS_TASK_FATHER

**Typedefs**

typedef enum **kill_mode**
enum kill_mode used by thread_kill

**Values:**

**KILL_WAIT**
WAIT

**KILL_REQ**
REQUEST

**KILL_FORCE**
FORCE ON

**Functions**

void **os_init**(void)
初始化操作系统

void **os_init_tick**(int)
初始化操作系统的时钟节拍

void **os_start**(void)
操作系统开始调度

int **os_task_create**(void (*func)(void *parm), void *parm, u8 prio, u32 stk_size, int q_size, const char *name)
创建一个任务，任务栈使用动态分配

**Parameters:**
func – [in] 入口功能函数

parm – [in] 入口函数的私有指针

prio – [in] 优先级

stk_size – [in] 堆栈空间的大小（以四个字节为一个单位）

q_size – [in] 消息队列空间的大小（以四个字节为一个单位）

name – [in] 任务名

**Returns:**	0: 成功

**Returns:**	-1: 失败

int **os_task_create_static**(void (*func)(void *parm), void *parm, u8 prio, u32 stk_size, int q_size, const char *name, u8 *tcb_stk_q)
创建一个任务，任务栈使用静态分配

**Parameters:**
func – [in] 入口功能函数

parm – [in] 入口函数的私有指针

prio – [in] 优先级

stk_size – [in] 堆栈空间的大小（以四个字节为一个单位）

q_size – [in] 消息队列空间的大小（以四个字节为一个单位）

name – [in] 任务名

tcb_stk_q – [in] 静态内存块（包括任务控制块空间+任务栈空间+消息队列空间）

**Returns:**	0: 成功

**Returns:**	-1: 失败

const char **os_current_task**(void)
获取当前任务名

**Returns:**	当前任务名

void **os_task_set_priority**(const char *task_name, u8 new_priority)
动态调整任务的优先级

**Parameters:**
task_name – [in] 需要调整的任务名

new_priority – [in] 调整后的任务优先级

unsigned int **os_current_task_prio**(void)
获取当前任务的优先级

**Returns:**	当前任务的优先级

unsigned int **os_current_task_stask_size**(void)
获取当前任务的任务栈大小

**Returns:**	当前任务的任务栈大小

unsigned int **os_time_get**(void)
获取当前时钟节拍数

**Returns:**	当前时钟节拍数

int **os_task_del_req**(const char *name)
请求删除任务

**Parameters:**
name – [in] 需要删除的任务名

**Returns:**	删除标志tag

int **os_task_del_res**(const char *name)
响应任务删除请求，标记资源已经释放，可以删除当前任务

**Parameters:**
name – [in] 需要删除的任务名，当前任务可以用OS_TASK_SELF

**Returns:**	0: 成功

**Returns:**	-1: 失败

int **os_task_del**(const char *name)
强制删除任务

**Note**

任务不能删除自己，需要在其他任务中调用

**Parameters:**
name – [in] 需要删除的任务名

**Returns:**	0: 成功

**Returns:**	-1: 失败

void **os_time_dly**(int time_tick)
延时

**Note**

不可在中断函数或者临界区调用

**Parameters:**
time_tick – [in] 延时节拍，一个tick等于10ms

int **__os_taskq_post**(const char *name, int type, int argc, int *argv)
发送任务队列消息

**Parameters:**
name – [in] 消息队列所属任务名

type – [in] 消息类型

argc – [in] 消息个数

argv – [in] 消息数组

**Returns:	**0: 成功

**Returns:**	OS_TASK_NOT_EXIST: 任务不存在

**Returns:**	OS_ERR_POST_NULL_PTR: 任务消息队列不存在

**Returns:**	OS_Q_FULL: 任务消息队列已满

int **__os_taskq_pend**(int *argv, int argc, int tick)
接收任务队列消息

**Parameters:**
tick – [in] 等待超时，时钟节拍为单位，取0不等待马上返回

argv – [in] 可用消息数组

argc – [in] 可用消息个数

**Returns:**	OS_TASKQ: 成功

**Returns:**	OS_Q_EMPTY: 任务消息队列为空

int **__os_taskq_del**(const char *name, int type, int argc, int *msg)
删除任务队列的指定某个消息

**Parameters:**
name – [in] 消息队列所属任务名

type – [in] 消息类型

argv – [in] 之前发送的消息个数

msg – [in] 之前发送的消息

**Returns:**	0: 成功

**Returns:**	OS_TASK_NOT_EXIST: 任务不存在

**Returns:**	OS_ERR_POST_NULL_PTR: 任务消息队列不存在

int **os_taskq_pend**(const char *fmt, int *argv, int argc)
接收任务队列消息，无限等待

**Parameters:**
fmt – [in] “taskq”
argv – [in] 可用消息数组
argc – [in] 可用消息个数

**Returns:**	OS_TASKQ: 成功

**Returns:**	OS_Q_EMPTY: 任务消息队列为空

int **os_taskq_pend_timeout**(const char *fmt, int *argv, int argc, int tick)
接收任务队列消息，无限等待

**Parameters:**
fmt – [in] “taskq”
argv – [in] 可用消息数组
argc – [in] 可用消息个数
tick – [in] 超时tick个数

**Returns:**	OS_TASKQ: 成功

**Returns:**	OS_Q_EMPTY: 任务消息队列为空

int **os_taskq_post**(const char *name, int argc, ...)
发送任务队列普通消息

**Parameters:**
name – [in] 消息队列所属任务名
argc – [in] 消息个数
... – [in] 消息可变参数

**Returns:**	0: 成功

**Returns:**	OS_TASK_NOT_EXIST: 任务不存在

**Returns:**	OS_ERR_POST_NULL_PTR: 任务消息队列不存在

**Returns:**	OS_Q_FULL: 任务消息队列已满

int **os_taskq_del**(const char *name, int type)
删除任务队列的某种类型的所有消息

**Parameters:**
name – [in] 消息队列所属任务名
type – [in] 消息类型

**Returns:**	0: 成功

**Returns:**	OS_TASK_NOT_EXIST: 任务不存在

**Returns:**	OS_ERR_POST_NULL_PTR: 任务消息队列不存在

int **os_taskq_post_type**(const char *name, int type, int argc, int *argv)
发送任务队列消息

**Parameters:**
name – [in] 消息队列所属任务名
type – [in] 消息类型
argc – [in] 消息个数
argv – [in] 消息数组

**Returns:**	0: 成功

**Returns:**	OS_TASK_NOT_EXIST: 任务不存在

**Returns:**	OS_ERR_POST_NULL_PTR: 任务消息队列不存在

**Returns:**	OS_Q_FULL: 任务消息队列已满

int **os_taskq_post_msg**(const char *name, int argc, ...)
发送任务队列的普通消息

**Parameters:**
name – [in] 消息队列所属任务名
argc – [in] 消息个数
... – [in] 消息可变参数

**Returns:**	0: 成功

**Returns:**	OS_TASK_NOT_EXIST: 任务不存在

**Returns:**	OS_ERR_POST_NULL_PTR: 任务消息队列不存在

**Returns:**	OS_Q_FULL: 任务消息队列已满

int **os_taskq_flush**(void)
重置当前任务的消息队列

**Note**

需要在当前任务中调用

**Returns:**	0: 成功

**Returns:**	-1: 失败

int **os_sem_create**(OS_SEM *sem, int cnt)
创建信号量

**Parameters:**
sem – [in] 信号量
cnt – [in] 初始计数值

**Returns:**	0: 成功

**Returns:**	-1: 失败

int **os_sem_pend**(OS_SEM *sem, int timeout)
等待信号量

**Note**

不可在中断函数或者临界区调用

**Parameters:**
sem – [in] 信号量
timeout – [in] 等待超时（时钟节拍），取0时无限等待，不堵塞请使用os_sem_accept

**Returns:**	0: 成功

**Returns:**	OS_TIMEOUT: 等待超时

int **os_sem_accept**(OS_SEM *sem)
获取信号量（非堵塞）

**Note**

不可在中断函数或者临界区调用

**Parameters:**
sem – [in] 信号量

**Returns:**	0: 成功

**Returns:**	OS_TIMEOUT: 获取失败

int **os_sem_post**(OS_SEM *sem)
发送信号量

**Parameters:**
sem – [in] 信号量

**Returns:**	0: 成功

**Returns:**	-EFAULT: 失败

int **os_sem_del**(OS_SEM *sem, int force)
删除信号量

**Parameters:**
sem – [in] 信号量
force – [in] 是否强制删除

**Returns:**	0: 成功

**Returns:**	-1: 失败

int **os_sem_set**(OS_SEM *sem, u16 cnt)
设置信号量的计数值

**Parameters:**
sem – [in] 信号量
cnt – [in] 计数值

**Returns:**	0: 成功

**Returns:**	-1: 失败

int **os_sem_valid**(OS_SEM *sem)
检查信号量是否合法

**Parameters:**
sem – [in] 信号量

**Returns:** **1: 有效**
**Returns:** **0: 非法**

int **os_sem_query**(OS_SEM *sem)
检查信号量是否空闲

**Parameters:**
sem – [in] 信号量

**Returns:** **1: 没有其他线程在等待此信号量**
**Returns:** **0: 其他线程在等待此信号量**

int **os_mutex_valid**(OS_MUTEX *mutex)
检查互斥量是否合法

**Parameters:**
mutex – [in] 互斥量

**Returns:** **1: 有效**
**Returns:** **0: 非法**

int **os_q_create**(OS_QUEUE *pevent, QS size)
创建消息队列，内存采用动态分配

**Parameters:**
pevent – [in] 消息队列
size – [in] 消息队列大小，以word为单位

**Returns:** **0: 成功**
**Returns:** **-1: 失败**

int **os_q_valid**(OS_QUEUE *pevent)
检查消息队列是否合法

**Parameters:**
pevent – [in] 互斥量

**Returns:** **1: 有效**
**Returns:** **0: 非法**

int **os_q_is_full**(OS_QUEUE *pevent)
检查消息队列是否已满

**Parameters:**
pevent – [in] 互斥量

**Returns:** **1: 消息队列已满**
**Returns:** **0: 消息队列未满**

int **sem_valid**(int *sem)
检测信号量是否有效

**Parameters:**
sem – [in] 指向需要查询的信号量的指针

**Returns:** **1: 有效**
**Returns:** **0: 非法**

# 7.9. PTHREAD API

SDK中提供了两种操作系统API，一种是基于FreeRTOS原接口进行再次封装的API（这里简称为OS API）， 在SDK有更好的兼容性，所以SDK中大量采用了这类API（具体请参考 OS API）)；另一种为POSIX Threads（这里简称为pthread api）；

## 7.9.1. DEMO

使用工程：示例代码见 `apps/common/example/system/os/pthreads_api/main.c`，测试时需要在 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_PTHREAD_API_TEST` 。

**示例说明**

展示了PTHREAD API基本使用方法，包括任务创建、信号量、互斥量的使用和消息队列的使用等，主要示例包括：

* posix_mutex_test(); 互斥量使用示例
* posix_queue_test(); 消息队列使用示例
* posix_sem_test(); 信号量使用示例

## 7.9.2. 线程(Task)

**线程创建**

| **函数**   | int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*startroutine)(void *), void *arg)                                                        |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **描述**   | 创建线程                                                                                                                                                           |
| **参数**   | thread：指向线程句柄的指针，不能为NULL attr： 指向线程属性的指针，如果使用NULL，则使用默认的线程属性 startroutine：线程入口函数地址 arg： 传递给线程入口函数的参数 |
| **返回值** | 0：成功 其他：失败                                                                                                                                                 |

**例子**

> ```
> #include <pthread.h>
>
> static pthread_t thread1;
> static pthread_t thread2;
>
> static void* thread_entry(void* parameter)
> {
>     int cnt = 0;
>     int data = (int) parameter;
>
>     while (1)
>     {
>         printf("data : %d, cnt : %d\n", data, cnt++);
>
>         sleep(5);
>     }
>
>     return NULL;
> }
>
> int application_init()
> {
>     int ret;
>     int data1 = 1；
>     int data2 = 2;
>
>     /** 创建线程1*/
>     ret = pthread_create(&thread1, NULL, thread_entry, (void*)data1);
>     if(0 != ret)
>         printf("pthread_create failed! error code is %d\n", ret);
>
>     /** 创建线程2*/
>     ret = pthread_create(&thread2, NULL, thread_entry, (void*)data2);
>     if(0 != ret)
>         printf("pthread_create failed! error code is %d\n", ret);
>
>     return 0;
> }
> ```

**阻塞等待线程退出**

| **函数**   | int pthread_join(pthread_t thread, void **retval)                        |
| ---------------- | ------------------------------------------------------------------------ |
| **描述**   | 阻塞等待线程退出                                                         |
| **参数**   | thread：线程句柄 retval： 用户定义的指针，用来存储被等待线程的返回值地址 |
| **返回值** | 0：成功 其他：失败                                                       |

**例子**

> ```
> #include <pthread.h>
>
> static pthread_t thread1;
> static pthread_t thread2;
>
> static void* thread_entry1(void* parameter)
> {
>     int cnt = 0;
>     int data = (int) parameter;
>
>     for(int i; i < 4; i++)
>     {
>         printf("data : %d, cnt : %d\n", data, cnt++);
>
>         sleep(5);
>     }
>
>     printf("thread1 exited!\n");
>     return NULL;
> }
>
> static void* thread_entry2(void* parameter)
> {
>     int cnt = 0;
>     int data = (int) parameter;
>
>     /** 阻塞等待线程1运行退出 */
>     pthread_join(thread1, NULL);
>
>     for(int i; i < 4; i++)
>     {
>         printf("data : %d, cnt : %d\n", data, cnt++);
>
>         sleep(5);
>     }
>
>     printf("thread1 exited!\n");
>     return NULL;
> }
>
> int application_init()
> {
>     int ret;
>     int data1 = 1；
>     int data2 = 2;
>
>     /** 创建线程1*/
>     ret = pthread_create(&thread1, NULL, thread_entry1, (void*)data1);
>     if(0 != ret)
>         printf("pthread_create failed! error code is %d\n", ret);
>
>     /** 创建线程2*/
>     ret = pthread_create(&thread2, NULL, thread_entry2, (void*)data2);
>     if(0 != ret)
>         printf("pthread_create failed! error code is %d\n", ret);
>
>     return 0;
> }
> ```

**退出线程**

| **函数**   | void pthread_exit(void *value_ptr)                         |
| ---------------- | ---------------------------------------------------------- |
| **描述**   | 退出线程                                                   |
| **参数**   | value_ptr： 用户定义的指针，用来存储被等待线程的返回值地址 |
| **返回值** | 0：成功 其他：失败                                         |

**例子**

> ```
> #include <pthread.h>
>
> static pthread_t thread;
>
> static void* thread_entry(void* parameter)
> {
>     int cnt = 0;
>     int data = (int) parameter;
>
>     while (1)
>     {
>         printf("data : %d, cnt : %d\n", data, cnt++);
>
>         sleep(5);
>
>         pthread_exit(NULL); //退出线程
>     }
>
>     printf("thread exited!\n");
>
>     return NULL;
> }
>
> int application_init()
> {
>     int ret;
>     int data1 = 1；
>
>     /** 创建线程*/
>     ret = pthread_create(&thread, NULL, thread_entry, (void*)data1);
>     if(0 != ret)
>         printf("pthread_create failed! error code is %d\n", ret);
>
>     return 0;
> }
> ```

---

## 7.9.3. 消息队列(Queue)

**创建消息队列**

| **函数**   | mqd_t mq_open(const char *name, int oflag, mode_t mode, struct mq_attr *attr) |
| ---------------- | ----------------------------------------------------------------------------- |
| **描述**   | 创建消息队列                                                                  |
| **参数**   | name：消息队列名称 oflag：消息队列打开方式 mode：attr：                       |
| **返回值** | 非NULL：返回消息队列句柄 NULL：失败                                           |

**发送消息**

| **函数**   | int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio)                     |
| ---------------- | ---------------------------------------------------------------------------------------------------- |
| **描述**   | 发送消息                                                                                             |
| **参数**   | mqdes：消息队列句柄 msg_ptr：指向要发送的消息的指针 msg_len：发送的消息的长度 msg_prio：不支持，忽略 |
| **返回值** | 0：成功 其他：失败                                                                                   |

**接收消息**

**例子**

> ```
> static mqd_t mqID;
>
> //发送线程
> static void *thread_send(void *args)
> {
>     char msg[] = "This is a message for test!";
>     mqd_t *sendID = (mqd_t *)args;
>
>     while (1) {
>         if (mq_send(*sendID, msg, sizeof(msg), 0) < 0) {
>             printf("send msg err!\n");
>             //终止当前线程
>             pthread_exit(NULL);
>         }
>
>         os_time_dly(100);
>     }
>
>     return (void *)0;
> }
>
> //接收线程
> static void *thread_rec(void *args)
> {
>     char buf[128] ;
>     mqd_t *recID = (mqd_t *)args;
>
>     while (1) {
>         if (mq_receive(*recID, buf, sizeof(buf), NULL) < 0) {
>             printf("rec msg err!\r\n");
>
>             //终止当前线程
>             pthread_exit(NULL);
>         }
>
>         printf("Message received :(%s)\n", buf);
>     }
>
>     return (void *)0;
> }
>
> static void posix_queue_test(void)
> {
>     pthread_t send;
>     pthread_t rec;
>     struct mq_attr mqAttr;
>     pthread_attr_t attr = {0};
>     struct sched_param param;
>     int ret;
>
>     //创建消息队列
>     mqID = mq_open("/mQueue_test", O_RDWR | O_CREAT, 0666, NULL); //队列消息名字需要符合POSIX IPC的名字规则
>     if (mqID < 0) {
>         printf("mq_open err!!!\r\n");
>         return;
>     }
>
>     //获取消息队列属性
>     if (mq_getattr(mqID, &mqAttr) < 0) {
>         printf("mq_getattr err!!!\r\n");
>         return;
>     }
>
>     printf("mq_flags:%d\r\n", mqAttr.mq_flags);
>     printf("mq_maxmsg:%d\r\n", mqAttr.mq_maxmsg);
>     printf("mq_msgsize:%d\r\n", mqAttr.mq_msgsize);
>     printf("mq_curmsgs:%d\r\n", mqAttr.mq_curmsgs);
>
>     //初始化线程属性变量
>     pthread_attr_init(&attr);
>
>     //设置优先级
>     pthread_attr_getschedparam(&attr, &param);
>     param.sched_priority = 10;
>
>     //设置优先级
>     pthread_attr_setschedparam(&attr, &param);
>
>     //采用默认优先级时，设置为NULL
>     ret = pthread_create(&send, &attr, thread_send, &mqID);
>     //ret = pthread_create(&send, NULL,thread_send, &mqID);
>     if (ret) {
>         printf("pthread_create send error!!!\r\n");
>     }
>
>     pthread_create(&rec, NULL, thread_rec, &mqID);
>     if (ret) {
>         printf("pthread_create send error!!!\r\n");
>     }
> }
> ```

---

## 7.9.4. 信号量(Semaphore)

**初始化信号量**

| **函数**   | int sem_init(sem_t *sem, int pshared, unsigned value)                       |
| ---------------- | --------------------------------------------------------------------------- |
| **描述**   | 初始化信号量                                                                |
| **参数**   | sem：信号量句柄 pshared：忽略 value: 信号量初始值，表示信号量资源的可用数量 |
| **返回值** | 0：成功 其他：失败                                                          |

**获取信号量**

| **函数**   | int sem_wait(sem_t *sem) |
| ---------------- | ------------------------ |
| **描述**   | 阻塞方式等待信号量       |
| **参数**   | sem：信号量句柄          |
| **返回值** | 0：成功 其他：失败       |

| **函数**   | int sem_trywait(sem_t *sem) |
| ---------------- | --------------------------- |
| **描述**   | 非阻塞方式等待信号量        |
| **参数**   | sem：信号量句柄             |
| **返回值** | 0：成功 其他：失败          |

**释放信号量**

| **函数**   | int sem_post(sem_t *sem) |
| ---------------- | ------------------------ |
| **描述**   | 释放信号量               |
| **参数**   | sem：信号量句柄          |
| **返回值** | 0：成功 其他：失败       |

**例子**

> ```
> static sem_t psem;
> static pthread_t waitSem;
> static pthread_t postSem;
>
> static void *thread_wait_sem(void *args)
> {
>     while (1) {
>         puts(">>>>>>>[0]thread_wait_sem : wait sem!");
>         sem_wait(&psem);
>         puts(">>>>>>>[2]thread_wait_sem : get sem!");
>     }
>     return (void *)0;
> }
>
> static void *thread_post_sem(void *args)
> {
>     while (1) {
>         os_time_dly(1000);
>         sem_post(&psem);
>         puts(">>>>>>>[1]thread_post_sem : post sem!");
>     }
>
>     return (void *)0;
> }
>
> static void posix_sem_test(void)
> {
>     int ret;
>
>     ret = sem_init(&psem, 0, 0);
>     if (ret) {
>         puts("sem_init err!!!");
>     }
>
>     pthread_create(&waitSem, NULL, thread_wait_sem, NULL);
>
>     pthread_create(&postSem, NULL, thread_post_sem, NULL);
>
>     os_time_dly(50);
>
> }
>
> ```

---

## 7.9.5. 互斥锁(Mutex)

**初始化互斥锁**

| **函数**   | int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr) |
| ---------------- | ------------------------------------------------------------------------------- |
| **描述**   | 初始化互斥锁                                                                    |
| **参数**   | mutex：互斥锁句柄 attr： 指向互斥锁属性的指针，若该指针NULL，则使用默认的属性。 |
| **返回值** | 0：成功 其他：失败                                                              |

**互斥锁上锁**

| **函数**   | int pthread_mutex_lock(pthread_mutex_t *mutex)                                 |
| ---------------- | ------------------------------------------------------------------------------ |
| **描述**   | 阻塞方式给互斥锁上锁 ，如果互斥锁mutex被其他线程上锁持有，当前线程将阻塞等待。 |
| **参数**   | mutex：互斥锁句柄                                                              |
| **返回值** | 0：成功 其他：失败                                                             |

| **函数**   | int pthread_mutex_trylock(pthread_mutex_t *mutex)                                            |
| ---------------- | -------------------------------------------------------------------------------------------- |
| **描述**   | 非阻塞方式给互斥锁上锁 ，如果互斥锁mutex已经被上锁，当前线程不会阻塞等待，而是马上返回错误码 |
| **参数**   | mutex：互斥锁句柄                                                                            |
| **返回值** | 0：成功 其他：失败                                                                           |

**互斥锁解锁**

| **函数**   | int pthread_mutex_unlock(pthread_mutex_t *mutex) |
| ---------------- | ------------------------------------------------ |
| **描述**   | 互斥锁解锁                                       |
| **参数**   | mutex：互斥锁句柄                                |
| **返回值** | 0：成功 其他：失败                               |

**销毁互斥锁**

| **函数**   | int pthread_mutex_destroy(pthread_mutex_t *mutex) |
| ---------------- | ------------------------------------------------- |
| **描述**   | 销毁互斥锁                                        |
| **参数**   | mutex：互斥锁句柄                                 |
| **返回值** | 0：成功 其他：失败                                |

**例子**

> ```
> static pthread_mutex_t mutex;
> static pthread_t p1, p2;
>
> extern void os_time_dly(int tick);
>
> static void *func1(void *arg)
> {
>     char *str = (char *)arg;
>
>     //获取互斥锁
>     pthread_mutex_lock(&mutex);
>
>     while (*str != '\0') {
>         printf("%c\n", *str);
>         str++;
>     }
>     puts("\n");
>
>     //释放互斥锁
>     pthread_mutex_unlock(&mutex);
>
>     return (void *)0;
> }
>
> static void *func2(void *arg)
> {
>     char *str = (char *)arg;
>
>     //获取互斥锁
>     pthread_mutex_lock(&mutex);
>
>     while (*str != '\0') {
>         printf("%c\n", *str);
>         str++;
>     }
>     puts("\n");
>
>     //释放互斥锁
>     pthread_mutex_unlock(&mutex);
>
>     return (void *)0;
> }
>
> static void posix_mutex_test(void)
> {
>     char *str1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
>     char *str2 = "abcdefghijklmnopqrstuvwxyz";
>     int err;
>
>     pthread_mutex_init(&mutex, NULL);
>
>     if ((err = pthread_create(&p1, NULL, func1, str1)) != 0) {
>         printf("[0]pthread_create fail\n");
>     }
>
>     if ((err = pthread_create(&p2, NULL, func2, str2)) != 0) {
>         printf("[1]pthread_create fail\n");
>     }
>
> }
> ```

# 7.10. FS

**Overview**

提供文件系统接口应用示例、常用相关 API 介绍和常见问题。

## 7.10.1. 应用示例

**示例演示：** 通过挂载SD卡进行文件系统接口调用：

* 长文件名和短文件名的打开
* 长文件名和短文件名的目录创建
* fscan、fslect和fget_name的用法

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_FS_TEST_DEMO` 或者 `USE_SD_TEST_DEMO` apps/common/example/storage/sd_fs/ main.c 或 main1.c，main1.c为长文件名使用 长文件名使用注意说明

**Note**

* 1.app_config.h：使能SD卡，需要定义#define TCFG_SD0_ENABLE 1同时在例子的main1.c中有以下几个宏 //测试例选择
  #define FILENAME_TEST 0 //长短文件名打开和目录创建操作测试
  #define FS_FSCAN_TEST 1 //扫描文件测试 fscan和fselect使用
* 2.长文件名：通过open的”w+”打开可 读/写文件，若文件存在则原文件会被直接覆盖；若文件不存在则创建该文件。通过fopen的”r”以只读方式打开文件，该文件必须存在。
* 3.短文件名文件除了通过像长文件名的方式进行创建和打开读写之外，也可以直接通过路径+短文件名如CONFIG_ROOT_PATH”filename.txt”，使用8+3规则，短文件名不能超过8个字节。
* 4.在测试创建长文件夹名和长文件名目录时，将filename_test()中的file_name修改如下：

  ```
  char file_name[128] = {
  '/','\\','U',0x4B,0x6D,0xD5,0x8B,0x7F,0x95,0x87,0x65,0xF6,0x4E,0x39,0x59,0x0D,0x54,0x4B,0x6D,0xD5,0x8B,'/',0x00,'\\','U',0x4B,0x6D,0xD5,0x8B,0x1B,0x52,0xFA,0x5E,0x7F,0x95,0x87,0x65,0xF6,0x4E,0x0D,0x54,0x4B,0x6D,0xD5,0x8B,0x2E,0x00,0x74,0x00,0x78,0x00,0x74,0x00
  };
  ```

  注意在文件夹名后’/’,0x00,’\’,’U’中间写入0x00，否则会创建目录失败。
* 5.fscan()：test中使用fscan()扫描CONFIG_STORAGE_PATH”/C/”路径中，搜索.txt格式文件-tTXT，包括子目录-r，按照按照文件号排序-sn
* 6.fslect()：test中通过使用fselect()通过选择的按顺序、按簇号和序号选择文件，然后通过fget_name()获取文件名。
* 7.fget_name()：传入的buf长度若少于16个字节则获取短文件名，大于等于16个字节则获取长文件名，由小机filename_test()若按照unicode编码创建的文件名读取到文件名均为unicode编码（包括中英文）；由windows创建的短英文文件名读取到文件名为utf-8编码，短中文文件名和长中英文文件名读取文件名均为unicode编码。
* 8.注意使用fget_name以后使用put_buf将文件名打印，不可使用printf(遇到0会结束打印)，打印的文件名为对应的fget_name获取到的编码格式的编码。
* 1.fmove使用参考 `apps/common/example/storage/sd_fs/main.c`,注意参数填写 path_dst目标路径；newFile保存操作成功后文件在新路径的文件流指针；path_len目标路径长度填写要正确不然会移动到根目录

  ```
  /**
  * @brief 移动文件
  *
  * @param file 指向文件流的文件指针
  * @param path_dst 目标路径，注意如果不需要更改原文件名，路径不需要填写文件名，如/aa/即可，根目录前面不能加分区路径
  * @param newFile 保存操作成功后文件在新路径的文件流指针
  * @param clr_attr 是否清除原有文件的文件属性
  * @param path_len 目标路径长度
  *
  * @return 0: 移动成功(自动关闭旧文件流)
  * @return other: 移动失败
  */
  int fmove(FILE *file, const char *path_dst, FILE **newFile, int clr_attr, int path_len);

  //storage/sd0/C/111/test.txt文件移动到storage/sd0/C/222目录下
  //FILE *fd = fopen(CONFIG_ROOT_PATH"111/test.txt", "w+");
  //FILE *newFile；
  //fmove(fd,"/222/",&newFile,0,5);//第二个参数是目标目录，由根目录开始，比如目录是storage/sd0/C/222，则填/222/
  ```

## 7.10.2. 常见问题

* SD卡打开文件失败？
  答：确保SD卡已经挂载成功后才能调用文件系统接口。
* 有些SD卡能挂载成功，有些却挂载不了？
  答：不同类型的SD卡读写速率不一样，对于低速卡如果挂载不成功时，尝试调整对应的板级配置

## 7.10.3. API Reference

**Defines**

Seek orig for fseek function

SEEK_SET
Seek from beginning of file.

SEEK_CUR
Seek from current position.

SEEK_END
Seek from end of file.

File attributes bits for fset_attr and fget_attr funciton

F_ATTR_RO
只读

F_ATTR_ARC
文件

F_ATTR_DIR
目录

F_ATTR_VOL
卷标

F_ATTR_HID
隐藏

FSELECT_MODE

Select mode for fselect function

FSEL_FIRST_FILE
选择第一个文件

FSEL_LAST_FILE
选择最后一个文件

FSEL_NEXT_FILE
选择下一个文件

FSEL_PREV_FILE
选择上一个文件

FSEL_CURR_FILE
选择当前文件

FSEL_BY_NUMBER
根据文件序号选择

FSEL_BY_SCLUST
根据分配单元选择文件

FSEL_AUTO_FILE
自动选择文件

FSEL_NEXT_FOLDER_FILE
选择下一个文件夹的文件

FSEL_PREV_FOLDER_FILE
选择上一个文件夹的文件

FSEL_BY_PATH
根据文件路径选择

FCYCLE_MODE

Cycle mode for fselect function

FCYCLE_LIST
全部文件循环模式

FCYCLE_ALL
unused

FCYCLE_ONE
当前文件循环模式

FCYCLE_FOLDER
文件夹循环模式

FCYCLE_RANDOM
随机循环模式

FCYCLE_MAX
unused

**Typedefs**

enum **[anonymous]**

*Values:*

**FS_IOCTL_GET_FILE_NUM**
unused

**FS_IOCTL_FILE_CHECK**
unused

**FS_IOCTL_GET_ERR_CODE**
暂不支持

**FS_IOCTL_FREE_CACHE**
unused

**FS_IOCTL_SET_NAME_FILTER**
设置文件过滤

**FS_IOCTL_GET_FOLDER_INFO**
获取文件夹序号和文件夹内文件数目

**FS_IOCTL_SET_LFN_BUF**
512

**FS_IOCTL_SET_LDN_BUF**
512

**FS_IOCTL_SET_EXT_TYPE**
设置后缀类型

**FS_IOCTL_OPEN_DIR**
打开目录

**FS_IOCTL_ENTER_DIR**
进入目录

**FS_IOCTL_EXIT_DIR**
退出目录

**FS_IOCTL_GET_DIR_INFO**
获取目录信息

**FS_IOCTL_GETFILE_BYNAME_INDIR**
由歌曲名称获得歌词

**FS_IOCTL_GET_DISP_INFO**
用于长文件名获取

**FS_IOCTL_MK_DIR**
创建文件夹

**FS_IOCTL_GET_ENCFOLDER_INFO**
获取录音文件信息

**FS_IOCTL_GET_OUTFLASH_ADDR**
获取外置flash实际物理地址（暂时用于手表case,特殊fat系统）

**FS_IOCTL_FLUSH_WBUF**
刷新wbuf

**FS_IOCTL_SAVE_FAT_TABLE**
seek加速处理

**FS_IOCTL_INSERT_FILE**
插入文件

**FS_IOCTL_DIVISION_FILE**
分割文件

**FS_IOCTL_STORE_CLUST_RANG**
存储CLUST_RANG 信息

**Functions**

struct imount * **mount**(const char *dev_name, const char *path, const char *fs_type, int cache_num, void *dev_arg)
挂载设备虚拟文件系统

**Parameters:**
dev_name – [in] 设备名称

path – [in] 挂载点路径

fs_type – [in] 文件系统类型(支持"fat" "devfs" "ramfs" "sdfile")

cache_num – [in] 文件系统缓存

dev_arg – [in] 设备参数指针

**Returns:**	指向挂载点结构体的指针

**Returns:**	NULL 挂载失败

int **unmount**(const char *path)
卸载设备虚拟文件系统

**Parameters:**
path – [in] 挂载点路径

**Returns:**	0: 卸载成功

**Returns:**	other: 卸载失败

int **f_format**(const char *path, const char *fs_type, u32 clust_size)
格式化驱动器

**Parameters:**
path – [in] 需要格式化的根目录

fs_type – [in] 文件系统类型

clust_size – [in] 簇大小,簇为0时默认为卡本身簇大小

**Returns:**	0: 格式化成功

**Returns:**	other: 格式化失败

FILE * **fopen**(const char *path, const char *mode)
打开文件, 获取指向文件流的文件指针

**Parameters:**
path – [in] 文件路径

mode – [in] 打开模式

**Note**

fopen自动打开、创建文件夹和文件，打开模式只支持"r" "w" "w+"，如需要追加写请使用"w"，文件名长度超过8个字节的需要用长文件名打开

**Returns:**	指向文件流的文件指针

**Returns:**	NULL: 打开失败

int **fread**(void *buf, u32 size, u32 count, FILE *file)
从文件中读取数据

**Parameters:**
buf – [out] 保存读取到的数据

size – [in] 每次读取字节数

count – [in] 总共读取次数

file – [in] 指向文件流的文件指针

**Returns:**	成功读取到的数据的字节长度

int **fwrite**(void *buf, u32 size, u32 count, FILE *file)
写入数据到文件中

**Parameters:**
buf – [in] 需要写入的数据

size – [in] 每次写入字节数

count – [in] 总共写入次数

file – [in] 指向文件流的文件指针

**Returns:**	成功写入的数据的字节长度

int **fseek**(FILE *file, int offset, int orig)
设置文件指针的位置

**Parameters:**
file – [in] 指向文件流的文件指针

offset – [in] 偏移量

orig – [in] 偏移的基准位置

**Returns:**	成功返回0

int **fseek_fast**(FILE *file, int offset, int orig)
快速设置文件指针的位置

**Note**

一般手表case使用,去除互斥,设置ram里面跑

**Parameters:**
file – [in] 指向文件流的文件指针

offset – [in] 偏移量

orig – [in] 偏移的基准位置

**Returns:**	成功返回0

int **fread_fast**(void *buf, u32 size, u32 count, FILE *file)
从文件中快速读取数据

**Note**

一般手表case使用,去除互斥,设置ram里面跑

**Parameters:**
buf – [out] 保存读取到的数据

size – [in] 每次读取字节数

count – [in] 总共读取次数

file – [in] 指向文件流的文件指针

**Returns:**	成功读取到的数据的字节长度

int **flen**(FILE *file)
获取文件的大小

**Parameters:**
file – [in] 指向文件流的文件指针

**Returns:**	文件大小(负值表示获取失败)

int **ftell**(FILE *file)
获取文件指针的当前位置

**Parameters:**
file – [in] 指向文件流的文件指针

**Returns:**	文件指针的位置

int **fget_name**(FILE *file, u8 *name, int len)
获取文件名(不包含目录)

**Parameters:**
file – [in] 指向文件流的文件指针
name – [out] 保存文件名的buffer,获取长文件名时buffer大小要大于长文件名长度，否则会获取到文件的短文件名"LFN~xxx",打印长文件名用put_buf方式
len – [in] buffer的长度，大于15个字节获取的是长文件名，小于16个字节获取的是短文件名

**Returns:**	文件名的长度(大于0)

int **frename**(FILE *file, const char *fname)
重命名文件

**Note**

操作完毕后需要调用fclose关闭文件句柄

**Parameters:**
file – [in] 指向文件流的文件指针

fname – [in] 文件的新文件名，不需要加目录路径

**Returns:**	0: 成功

**Returns:**	other: 失败

int **fclose**(FILE *file)
关闭文件流

**Parameters:**
file – [in] 指向文件流的文件指针

**Returns:**	0: 关闭成功

int **fdelete**(FILE *file)
删除文件,操作成功后会自动关闭文件

**Parameters:**
file – [in] 指向文件流的文件指针

**Returns:**	0: 删除成功

**Returns:**	other: 失败

int **fdelete_by_name**(const char *fname)
根据文件路径删除文件

**Parameters:**
fname – [in] 文件路径

**Returns:**	0: 删除成功

**Returns:**	other: 失败

int **fdelete_dir**(const char *path)
删除文件夹

**Parameters:**
path – [in] 文件夹路径，最后不需要加'/'

**Returns:**	0: 删除成功

**Returns:**	other: 失败

long long **flen_dir**(const char *path)
获取目录下文件总大小

**Parameters:**
path – [in] 文件夹路径，最后不需要加'/'

**Returns:**	目录下文件总大小(用s64类型接收返回值，使用lld打印数值)

**Returns:**	负值获取失败

int **fget_free_space**(const char *path, u32 *space)
获取剩余空间

**Parameters:**
path – [in] 设备路径

space – [out] 保存剩余空间的大小

**Returns:**	0: 获取成功

**Returns:**	other: 获取失败

int **fget_physical_total_space**(const char *path, u32 *space)
获取存储设备的物理总空间(注意是物理大小，并不是分区的逻辑空间大小)

**Parameters:**
path – [in] 根目录

space – [out] 保存总空间的大小

**Returns:**	0: 获取成功

**Returns:**	other: 获取失败

int **fget_path**(FILE *file, struct vfscan *fscan, u8 *name, int len, u8 is_relative_path)
获取当前文件相对路径和绝对路径

**Parameters:**
file – [in] 指向文件流的文件指针

fscan – [in] 文件扫描结构体句柄

name – [out] 保存文件路径的buffer

len – [in] buffer的长度

is_relative_path – [in] 是否要获取相对路径

**Returns:**	文件名的长度(大于0)

struct vfscan * **fscan**(const char *path, const char *arg, u8 max_deepth)
文件扫描

**Note**

arg扫描参数

1. -t 文件类型
2. -r 包含子目录
3. -d 扫描文件夹
4. -a 文件属性 r: 读， /: 非
5. -s 排序方式， t:按时间排序， n:按文件号排序

**Parameters:**
path – [in] 扫描路径

arg – [in] 扫描参数设置

max_deepth – [in] 扫描目录层数，最大为9

**Returns:**	虚拟文件扫描结构体句柄

**Returns:**	NULL: 扫描失败

struct vfscan * **fscan_interrupt**(const char *path, const char *arg, u8 max_deepth, int (*callback)(void))
可打断的文件扫描

**Note**

arg扫描参数

1. -t 文件类型
2. -r 包含子目录
3. -d 扫描文件夹
4. -a 文件属性 r: 读， /: 非
5. -s 排序方式， t:按时间排序， n:按文件号排序

**Parameters:**
path – [in] 扫描路径

arg – [in] 扫描参数设置

max_deepth – [in] 扫描目录层数，最大为9

callback – [in] 每扫描完一个目录后回调一次

**Returns:**	虚拟文件扫描结构体句柄

**Returns:**	NULL: 扫描失败

struct vfscan * **fscan_enterdir**(struct vfscan *fs, const char *path)
文件扫描(进入指定子目录，只扫此目录下文件信息)

**Parameters:**
fs – [in] 文件扫描结构体句柄

path – [in] 指定目录的相对路径

**Returns:**	虚拟文件扫描结构体句柄

**Returns:**	NULL: 扫描失败

struct vfscan * **fscan_exitdir**(struct vfscan *fs)
返回上一层的文件扫描目录

**Parameters:**
fs – [in] 文件扫描结构体句柄

**Returns:**	虚拟文件扫描结构体句柄

**Returns:**	NULL: 扫描失败

void **fscan_release**(struct vfscan *fs)
释放文件扫描结构体句柄

**Parameters:**
fs – [in] 文件扫描结构体句柄

FILE * **fselect**(struct vfscan *fs, int selt_mode, int arg)
选择文件

**Parameters:**
fs – [in] 文件扫描结构体句柄

selt_mode – [in] 选择模式(支持按簇号、序号、路径选择)

arg – [in] 选择参数,默认0

**Returns:**	指向文件流的文件指针

**Returns:**	NULL: 选择操作失败

int **fdir_exist**(const char *dir)
检查挂载点是否存在

**Parameters:**
dir – [in] 挂载点路径

**Returns:**	1: 存在

**Returns:**	0: 不存在

int **fget_attr**(FILE *file, int *attr)
获取文件的文件属性

**Parameters:**
file – [in] 指向文件流的文件指针

attr – [out] 保存操作成功后文件的文件属性信息

**Returns:**	0: 获取成功

**Returns:**	other: 获取失败

int **fset_attr**(FILE *file, int attr)
设置文件的文件属性

**Parameters:**
file – [in] 指向文件流的文件指针

attr – [in] 文件属性码

**Returns:**	0: 设置成功

**Returns:**	other: 设置失败

int **fget_attrs**(FILE *file, struct vfs_attr *attr)
获取文件的详细信息如属性、簇号、大小等

**Parameters:**
file – [in] 指向文件流的文件指针

attr – [out] 保存操作成功后文件的详细信息

**Returns:**	0: 获取成功

**Returns:**	other: 获取失败

struct vfs_partition * **fget_partition**(const char *path)
获取路径对应的分区

**Parameters:**
path – [in] 分区路径

**Returns:**	指向分区结构体的指针

**Returns:**	NULL: 获取失败

int **fset_vol**(const char *path, const char *name)
设置路径对应的卷标的名称

**Parameters:**
path – [in] 卷标路径

name – [in] 卷标名称

**Returns:**	0: 设置成功

**Returns:**	other: 设置失败

int **fmove**(FILE *file, const char *path_dst, FILE *newFile, int clr_attr, int path_len)
移动文件

**Parameters:**
file – [in] 指向文件流的文件指针

path_dst – [in] 目标路径，注意如果不需要更改原文件名，路径不需要填写文件名，如/aa/即可，根目录前面不能加分区路径

newFile – [out] 保存操作成功后文件在新路径的文件流指针

clr_attr – [in] 是否清除原有文件的文件属性

path_len – [in] 目标路径长度

**Returns:**	0: 移动成功(自动关闭旧文件流)

**Returns:**	other: 移动失败

int **fcheck**(FILE *file)
检查文件

**Parameters:**
file – [in] 指向文件流的文件指针

**Returns:**	文件错误码

int **fget_err_code**(const char *path)
获取文件系统的错误代码

**Parameters:**
path – [in] 文件路径

**Returns:**	文件错误码

int **fname_to_path**(char *result, const char *path, const char *fname, int len, u8 is_dir, u8 is_lfn)
拼接文件名(目录+文件名) (特别用于中文名文件的路径拼接)

**Parameters:**
result – [out] 保存操作成功后的文件路径的字符串

path – [in] 目录路径

fname – [in] 文件名

len – [in] fname的长度

is_dir – [in] 拼接的是否为文件夹

is_lfn – [in] 拼接的是否为长文件名

**Returns:**	文件名的长度(大于0)

int **fget_folder**(struct vfscan *fs, struct ffolder *arg)
获取文件夹信息，获取文件夹序号和文件夹内文件数目

**Parameters:**
fs – [in] vfscan 结构句柄

arg – [out] 文件夹信息结构句柄

**Returns:**	0成功， 非0错误。

int **fset_lfn_buf**(struct vfscan *fs, void *arg)
设置长文件名Buf (现已不常用)

**Parameters:**
fs – [in] vfscan 句柄

arg – [in] buf

**Returns:**	0成功， 非0错误。

int **fset_ldn_buf**(struct vfscan *fs, void *arg)
设置长文件夹名Buf (现已不常用)

**Parameters:**
fs – [in] vfscan 句柄

arg – [in] buf

**Returns:**	0成功， 非0错误。

int **fset_ext_type**(const char  *path, void *ext_type)
设置后缀名过滤（现已不常用）

**Parameters:**
path – [in] 根路径

ext_type – [in] 后缀名

**Returns:**	0成功， 非0错误。

int **fopen_dir_info**(const char *path, FILE *pp_file, void *dir_dj)
文件浏览使用，打开目录

**Parameters:**
path – [in] 路径

pp_file – [out] 文件句柄

dir_dj – [out] 目录信息句柄

**Returns:**	无意义

int **fenter_dir_info**(FILE *file, void *dir_dj)
文件浏览使用，进入目录

**Parameters:**
file – [in] 文件句柄

dir_dj – [in/out] 目录信息句柄

**Returns:**	目录项总数

int **fexit_dir_info**(FILE *file)
文件浏览使用，退出目录

**Parameters:**
file – [in] 文件句柄

**Returns:**	目录项总数

int **fget_dir_info**(FILE *file, u32 start_num, u32 total_num, void *buf_info)
文件浏览使用，获取目录信息

**Parameters:**
file – [in] 文件句柄

start_num – [in] 起始位置

total_num – [in] 获取目录个数

buf_info – [out] 目录信息句柄

**Returns:**	获取的目录数

int **fstore_clust_rang**(FILE *file)
存储文件簇信息

**Note**

一般手表case使用, 用于fget_fat_outflash_addr()之前调用，节省fget_fat_outflash_addr()时间

**Parameters:**
file – [in] 文件句柄

**Returns:**	0成功， 非0错误。

int **fget_fat_outflash_addr**(FILE *file, char  *name, void  *buf_info, int buf_len)
获取外置flash实际物理地址

**Note**

一般手表case使用

**Parameters:**
file – [in] 文件句柄

name – [in] sdfile格式文件名

buf_info – [out] 存储相关信息结构buf指针

buf_len – [in] buf 长度

**Returns:**	0表示buf不够 大于 0 表示存储多少个信息结构，其他 错误

int **fget_file_byname_indir**(FILE *file, FILE *newFile, void *ext_name)
文件浏览使用，由歌曲名称获取歌词

**Parameters:**
file – [in] 歌曲文件句柄

newFile – [out] 歌词文件句柄

ext_name – [in] 后缀名称

**Returns:**	0成功， 非0错误。

int **fget_disp_info**(FILE *file, void *arg)
获取长文件名和长文件夹名信息（现在不常使用）

**Note**

需要先设置长文件名或者长文件夹名buf进去

**Parameters:**
file – [in] 歌曲文件句柄

arg – [out] 长文件相关信息结构指针

**Returns:**	0成功， 非0错误。

int **fmk_dir**(const char *path, char *folder, u8 mode)
创建目录

**Parameters:**
path – [in] 路径

folder – [in] 文件夹名称,需要 /, 例如 /test

mode – [in] 目录属性（1 设置为隐藏属性， 0 不设置 ）

**Returns:**	0成功，非0不成功

int **fget_encfolder_info**(const char *path, char *folder, char *ext, u32 *last_num, u32 *total_num)
获取录音文件信息(现在不常用)

**Parameters:**
path – [in] 路径

folder – [in] 文件夹名称

ext – [in] 文件名后缀

last_num – [out] 可变数字最大数字

total_num – [out] 文件总数

**Returns:**	0成功，非0不成功

const char * **fname_after_root**(const char *path)
截取path中根目录之后的文件名

**Parameters:**
path – [in] 路径

**Returns:**	文件名

const char * **fget_fs_type**(const char *path)
获取文件系统类型

**Parameters:**
path – [in] 路径

**Returns:**	文件系统类型

int **fget_name_type**(char *path, int len)
判断文件路径是否带有unicode编码

**Parameters:**
path – [in] 路径

len – [in] 路径长度

**Returns:**	是否带unicode

int **get_last_num**(void)
录音获取最后序号

**Returns:**	最后序号

void **set_bp_info**(u32 clust, u32 fsize, u32 *flag)
设置断点参数

**Note**

1.接口调用在扫描前 2.使用完需要put_bp_info对应释放buf

**Parameters:**
clust – [in] 记录的簇号

fsize – [in] 记录的文件大小

flag – [in/out] 文件是否存在标志

void **put_bp_info**(void)
释放内存

void **ff_set_FileInDir_enable**(u8 enable)
优化扫盘速度，优化文件打开速度，如果不需要切换文件夹的操作，可置0关闭

**Note**

1.目的是是否去除获取文件夹内所有文件功能，默认enable 是1 获取数目，置0不获取，所以不需要切换文件夹操作的功能，可置0 关闭 2.在扫描前调用接口

**Parameters:**
enable – [in] 开关

void **ff_set_DirBaseInfo**(void *buf, u16 n)
设置目录项基点信息（用于加速）

**Note**

1.加速序号选择文件，明显效果体现在上一曲加速 2.注意buf使用

**Parameters:**
buf – [in] 存储基点buf (长度 10 * n)

n – [in] 基点数目

void **fat_set_datetime_info**(u16 year, u8 month, u8 day, u8 hour, u8 minute, u8 second)
设置文件的创建时间

**Parameters:**
year – [in] 年

month – [in] 月

day – [in] 日

hour – [in] 小时

minute – [in] 分钟

second – [in] 秒

void **hidden_file**(u8 flag)
隐藏属性文件是否过滤

**Parameters:**
flag – [in] 置1 为过滤

void **fat_save_already_size_enable**(char enable)
是否保存预申请长度

**Parameters:**
enable – [in] 1保存，0 不保存

void **fat_set_pre_create_chain_num**(u16 num)
设置预申请簇数目

**Parameters:**
num – [in] 数目（1-0x1fe）

int **fsave_fat_table**(FILE *file, u16 btr, u8 *buf)
存储文件簇信息

**Note**

seek加速，4字节对齐

**Parameters:**
file – [in] 文件句柄

btr – [in] buf 长度

buf – [in] buf指针

**Returns:**	0成功，非0不成功

int **f_flush_wbuf**(const char *path)
刷新文件系统缓存buf

**Parameters:**
path – [in] 设备路径

**Returns:**	0成功，非0不成功

int **finsert_file**(FILE *file, FILE *i_file, u32 fptr)
插入文件，操作的两个文件指针都需要用只读r方式打开，而且文件大小需要对齐簇大小，否则会出现前后数据丢失的情况

**Note**

操作完毕后需要调用fclose关闭文件句柄

**Parameters:**
file – [in] 源文件

i_file – [in] 需要插入的文件

fptr – [in] 源文件被插入的位置

**Returns:**	0成功，非0不成功

int **fdicvision_file**(FILE *file, char *file_name, u32 fptr)
分割文件，操作的文件指针需要用只读r方式打开，而且文件大小需要对齐簇大小，否则会出现前后数据丢失的情况

**Note**

操作完毕后需要调用fclose关闭文件句柄

**Parameters:**
file – [in] 源文件

file_name – [in] 分割后第二个文件文件名

fptr – [in] 源文件被分割位置

**Returns:**	0成功，非0不成功

struct vfs_partition
*#include <fs.h>*

分区信息

**Public Members**

struct vfs_partition *next
下一个分区信息指针

u32 **offset**
分区起始偏移

u32 **clust_size**
簇大小

u32 **total_size**
总容量

u8 **fs_attr**
文件属性

u8 **fs_type**
文件系统类型

char **dir**[VFS_PART_DIR_MAX]
挂载点路径

void *private_data
私有指针

struct ffolder
*#include <fs.h>*

文件夹信息

**Public Members**

u16 **fileStart**
文件夹起始序号

u16 **fileTotal**
文件夹数目

struct imount
*#include <fs.h>*

挂载点信息

**Public Members**

int **fd**
私有设备指针

const char *path
挂载点路径

const struct vfs_operations *ops
文件系统操作函数句柄

struct vfs_devinfo **dev**
设备信息

struct vfs_partition **part**
分区信息

struct list_head **entry**
链表节点

atomic_t **ref**
引用计数器

OS_MUTEX **mutex**
互斥量

u8 **avaliable**
是否合法

u8 **part_num**
分区数量

struct vfs_attr
*#include <fs.h>*

文件属性

Public Members

u8 **attr**
文件属性标志位

u32 **fsize**
文件大小

u32 **sclust**
最小分配单元

struct sys_time **crt_time**
文件创建时间

struct sys_time **wrt_time**
文件最后修改时间

struct sys_time **acc_time**
文件最后访问时间

struct FILE
*#include <fs.h>*

文件流

Public Members

struct imount *mt
挂载点指针

struct vfs_devinfo *dev
设备信息

struct vfs_partition *part
分区信息

void *private_data
私有指针

struct vfscan
*#include <fs.h>*

文件扫描信息

Public Members

u8 **scan_file**
是否扫描文件

u8 **subpath**
子目录，设置是否只扫描一层

u8 **scan_dir**
是否扫描目录

u8 **attr**
文件属性

u8 **cycle_mode**
扫描的循环模式

char **sort**
扫描的文件排序 ‘t’ ‘n’

char **ftype**[20 * 3 + 1]
扫描的文件扩展类型

u16 **file_number**
扫描出来的文件总数

u16 **file_counter**
当前文件序号

u16 **dir_totalnumber**
文件夹总数

u16 **musicdir_counter**
播放文件所在文件夹序号

u16 **fileTotalInDir**
文件夹下的文件数目

void *priv
私有指针

struct vfs_devinfo *dev
设备信息

struct vfs_partition *part
分区信息

char **filt_dir**[12]
设置文件夹过滤

char **fasten_num**[8]

char *fasten_buf

char *d_save

# 7.11. LBUF

**Overview**

提供LBUF应用示例、常用相关 API 介绍和常见问题。

## 7.11.1. 应用示例

**示例演示：**

* lbuf使用方法

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_LBUF_TEST_DEMO` 。

**Note**

lbuf 具有如下特点：

> * 1.以链表的方式对读取和写入的数据进行管理；
> * 2.数据先进先出；
> * 3.在多次读写之后可能会产生碎片；

![](img\187.png)

![](img\188.png)

## 7.11.2. 常见问题

* lbuf通过用于什么场合?
  答:适合用于以数据以包/帧为单位读写的应用场合

## 7.11.3. API Reference

**Functions**

struct lbuff_head *lbuf_init(void *buf, u32 len, int align, int priv_head_len)
链表buf初始化

**Parameters:**
buf – [in] 需要lbuf进行管理的内存
len – [in] 内存长度
align – [in] 输入对管理的内存进行对齐的参数,避免后续使用因地址不对齐产生碎片
priv_head_len – [in] 要管理的一个数据包结构体的最小的长度

**Returns:**
lbuf操作句柄

void *lbuf_alloc(struct lbuff_head *head, u32 len)
分配内存空间进行存储数据包

**Parameters:**
head – [in] lbuf操作句柄
len – [in] 需要存入的数据包的长度

**Returns:**
成功则返回进行存储数据包的地址,调用时候需要用户把该块内存的类型初始化为数据包结构体的类型。失败则返回NULL。

void *lbuf_realloc(void *lbuf, int size)
重新分配lbuf_alloc()返回用于存储数据包的lbuf空间

**Parameters:**
lbuf – [in] lbuf_alloc()返回用于存储数据包的地址
size – [in] 需重新分配的空间的字节长度.注:size的大小只能比lbuf_alloc()中的len小,即只能重新分配更小的lbuf空间,不能扩大空间.

**Returns:**
重新分配后用于存储数据包的地址。失败则返回空指针。注:重新分配最好使用lbuf_real_size()获取lbuf空间的长度确认是否分配成功

int lbuf_empty(struct lbuff_head *head)
判断lbuf空间内的内容是否为空

**Parameters:**
head – [in] lbuf操作句柄

**Returns:**
返回1则为空,0则不为空

void lbuf_clear(struct lbuff_head *head)
清空lbuf空间内进行已经分配给数据包的空间

**Parameters:**
head – [in] lbuf操作句柄

void lbuf_push(void *lbuf, u8 channel_map)
把数据包写入分配好的lbuf区域

**Parameters:**
lbuf – [in] lbuf_alloc()返回用于存储数据包的地址
channel_map – [in] 选择映射到哪个通道,最多8个通道,使用位映射的方式进行通道对应.

void *lbuf_pop(struct lbuff_head *head, u8 channel)
读取对应的通道映射的lbuf区域存储的内容

**Parameters:**
head – [in] lbuf操作句柄
channel – [in] 需要读取的通道值,一般使用BIT(n),n为需要读取的通道

**Returns:**
成功则返回存储对应的通道映射的数据包的地址

int lbuf_free(void *lbuf)
释放存储数据包的lbuf空间

**Parameters:**
lbuf – [in] lbuf_alloc()返回用于存储数据包的地址

**Returns:**
0则释放失败，存在地址越界操作或者通道还没有被读完，ref-1,读完后才能完全释放。1则释放成功。

void lbuf_free_check(void *lbuf, u32 rets)
用于调试,检查是否可以释放存储数据包的lbuf空间

**Parameters:**
lbuf – [in] lbuf_alloc()返回用于存储数据包的地址
rets – [in] 调用lbuf_free_check()函数的返回地址rets,取值可参考lbuf_free()

u32 lbuf_free_space(struct lbuff_head *head)
返回可分配的用来存储数据包的最大lbuf内存空间

**Parameters:**
head – [in] lbuf操作句柄

**Returns:**
可分配的最大lbuf内存空间的字节长度

void lbuf_state(struct lbuff_head *head, struct lbuff_state *state)
获取lbuf空间的状态

**Parameters:**
head – [in] lbuf操作句柄
state – [out] lbuff_state结构体

void lbuf_dump(struct lbuff_head *head)
lbuf信息打印

**Parameters:**
head – [in] lbuf操作句柄

int lbuf_traversal(struct lbuff_head *head)
获取已经存入lbuf空间的数据包的数量

**Parameters:**
head – [in] lbuf操作句柄

**Returns:**
lbuf存储的数据包的数量

int lbuf_avaliable(struct lbuff_head *head, int size)
返回lbuf空间还可以被写入size大小数据包的数量

**Parameters:**
head – [in] lbuf操作句柄
size – [in] 欲检测写入数据包的大小

**Returns:**
可以写入的数量

int lbuf_real_size(void *lbuf)
返回给数据包分配的内存空间的大小

**Parameters:**
lbuf – [in] lbuf_alloc()返回用于存储数据包的地址

**Returns:**
实际占用空间的字节长度

int lbuf_remain_space(struct lbuff_head *head)
计算lbuf空间剩下多少剩余空间

**Parameters:**
head – [in] lbuf操作句柄

**Returns:**
剩余空间的字节长度

void lbuf_inc_ref(void *lbuf)
需要被重复释放的次数+1

**Parameters:**
lbuf – [in] lbuf_alloc()返回用于存储数据包的地址

struct lbuff_head
*#include <lbuf.h>*

lbuf头部信息

**Public Members**
int magic_a
测试验证变量

struct list_head head
指向hentry链表

struct list_head free
指向hfree链表

spinlock_t lock
混合自旋锁,单核是为开关临界区,多核是自旋锁.

u8 align
数据包字节对齐

u16 priv_len
数据包结构体的最小长度

u32 total_size
总大小

u32 last_addr
指向free链表中找到的足够长度的hfree结构体地址

void *priv

int magic_b
测试验证变量

struct lbuff_state
*#include <lbuf.h>*

lbuf状态

**Public Members**
u32 avaliable
剩余空间的字节长度

u32 fragment
lbuf内存碎片块数量

u32 max_continue_len
最大的剩余内存块的字节长度

int num
剩余内存块数量

# 7.12. 循环BUF

**Overview**

提供循环BUF应用示例、常用相关 API 介绍和常见问题。

## 7.12.1. 应用示例

**示例演示：**

* 循环buf使用方法

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_CBUF_TEST_DEMO` 。

**Note**

cbuf 具有如下特点：* 1.buf 空间大小固定；

* 2.数据先进先出；
* 3.buf 开始和结束头尾相连的，在写到buf 结束会从buf 开始位置继续写入，形成环形结构；
* 4.数据可以多次写入一次读出或者一次写入多次读出；
* 5.无碎片产生问题；

![](img\189.png)

![](img\190.png)

## 7.12.2. 常见问题

* cbuf通过用于什么场合?
  答:适合用于流形式的数据包, 并且任务间数据流读写动态平衡的场合
* `circular_buf.h` 除了给出事例以外的接口如何使用?
  答:如果例子展示的接口不满足客户应用需求, 请联系杰理技术团体增加更完善的接口使用说明

## 7.12.3. API Reference

**Functions**

void cbuf_init(cbuffer_t *cbuffer, void *buf, u32 size)
适用范围:全局
cbuffer初始化

**Parameters:**
cbuffer – [in] cbuffer 句柄
buf – [in] 缓存空间
size – [in] 缓存总大小

u32 cbuf_read(cbuffer_t *cbuffer, void *buf, u32 len)
适用范围:cb_memcpy管理
把cbuffer_t结构体管理的内存空间的数据拷贝到buf数组

**Parameters:**
cbuffer – [in] cbuffer 句柄
buf – [out] 指向用于存储读取内容的目标数组
len – [in] 要读取的字节长度

**Returns:**
成功读取的字节长度

u32 cbuf_write(cbuffer_t *cbuffer, void *buf, u32 len)
适用范围:cb_memcpy管理
把buf数组数据拷贝cbuffer_t结构体管理的内存空间

**Parameters:**
cbuffer – [in] cbuffer 句柄
buf – [in] 指向用于存储写入内容的目标数组
len – [in] 要写入的字节长度

**Returns:**
成功写入的字节长度

u32 cbuf_is_write_able(cbuffer_t *cbuffer, u32 len)
适用范围:全局
判断是否可写入len字节长度的数据

**Parameters:**
cbuffer – [in] cbuffer 句柄
len – [in] len字节长度的数据

**Returns:**
返回可以写入的len字节长度

void *cbuf_write_alloc(cbuffer_t *cbuffer, u32 *len)
适用范围:外部内存管理
预分配待写入数据的空间，要和cbuf_write_updata()配套使用,更新cbuf管理handle数据。

**Parameters:**
cbuffer – [in] cbuffer句柄
len – [in] 回传可以最多写入len字节长度的数据

**Returns:**
当前写指针的地址

void cbuf_write_updata(cbuffer_t *cbuffer, u32 len)
适用范围:外部内存管理
更新cbuf管理handle的写指针位置和数据长度

**Parameters:**
cbuffer – [in] cbuffer句柄
len – [in] 在非cbuffer_t结构体包含的内存空间中写入的数据的实际字节长度

**Returns:**
当前写指针的地址

void *cbuf_read_alloc(cbuffer_t *cbuffer, u32 *len)
适用范围:外部内存管理
预分配待读取数据的空间,需要和cbuf_read_updata()配套使用,更新cbuf管理handle数据

**Parameters:**
cbuffer – [in] cbuffer 句柄
len – [in] 回传可以最多读取len字节长度的数据

**Returns:**
当前读指针的地址

void cbuf_read_updata(cbuffer_t *cbuffer, u32 len)
适用范围:外部内存管理
更新cbuf管理handle的读指针位置和数据长度

**Parameters:**
cbuffer – [in] cbuffer 句柄
len – [in] 在非cbuffer_t结构体包含的内存空间中读取的数据的实际字节长度

void cbuf_clear(cbuffer_t *cbuffer)
适用范围:外部内存管理
清空cbuffer空间

**Parameters:**
cbuffer – [in] cbuffer 句柄

u32 cbuf_rewrite(cbuffer_t *cbuffer, void *begin, void *buf, u32 len)
适用范围:cb_memcpy管理。
指定位置进行数据重写

**Parameters:**
cbuffer – [in] cbuffer 句柄
begin – [in] 指向需要重写内容的开始地址
buf – [out] 指向用于存储重写内容的目标数组
len – [in] 待重写内容的长度

**Returns:**
成功重写的字节长度

void cbuf_discard_prewrite(cbuffer_t *cbuffer)
适用范围:cb_memcpy管理
更新指向上一次操作的指针为当前指针,并刷新数据长度

**Parameters:**
cbuffer – [in] cbuffer 句柄

void cbuf_updata_prewrite(cbuffer_t *cbuffer)
适用范围:cb_memcpy管理
操作指针回退到上一次的操作位置,并刷新数据长度

**Parameters:**
cbuffer – [in] cbuffer 句柄

u32 cbuf_prewrite(cbuffer_t *cbuffer, void *buf, u32 len)
适用范围:cb_memcpy管理
回退写入内容，从上一次的操作的指针处进行覆盖填充

**Parameters:**
cbuffer – [in] cbuffer 句柄
buf – [out] 指向用于覆盖写入内容的目标数组
len – [in] 填充数据的字节长度

**Returns:**
成功填充数据的字节长度

void *cbuf_get_writeptr(cbuffer_t *cbuffer)
适用范围:全局
获取指向写指针的地址

**Parameters:**
cbuffer – [in] cbuffer 句柄

**Returns:**
写指针的地址

u32 cbuf_get_data_size(cbuffer_t *cbuffer)
适用范围:全局
获取cbuffer存储的数据的字节长度

**Parameters:**
cbuffer – [in] cbuffer句柄

**Returns:**
获取cbuffer存储的数据的字节长度

void *cbuf_get_readptr(cbuffer_t *cbuffer)
适用范围:全局
获取指向读指针的地址

**Parameters:**
cbuffer – [in] cbuffer句柄

**Returns:**
读指针的地址

u32 cbuf_read_goback(cbuffer_t *cbuffer, u32 len)
适用范围:全局
读指针向后回退

**Parameters:**
cbuffer – [in] cbuffer 句柄
len – [in] 要回退的字节长度

**Returns:**
成功回退的字节长度

u32 cbuf_get_data_len(cbuffer_t *cbuffer)
适用范围:全局
获取存储数据的字节长度

**Parameters:**
cbuffer – [in] cbuffer 句柄

**Returns:**
存储数据的字节长度

u32 cbuf_read_alloc_len(cbuffer_t *cbuffer, void *buf, u32 len)
适用范围:memcpy管理+cbuf_read_alloc系列管理函数
预分配待读取数据的空间,并把读取到的数据存入buf数组

**Parameters:**
cbuffer – [in] cbuffer 句柄
buf – [out] 存储读取的数据的目标buf数组
len – [in] 要读取的数据的字节长度

**Returns:**
（原文档未标注返回值）

void cbuf_read_alloc_len_updata(cbuffer_t *cbuffer, u32 len)
适用范围:memcpy管理+cbuf_read_alloc系列管理函数
更新cbuf管理handle的读指针位置和数据长度

**Parameters:**
cbuffer – [in] cbuffer 句柄
len – [in] 要更新的数据的字节长度

struct cbuffer_t
*#include <circular_buf.h>*
cbuffer头部信息

**Public Members**
u8 *begin
cbuffer内存开始地址指针

u8 *end
cbuffer内存结束地址指针

u8 *read_ptr
cbuffer当前读指针位置

u8 *write_ptr
cbuffer当前写指针位置

u8 *tmp_ptr
cbuffer当前暂存指针位置

u32 tmp_len
cbuffer当前暂存数据大小

u32 data_len
cbuffer当前可读数据大小

u32 total_len
cbuffer内存总大小

spinlock_t lock
cbuffer硬件锁

# 7.13. INTERRUPT

**Overview**

提供系统中断应用示例、常用相关 API 介绍和常见问题。

## 7.13.1. 应用示例

**示例演示：**

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_INTERRUPT_TEST_DEMO` 。

**Note**

* 1.通常安装中断使用request_irq,优先级为1-7, 越大优先级越高,cpu_id为安装到哪一个核去响应中断
* 2.SDK库内部已经安装好中断, 如果用户需要修改中断的优先级和安装核, 可以在app_main.c的irq_info_table强行修改对应的中断号,例如：
  > ```
  > /*中断列表 */
  > const struct irq_info irq_info_table[] = {
  >   { IRQ_TIMER4_IDX,      2,   1    }, //此中断强制配置为优先级为2,并且安装到cpu1
  > ```
  >
* 3.当用户想统一某些中断注册到核1,某些中断注册到核0,可以在app_main.c的irq_info_table配置,例如：
  ```
  const struct irq_info irq_info_table[] = {
    { IRQ_SOFT5_IDX,      7,   0    }, //此中断强制注册到cpu0
    { IRQ_SOFT4_IDX,      7,   1    }, //此中断强制注册到cpu1
    { -2,                       -2,   -2   },//如果加入了该行, 那么只有该行之前的中断注册到对应核, 其他所有中断强制注册到CPU0
  ```

## 7.13.2. 常见问题

## 7.13.3. API Reference

**IRQ select**
IRQ_SDTAP_IDX
IRQ_EXCEPTION_IDX
IRQ_SYSCALL_IDX
IRQ_TICK_TMR_IDX
IRQ_TIMER0_IDX
IRQ_TIMER1_IDX
IRQ_TIMER2_IDX
IRQ_TIMER3_IDX
IRQ_USB_SOF_IDX
IRQ_USB_CTRL_IDX
IRQ_RTC_WDT_IDX
IRQ_ALNK_IDX
IRQ_ALNK1_IDX
IRQ_AUDIO_IDX
IRQ_PORT_IDX
IRQ_SPI0_IDX
IRQ_SPI1_IDX
IRQ_SD0_IDX
IRQ_SD1_IDX
IRQ_UART0_IDX
IRQ_UART1_IDX
IRQ_UART2_IDX
IRQ_PAP_IDX
IRQ_IIC_IDX
IRQ_SARADC_IDX
IRQ_SPI3_IDX
IRQ_GPC_IDX
IRQ_EMI_IDX
IRQ_OSA_IDX
IRQ_BLE_RX_IDX
IRQ_NFC_IDX
IRQ_AES_IDX
IRQ_RDEC_IDX
IRQ_MCTMRX_IDX
IRQ_CHX_PWM_IDX
IRQ_SPDETX
IRQ_CTM_IDX
IRQ_SPI2_IDX
IRQ_PLNK_IDX
IRQ_PLNK1_IDX
IRQ_BREDR_IDX
IRQ_BT_CLKN_IDX
IRQ_BT_DBG_IDX
IRQ_WL_LOFC_IDX
IRQ_LRCT_IDX
IRQ_BLE_EVENT_IDX
IRQ_SBC_IDX
IRQ_SS_IDX
IRQ_DMA_COPY_IDX
IRQ_PMU_PND0_IDX
IRQ_PMU_PND1_IDX
IRQ_LDMA_IDX
IRQ_WF_IDX
IRQ_USB1_SOF_IDX
IRQ_USB1_CTRL_IDX
IRQ_JPG_IDX
IRQ_SHA_IDX
IRQ_FFT_IDX
IRQ_SRC_IDX
IRQ_ISC0_IDX
IRQ_EQ_IDX
IRQ_WF_RSVD_IDX
IRQ_TIMER4_IDX
IRQ_TIMER5_IDX
IRQ_ISC1_IDX
IRQ_IMD_IDX
IRQ_SOFT0_IDX
IRQ_SOFT1_IDX
IRQ_SOFT2_IDX
IRQ_SOFT3_IDX
IRQ_SOFT4_IDX
IRQ_SOFT5_IDX
IRQ_SOFT6_IDX
IRQ_SOFT7_IDX

ISR_ENTRY

**Functions**
void request_irq(unsigned char index, unsigned char priority, void (*handler)(void), unsigned char cpu_id)
request_irq, 中断注册

**Parameters:**
index – : 使用的中断号，例如IRQ_TIMER0_IDX 等
priority – : 中断优先级0~7，越大优先级越高
handler – : 中断函数
cpu_id – : 中断注册到的cpu, 0是注册到cpu0,1是注册到cpu1，cpuid为0xff时注册到当前CPU。

void unrequest_irq(u8 index, u8 cpu_id)
unrequest_irq, 解除中断注册

**Parameters:**
index – : 使用的中断号，例如IRQ_TIMER0_IDX 等
cpu_id – : 中断注册到的cpu, 0是注册到cpu0,1是注册到cpu1

# 7.14. MALLOC

**Overview**

本章节主要提供 1、查询内存信息的方法；2、内存泄露检测手段；3、踩内存检测手段。

**示例演示：**

* 1. 查询内存信息的方法
* 2. 内存泄露检测手段
* 3. 踩内存检测手段

## 7.14.1. 查询内存信息的方法

**- 基础概念：**

内存信息包括内存池大小、内存使用量、剩余内存大小、最大空闲内存、内存水线、内存节点数统计、碎片率等。

> 内存水线：即内存池的最大使用量，每次申请和释放时，都会更新水线值，实际业务可根据该值，优化内存池大小；
>
> 碎片率：衡量内存池的碎片化程度，碎片率高表现为内存池剩余内存很多，但是最大空闲内存块很小，可以用公式（fragment=100-100.0*最大空闲内存块大小/剩余内存大小）来度量；

**- 配置**

1. 进入 `demo_config.h` ，开启宏 `USE_MALLOC_TEST_DEMO` 。
2. 进入 `app_config.h` 增加 `#define RTOS_STACK_CHECK_ENABLE` ，打印周期默认为60秒，测试建议设置为3秒;
3. 使用mem_heap库来定位不断打印定位整个SDK申请内存的情况，以便计算碎片率，此方法使用mem_heap内存管理才有效，工程增加apps/common/system/mem_heap.c后重新编译下载即可

**- 示例演示**

1. malloc_stats(); //打印一下当前内存使用情况
2. malloc_dump()； //打印堆内存的使用情况和碎片率

其中，total：总共内存堆可使用的大小；left：当前剩余可使用的大小；max：水线值；fragment：内存碎片率

![](img\191.png)

![](img\192.png)

## 7.14.2. 内存泄露检测手段

**- 基础概念**

内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

有两种方法查找内存泄漏，  **推荐使用第二种方法** 。

**- 方法 1：定位一个功能模块内部有没有内存泄漏**

* 1.需要在 `app_config.h` 增加 `#define MEM_LEAK_CHECK_ENABLE`
* 2.如果需要启动内存泄漏侦测, 必须所有需要侦测的.c和.h文件都要包含头文件 `#include "system/mem_leak_test.h"` 。
* 3.例如打印: MALLOC LEAK DBG:malloc_test_task 20 rets:0x1c10660,size:0x1000 代表发现malloc_test_task函数的第20行,rets地址为0x1c10660,申请大小为0x1000,rets可以通过工具 `cpu/wl80/tools/定位异常地址.bat` 查看

**- 方法 2：需要使用mem_heap库来定位不断打印定位整个SDK申请内存的情况来分析，下面将详细介绍如何使用该方法进行内存泄露侦测。**

1. 进入 `demo_config.h` ，开启宏 `USE_MALLOC_TEST_DEMO` 。
2. 请参考 **1、 查询内存信息的方法** 中的 **配置** 3和4。

**- 示例演示（针对方法 2进行示例演示）**

1. 在 `app_main.c.app_main()` 中添加如下代码，模拟内存泄露场景。

```
printf("my leak mem = 0x%x -------\r\n\r\n\r\n",malloc(5*1024*1024));
malloc_stats();
u32 leak_test = 1;
while(leak_test){
    leak_test += malloc(64);
}
```

2. 通过串口打印工具，查看测试结果

![](img\193.png)

发现在地址0x2005002处，频繁申请大小为58字节的内存（注：之所以是58字节而不是64字节，是因为系统在进行内存管理时，会插入一定长度头部字段），通过 `cpu/wl82/tools/定位异常地址.bat` 定位该异常的地址，为 `app_main.c.app_main()` 。

![](img\194.png)

## 7.14.3. 踩内存检测手段

**- 基础概念**

踩内存，即访问了不合法的地址。踩内存检测机制可用于检测动态内存池的完整性，及时发现是否发生踩内存问题。

**- 配置**

1. 进入 `demo_config.h` ，开启宏 `USE_MALLOC_TEST_DEMO` 。
2. 工程增加apps/common/system/mem_heap.c后重新编译下载。

**- 示例演示**

1. 在 `app_main.c.app_main()` 中添加如下代码，通过memset构造越界访问，踩到下节点的4个字节

```
int *q = (int*)malloc(1*sizeof(int));
int *k = q -1;
memset(k, 0,8);
mem_heap_check(__func__,__LINE__);  //使用mem_heap_check()进行踩内存检测
free(q);
```

2. 通过串口打印工具，查看测试结果

![](img\195.png)

再通过 `cpu/wl82/tools/定位异常地址.bat` 输入rets_addrs定位异常地址，即在 `app_main.c.app_main()` 中发生了踩内存。

![](img\196.png)

### 7.14.3.1. 常见问题

* 内存使用导致死机的情况有哪些?
  答： 用户需要排查有没有错误使用内存申请的情况,例如：

  > * 1.读写操作的地址范围超出内存申请指针包含的范围
  > * 2.内存指针释放了还继续使用
  > * 3.多次释放同一个内存申请的指针
  >
* 感觉到内存被篡改但是没有马上造成异常的情况应该如何定位?
  答: 需要使用mem_heap.c来定位, 需要在流程上存在篡改可能性的地方加入mem_heap_check函数来分析
* 有时候发现内存堆空间足够,但是内存申请失败的原因是什么?
  答: 由于内存碎片导致没有一块连续的并且足够大内存可以申请导致的, 用户使用内存申请注意不要申请过于小size的内存,另外常驻内存不要使用malloc,直接使用静态变量,malloc多个变量的情况考虑优化成一次性malloc一个结构体使用
* 打印出来中文乱码?
  答: 更换打印软件，有可能是该打印软件的转码格式不支持。

## 7.14.4. API Reference

**Functions**
void ***malloc**(size_t size)
void ***zalloc**(size_t size)
void ***calloc**(size_t count, size_t size)
void ***realloc**(void *rmem, size_t newsize)
void **free**(void *mem)
void ***kmalloc**(size_t size, int flags)
void ***vmalloc**(size_t size)
void **vfree**(void *addr)
void ***kzalloc**(unsigned int len, int a)
void **kfree**(void *p)
void **malloc_stats**(void)
void **malloc_dump**(void)
void **ram_free**(void *rmem)
void ***ram_malloc**(unsigned long size)
void ***ram_realloc**(void *rmem, unsigned long newsize)
void **mem_heap_check**(const char *const func, unsigned int line)
void **memory_init**(void)
void **mem_stats**(void)
size_t **xPortGetFreeHeapSize**(void)
size_t **xPortGetMinimumEverFreeHeapSize**(void)
size_t **xPortGetPhysiceMemorySize**(void)
void ***get_physic_address**(u32 page)
void ***vmem_get_phy_adr**(void *vaddr)

# 7.15. MOVABLE

**Overview**

提供动态加载指定代码到sram或者sdram运行的例子。

## 7.15.1. 应用实例

**示例演示：**

example: 具体示例代码详见 `apps/common/movable/example.c` ， 示例工程实现必须在 `apps/demo/demo_audio/include/app_config.h` 中定义宏 `CONFIG_NO_SDRAM_ENABLE` 和 `CONFIG_DYNAMIC_SDRAM_ONOFF_ENABLE`

```
//1、首先需要动态加载的代码需要以代码段的定义存在，具体方法可参考“库符号重定位到指定段方法”文档

//2、在apps/common/movable/movable_text.ld文件里模仿添加，注意参加的序号不要重复
    *(.movable.stub.4)
    __xxx_movable_region_start = .;
    *(.movable.region.4);
    __xxx_movable_region_end = .;

//3、在apps/common/movable/movable_data.ld文件里模仿添加，注意参加的序号不要重复
    . = ALIGN(4);
    __xxx_movable_slot_start = .;
    *(.movable.slot.4);
    __xxx_movable_slot_end = .;

//4、在apps/common/movable/section.c文件里模仿添加，注意参加的序号不要重复
4:
.xxx.text

static u32 *start_of_region = NULL;

extern u32 __xxx_movable_slot_start[];
extern u32 __xxx_movable_slot_end[];
extern u8 __xxx_movable_region_start[];
extern u8 __xxx_movable_region_end[];

static void enter_xxx_movable_region(u32 **start_of_region, u8 *code_load_addr)
{
    u32 code_size = __xxx_movable_region_end - __xxx_movable_region_start;
    code_movable_load(__xxx_movable_region_start, code_size, code_load_addr, __xxx_movable_slot_start, __xxx_movable_slot_end, start_of_region);
}

static void exit_xxx_movable_region(u32 **start_of_region, u8 *code_load_addr)
{
    code_movable_unload(__xxx_movable_region_start, __xxx_movable_slot_start, __xxx_movable_slot_end, start_of_region);

```

# 7.16. MATH

**Overview**

提供FFT接口使用示例和常见问题。

## 7.16.1. 应用示例

**示例演示：**

* FFT和IFFT的使用

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_MATH_TEST_DEMO` 。

**Note**

**说明：**

> * 1.需增加依赖文件

| 代码文件                           | 头文件                                 | 用途                                                                                                  |
| ---------------------------------- | -------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| flfft_core_pi32v2.c                | /                                      | 浮点fft和ifft运算                                                                                     |
| jl_fft.c                           | /                                      | 硬件fft接口                                                                                           |
| kiss_fft.c                         | kiss_fft.h                             | 软件fft接口, jl_fft.c文件开启#define KISS_FFT宏使用软件加速                                           |
| jl_math.c                          | /                                      | 实现向量加减乘除, ASM_ENABLE == 1, 软件加速; ASM_ENABLE == 2, 汇编方式优化; ASM_ENABLE == 3, 硬件加速 |
| nn_function_vec.c                  | /                                      | 实现个位宽向量加减乘除, 如果数据放SDRAM性能会差, 不建议使用                                           |
| driver/cpu/wl82/math/math.c(cpu.a) | include_lib/driver/cpu/wl82/asm/math.h | 三角函数相关                                                                                          |

## 7.16.2. 常见问题

## 7.16.3. API Reference

**nn_function_vec.c**

**Note**

* 加减法不支持 32 位和差溢出保护，需保证输入数据加减结果不大于 2147483647 或小于-2147483648。
* 实数乘加减，乘法部分运算完后会做饱和处理（最大 32 位）。
* 复数平方64位输出不做移位操作（/2^q），其余位宽均有做移位操作。
* 输出数据需满足 32bit 倍数，即 8bit 位宽至少 4 个，16bit 位宽至少 2 个，32bit 位宽至少 1 个。
* 各个vector函数的作用与参数说明：注意: 某些函数需要打开特定宏才能使用, 如调用函数发现未定义, 检查特定宏是否打开.

```
/* --------------------------------------------------------------------------*/
/**
* @brief 两个二维实数数组的点乘累加
* @z[n] = sum(y[n] * x[n] / 2^q)  // 0 <= n < len
*
* @param [out] zptr    输出为32bit数据,可以是xptr或yptr
* @param [in] yptr     输入为8bit数据
* @param [in] xptr     输入为8bit数据
* @param [in] len      为单次运算长度(二维数组data[m *n] 对应的宽(m)
* @param [in] loop     循环次数, 对应高(n)
* @param [in] x_inc    每次循环的xptr地址增量, 由于xptr是8bit数据,所以增量为对应len,可根据实际情况修改
* @param [in] y_inc    每次循环的yptr地址增量, 由于yptr是8bit数据,所以增量为对应len,可根据实际情况修改
* @param [in] z_inc    每次循环的zptr地址增量, 由于xptr是32bit数据,且每次循环只得一个数据,所以增量为4,可根据实际情况修改
* @param [in] q        zptr结果输出前除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_matrix_ys8_xs8(long *zptr, long *yptr, long *xptr, short len, short loop, short x_inc, short y_inc, short z_inc, char q);


/* --------------------------------------------------------------------------*/
/**
* @brief 两个二维实数数组的点乘累加
* @z[n] = sum(y[n] * x[n] / 2^q)  // 0 <= n < len
*
* @param [out] zptr    输出为32bit数据,可以是xptr或yptr
* @param [in] yptr     输入为32bit数据
* @param [in] xptr     输入为16bit数据
* @param [in] len      为单次运算长度(二维数组data[m *n] 对应的宽(m)
* @param [in] loop     循环次数, 对应高(n)
* @param [in] x_inc    每次循环的xptr地址增量, 由于xptr是16bit数据,所以增量为对应len*2,可根据实际情况修改
* @param [in] y_inc    每次循环的yptr地址增量, 由于yptr是32bit数据,所以增量为对应len*4,可根据实际情况修改
* @param [in] z_inc    每次循环的zptr地址增量, 由于xptr是32bit数据,且每次循环只得一个数据,所以增量为4,可根据实际情况修改
* @param [in] q        zptr结果输出前除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_matrix_ys32_xs16(long *zptr, long *yptr, long *xptr, short len, short loop, short x_inc, short y_inc, short z_inc, char q);



/* --------------------------------------------------------------------------*/
/**
* @brief 两个二维实数数组的点乘累加
* @z[n] = sum(y[n] * x[n] / 2^q)  // 0 <= n < len
*
* @param [out] zptr    输出为32bit数据,可以是xptr或yptr
* @param [in] yptr     输入为32bit数据
* @param [in] xptr     输入为8bit数据
* @param [in] len      为单次运算长度(二维数组data[m *n] 对应的宽(m)
* @param [in] loop     循环次数, 对应高(n)
* @param [in] x_inc    每次循环的xptr地址增量, 由于xptr是8bit数据,所以增量为对应len,可根据实际情况修改
* @param [in] y_inc    每次循环的yptr地址增量, 由于yptr是32bit数据,所以增量为对应len*4,可根据实际情况修改
* @param [in] z_inc    每次循环的zptr地址增量, 由于xptr是32bit数据,且每次循环只得一个数据,所以增量为4,可根据实际情况修改
* @param [in] q        zptr结果输出前除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_matrix_ys32_xs8(long *zptr, long *yptr, long *xptr, short len, short loop, short x_inc, short y_inc, short z_inc, char q);


/* --------------------------------------------------------------------------*/
/**
* @brief 两个一维实数数组的相加
* @z[n] = saturated( y[n] + x[n] )  // 0 <= n < len
*
* @param [out] zptr    输出为32bit数据,可以是xptr或yptr
* @param [in] yptr     输入为32bit数据
* @param [in] xptr     输入为32bit数据
* @param [in] len      输入数据长度
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_ys32_add_xs32(void *zptr, void *yptr, void *xptr, short len);




/* --------------------------------------------------------------------------*/
/**
* @brief 两个一维实数数组的相加
* @z[n] = saturated( y[n] + x[n] )  // 0 <= n < len
*
* @param [out] zptr    输出为32bit数据,可以是xptr或yptr
* @param [in] yptr     输入为32bit数据
* @param [in] xptr     输入为16bit数据
* @param [in] len      输入数据长度
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_ys32_add_xs16(void *zptr, void *yptr, void *xptr, short len);




/* --------------------------------------------------------------------------*/
/**
* @brief 两个一维实数数组的相减
* @z[n] = saturated( y[n] - x[n] )  // 0 <= n < len
*
* @param [out] zptr    输出为32bit数据,可以是xptr或yptr
* @param [in] yptr     输入为32bit数据
* @param [in] xptr     输入为32bit数据
* @param [in] len      输入数据个数
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_ys32_sub_xs32(void *zptr, void *yptr, void *xptr, short len);



/* --------------------------------------------------------------------------*/
/**
* @brief 一维实数数组乘一个常数
* @z[n] = (x[n] * const_dat/ 2^q)  // 0 <= n < len
*
* @param [out] zptr        输出为32bit数据,可以是xptr
* @param [in] xptr         输入为32bit数据
* @param [in] len          输入数据长度
* @param [in] q            zptr结果输出前除于2^q
* @param [in] const_dat    输入常数
*/
/* --------------------------------------------------------------------------*/
void vector_real_scale_s32(void *zptr, void *xptr, short len, char q, long const_dat);





/* --------------------------------------------------------------------------*/
/**
* @brief 两个一维实数数组的相乘
* @z[n] = saturated(y[n] * x[n] / 2^q)  // 0 <= n < len
*
* @param [out] zptr        输出为32bit数据,可以是xptr或yptr
* @param [in] yptr         输入为32bit数据
* @param [in] xptr         输入为32bit数据
* @param [in] len          输入数据长度
* @param [in] q            xptr除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_ys32_mul_xs32(void *zptr, void *yptr, void *xptr, short len, char q);





/* --------------------------------------------------------------------------*/
/**
* @brief 两个一维实数数组的相乘
* @z[n] = saturated(y[n] * x[n] / 2^q)  // 0 <= n < len
*
* @param [out] zptr        输出为32bit数据,可以是xptr或yptr
* @param [in] yptr         输入为16bit数据
* @param [in] xptr         输入为16bit数据
* @param [in] len          输入数据长度
* @param [in] q            xptr除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_ys16_mul_xs16(void *zptr, void *yptr, void *xptr, short len, char q);



/* --------------------------------------------------------------------------*/
/**
* @brief 两个一维实数数组的相乘
* @z[n] = saturated(y[n] * x[n] / 2^q)  // 0 <= n < len
*
* @param [out] zptr        输出为32bit数据,可以是xptr或yptr
* @param [in] yptr         输入为32bit数据
* @param [in] xptr         输入为16bit数据
* @param [in] len          输入数据长度
* @param [in] q            xptr除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_ys32_mul_xs16(void *zptr, void *yptr, void *xptr, short len, char q);




/* --------------------------------------------------------------------------*/
/**
* @brief 两个一维实数数组的相乘
* @z[n] = saturated(y[n] * x[n] / 2^q)  // 0 <= n < len
*
* @param [out] zptr        输出为32bit数据,可以是xptr或yptr
* @param [in] yptr         输入为32bit数据
* @param [in] xptr         输入为8bit数据
* @param [in] len          输入数据长度
* @param [in] q            xptr除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_ys32_mul_xs8(void *zptr, void *yptr, void *xptr, short len, char q);



/* --------------------------------------------------------------------------*/
/**
* @brief 两个一维实数数组的相乘
* @z[n] = saturated(y[n] * x[n] / 2^q)  // 0 <= n < len
*
* @param [out] zptr        输出为32bit数据,可以是xptr或yptr
* @param [in] yptr         输入为8bit数据
* @param [in] xptr         输入为8bit数据
* @param [in] len          输入数据长度
* @param [in] q            xptr除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_ys8_mul_xs8(void *zptr, void *yptr, void *xptr, short len, char q);






/* --------------------------------------------------------------------------*/
/**
* @brief 一维实数数组的相加除2^q
* @z[n] = sum(x[n]) / 2^q  // 0 <= n < len
*
* @param [out] zptr        输出为32bit数据,可以是xptr
* @param [in] xptr         输入为32bit数据
* @param [in] len          输入数据长度
* @param [in] q            结果除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_sum_xs32(void *zptr, void *xptr, short len, char q);




/* --------------------------------------------------------------------------*/
/**
* @brief 一维实数数组的乘常数除2^q
* @z[n] = (x[n] * const_dat/ 2^q)  // 0 <= n < len
*
* @param [out] zptr        输出为8bit数据,可以是xptr
* @param [in] xptr         输入为32bit数据
* @param [in] len          输入数据长度
* @param [in] q            结果除于2^q
* @param [in] const_dat    输入常数
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs8_x32_mul_const(void *zptr, void *xptr, short len, char q, long const_dat);



/* --------------------------------------------------------------------------*/
/**
* @brief 一维实数数组的乘常数除2^q
* @z[n] = (x[n] * const_dat/ 2^q)  // 0 <= n < len
*
* @param [out] zptr        输出为32bit数据,可以是xptr
* @param [in] xptr         输入为32bit数据
* @param [in] len          输入数据长度
* @param [in] q            结果除于2^q
* @param [in] const_dat    输入常数
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_x32_mul_const(void *zptr, void *xptr, short len, char q, long const_dat);
}




/* --------------------------------------------------------------------------*/
/**
* @brief 两个一维实数数组的相乘
* @z[n] = x[n] + z[n] * const_dat / 2^q  // 0 <= n < len
*
* @param [in/out] zptr     输入输出为32bit数据
* @param [in] xptr         输入为32bit数据
* @param [in] len          输入数据长度
* @param [in] q            xptr除于2^q
* @param [in] const_dat    输入常数
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_ys32_mac_xs32(void *zptr, void *xptr, short len, char q, long const_dat);




/* --------------------------------------------------------------------------*/
/**
* @brief 两个一维实数数组的相乘后相加,输出一个数
* @z[n] = sum(y[n] * x[n] / 2^q)  // 0 <= n < len
*
* @param [out] zptr        输出为32bit数据
* @param [in] yptr         输入为8bit数据
* @param [in] xptr         输入为8bit数据
* @param [in] len          输入数据长度
* @param [in] q            xptr除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_ys8_dot_product_xs8(void *zptr, void *yptr, void *xptr, short len, char q);




/* --------------------------------------------------------------------------*/
/**
* @brief 两个一维复数数组的相加
* @z[n] = saturated( y[n] + x[n] )  // 0 <= n < len
*
* @param [out] zptr    输出为32bit数据,可以是xptr或yptr
* @param [in] yptr     输入为32bit数据
* @param [in] xptr     输入为32bit数据
* @param [in] len      输入数据长度(复数的个数)
*/
/* --------------------------------------------------------------------------*/
void vector_complex_zs32_ys32_add_xs32(void *zptr, void *yptr, void *xptr, short len);


/* --------------------------------------------------------------------------*/
/**
* @brief 两个一维复数数组的相减
* @z[n] = saturated( y[n] - x[n] )  // 0 <= n < len
*
* @param [out] zptr    输出为32bit数据,可以是xptr或yptr
* @param [in] yptr     输入为32bit数据
* @param [in] xptr     输入为32bit数据
* @param [in] len      输入数据长度(复数的个数)
*/
/* --------------------------------------------------------------------------*/
void vector_complex_zs32_ys32_sub_xs32(void *zptr, void *yptr, void *xptr, short len);


/* --------------------------------------------------------------------------*/
/**
* @brief 两个一维复数数组的点乘
* @z[n] = saturated(y[n]. * x[n]. / 2^q)  // 0 <= n < len
*
* @param [out] zptr    输出为32bit数据,可以是xptr或yptr
* @param [in] yptr     输入为8bit数据
* @param [in] xptr     输入为8bit数据
* @param [in] len      输入数据长度(复数的个数)
* @param [in] q        输出结果除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_complex_zs32_ys8_mul_xs8(void *zptr, void *yptr, void *xptr, short len, char q);


/* --------------------------------------------------------------------------*/
/**
* @brief 两个一维复数数组的点乘除于2^q
* @z[n] = saturated(y[n]. * x[n]. / 2^q)  // 0 <= n < len
*
* @param [out] zptr    输出为32bit数据,可以是xptr或yptr
* @param [in] yptr     输入为32bit数据
* @param [in] xptr     输入为32bit数据
* @param [in] len      输入数据长度(复数的个数)
* @param [in] q        输出结果除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_complex_zs32_ys32_mul_xs32(void *zptr, void *yptr, void *xptr, short len, char q);


/* --------------------------------------------------------------------------*/
/**
* @brief xptr一维复数数组先共轭除2^q后与yptr一位复数数组的点乘
* @z[n] = saturated(y[n]. * x[n]. / 2^q)  // 0 <= n < len
*
* @param [out] zptr    输出为32bit数据,可以是xptr或yptr
* @param [in] yptr     输入为32bit数据
* @param [in] xptr     输入为32bit数据
* @param [in] len      输入数据长度(复数的个数)
* @param [in] q        xptr除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_complex_zs32_ys32_mul_conj_xs32(void *zptr, void *yptr, void *xptr, short len, char q);


/* --------------------------------------------------------------------------*/
/**
* @brief xptr一维复数数组先共轭除2^q后与yptr一位复数数组的点乘
* @z[n] = saturated(y[n]. * x[n]. / 2^q)  // 0 <= n < len
*
* @param [out] zptr    输出为64bit数据,可以是xptr或yptr
* @param [in] yptr     输入为32bit数据
* @param [in] xptr     输入为32bit数据
* @param [in] len      输入数据长度(复数的个数)
* @param [in] q        xptr除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_complex_zs64_ys32_mul_conj_xs32(void *zptr, void *yptr, void *xptr, short len, char q);





/* --------------------------------------------------------------------------*/
/**
* @brief xptr一维复数数组实部虚部分别平方相加
* @z[n] = saturated((x[n].real^2 + x[n].imag^2) / 2^q)  // 0 <= n < len/2
*
* @param [out] zptr    输出为64bit数据,可以是xptr
* @param [in] xptr     输入为32bit数据
* @param [in] len      输入数据长度(复数的个数)
* @param [in] q        xptr除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_complex_zs64_qdt_xs32(void *zptr, void *xptr, short len, char q);


/* --------------------------------------------------------------------------*/
/**
* @brief xptr一维复数数组实部虚部分别平方相加
* @z[n] = saturated((x[n].real^2 + x[n].imag^2) / 2^q)  // 0 <= n < len/2
*
* @param [out] zptr    输出为32bit数据,可以是xptr
* @param [in] xptr     输入为32bit数据
* @param [in] len      输入数据长度(复数的个数)
* @param [in] q        xptr除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_complex_zs32_qdt_xs32(void *zptr, void *xptr, short len, char q);


/* --------------------------------------------------------------------------*/
/**
* @brief xptr一维复数数组除2^q后与yptr一位复数数组的点乘,后加上zptr
* @z[n] = saturated(z. + (y[n]. * x[n]. / 2^q))  // 0 <= n < len*2
*
* @param [out] zptr    输出为32bit数据,可以是xptr或yptr
* @param [in] yptr     输入为32bit数据
* @param [in] xptr     输入为32bit数据
* @param [in] len      输入数据长度(复数的个数)
* @param [in] q        xptr除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_complex_zs32_ys32_mac_xs32(void *zptr, void *yptr, void *xptr, short len, char q);



/* --------------------------------------------------------------------------*/
/**
* @brief xptr一维复数数组先共轭除2^q后与yptr一位复数数组的点乘,后加上zptr
* @z[n] = saturated(z. + (y[n]. * x[n]. / 2^q))  // 0 <= n < len*2
*
* @param [out] zptr    输出为32bit数据,可以是xptr或yptr
* @param [in] yptr     输入为32bit数据
* @param [in] xptr     输入为32bit数据
* @param [in] len      输入数据长度(复数的个数)
* @param [in] q        xptr除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_complex_zs32_ys32_mac_conj_xs32(void *zptr, void *yptr, void *xptr, short len, char q);


/* --------------------------------------------------------------------------*/
/**
* @brief zptr 减去 xptr一维复数数组除2^q后与yptr一位复数数组的点乘
* @z[n] = saturated(z. - (y[n]. * x[n]. / 2^q))  // 0 <= n < len*2
*
* @param [out] zptr    输出为32bit数据,可以是xptr或yptr
* @param [in] yptr     输入为32bit数据
* @param [in] xptr     输入为32bit数据
* @param [in] len      输入数据长度(复数的个数)
* @param [in] q        xptr除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_complex_zs32_ys32_msc_xs32(void *zptr, void *yptr, void *xptr, short len, char q);


/* --------------------------------------------------------------------------*/
/**
* @brief xptr与常量比较取最大值后除2^q
* @z = x*cosnt /2^q
*
* @param [out] zptr    输出为32bit数据,可以是xptr
* @param [in] xptr     输入为32bit数据
* @param [in] len      输入数据长度
* @param [in] q        xptr除于2^q
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_x32_max_scale(long *zptr,  long *xptr, short len, char q, long const_dat);



/* --------------------------------------------------------------------------*/
/**
* @brief max_const与xptr中取最大值
* @x[n] =max( x[n], const)
*
* @param [in/out] xptr     输入输出为64bit数据
* @param [in] max_const    常数
* @param [in] len          输入数据长度
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs64_x64_max_scale(long  long *xptr,  long long max_const, long len);




/* --------------------------------------------------------------------------*/
/**
* @brief const_dat与xptr中取最小值
* @x[n] =min( x[n], const)
*
* @param [in/out] xptr     输入输出为32bit数据
* @param [in] min_const    常数
* @param [in] len          输入数据长度
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs32_x32_min_scale(long *zptr,  long *xptr, short len, char q, long const_dat);


/* --------------------------------------------------------------------------*/
/**
* @brief min_const与xptr中取最小值
* @x[n] =min( x[n], const)
*
* @param [in/out] xptr     输入输出为64bit数据
* @param [in] min_const    常数
* @param [in] len          输入数据长度
*/
/* --------------------------------------------------------------------------*/
void vector_real_zs64_x64_min_scale(long  long *xptr,  long long min_const, long len);





/* --------------------------------------------------------------------------*/
/**
* @brief 一维实数数组相减(zptr-xptr)乘lamda后除于2^q再加上xptr
* @z[n] =x[n] + ((z[n]- x[n])*lamda )/2^q
*
* @param [in/out]  zptr     输入输出为64bit数据
* @param [in]      xptr     输入为64bit数据
* @param [in] len          输入数据长度
* @param [in] q            常数
* @param [in] lamda        常数
*/
/* --------------------------------------------------------------------------*/
void vector_real_smooth_zs64_xs64(long long *zptr,  long long *xptr,  unsigned long len, char q, long lamda);



/* --------------------------------------------------------------------------*/
/**
* @brief 一维实数数组相减(zptr-xptr)乘lamda后除于2^q再加上xptr
* @z[n] =x[n] + ((z[n]- x[n])*lamda )/2^q
*
* @param [in/out]  zptr     输入输出为32bit数据
* @param [in]      xptr     输入为64bit数据
* @param [in] len          输入数据长度
* @param [in] q            常数
* @param [in] lamda        常数
*/
/* --------------------------------------------------------------------------*/
void vector_real_smooth_zs32_xs32(long *zptr,  long *xptr,  unsigned long len, char q, long lamda);



/* --------------------------------------------------------------------------*/
/**
* @brief 一维复数数组相减(zptr-xptr)乘lamda后除于2^q再加上xptr
* @z[n] =x[n] + ((z[n]- x[n])*lamda )/2^q
*
* @param [in/out]  zptr     输入输出为32bit数据
* @param [in]      xptr     输入为64bit数据
* @param [in] len          输入数据长度(复数长度)
* @param [in] q            常数
* @param [in] lamda        常数
*/
/* --------------------------------------------------------------------------*/
void vector_complex_smooth_zs32_xs32(long *zptr,  long *xptr,  unsigned long len, char q, long lamda);




//该函数暂时不能用
//=====================================
//  z[0] = (x[0]^2 + x[1]^2)^0.5
//  z[1] = (x[2]^2 + x[3]^2)^0.5
//...
//  z[n] = (x[2*n]^2 + x[2*n+1]^2)^0.5
// result effective precision : 22bit
//=====================================
void complex_abs_s32(unsigned long *zptr, long *xptr, unsigned long len);
```

# 7.17. MEMORY

**Overview**

提供芯片内存使用示例和常见问题。

## 7.17.1. 应用示例

**示例演示：**

* 定义变量/函数到 flash/sdram/内部ram

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_MEMORY_TEST_DEMO` 。

## 7.17.2. 常见问题

* 如何查看芯片内存使用情况?
  答:系统开机以后会打印 芯片内存使用情况如下所示:

  >> ```
  >> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  >> setup_arch Jul 12 2021 10:07:49
  >> sys_clk = 320000000,sdram_clk = 240000000,hsb_clk = 160000000,lsb_clk = 53333333, sfc_clk = 80000000
  >> CODE+CONST SIZE = 1622496
  >> SDRAM_SIZE = 2097152, DATA_SIZE = 45444,BSS_SIZE = 454944,REMAIN_SIZE = 1596764
  >> RAM_SIZE = 523728,DATA_SIZE = 12624,BSS_SIZE = 499120,REMAIN_SIZE = 11984
  >> CACHE_RAM_SIZE = 0,DATA_SIZE = 0, BSS_SIZE = 0,REMAIN_SIZE = 0
  >> HEAP_SIZE = 1596704
  >> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  >> ```
  >>
  >
  > * CODE+CONST代表代码加const变量总大小
  > * SDRAM_SIZE 代表SDRAM容量大小
  > * RAM_SIZE 代表芯片内部RAM容量大小
  > * CACHE_RAM_SIZE 代表芯片内部一块小的,并且跟内部RAM不连续地址的额外可用大小
  > * DATA_SIZE 代表有初始化的变量大小
  > * BSS_SIZE 代表无初始化的变量大小
  > * REMAIN_SIZE 代表该区域剩余可用大小
  > * HEAP_SIZE 代表内存堆大小,通常是位于 SDRAM的 REMAIN_SIZE,如果没有SDRAM则位于内部RAM的REMAIN_SIZE
  >
* 任务栈在什么内存上?
  答:创建的任务如果是静态任务,栈位于全局变量所在内存; 如果是动态任务,栈位于堆内存
* 如何查看地址映射MAP文件
  答:MAP文件位于对应cpu的tools目录下, 如 `sdk.map`

**Warning**

如果定义函数到sdram/内部ram导致异常报错pc_limit_err，是由于程序代码跑到其他段系统误以为跑飞，这时候需要把debug_init的pc_rang_limit注释掉。

## 7.17.3. API Reference

# 7.18. UPDATE

**Overview**

杰理提供了多种固件升级的方法，包括：SD卡升级，U盘升级，HTTP OTA升级和FTP OTA升级等用户可以根据实际需求进行选择。

| 升级方式    | 单备份升级 | 双备份升级 | 预留区升级 |
| ----------- | ---------- | ---------- | ---------- |
| SD卡升级    | 支持       | 支持       | 支持       |
| U盘升级     | 支持       | 支持       | 支持       |
| HTTP升级    | 不支持     | 支持       | 支持       |
| FTP升级     | 不支持     | 支持       | 支持       |
| 虚拟U盘升级 | 不支持     | 支持       | 支持       |

## 7.18.1. DEMO

**工程demo**

`apps/demo/demo_DevKitBoard`

**示例**

* HTTP升级 ： `apps/common/example/update/http_upgrade/`, 测试时需要在 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_HTTP_UPDATE_DEMO1` 或 `USE_HTTP_UPDATE_DEMO2`。
* SD卡/U盘升级: `apps/common/example/update/sd_udisk_upgrade/main.c`， 测试时需要在 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_SD_UPGRADE_DEMO` 。
* FTP升级 : `apps/common/example/update/ftp_upgrade/main.c`， 测试时需要在 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_FTP_UPDATE_DEMO` 。
* 虚拟U盘升级：设备作为USB从机，并虚拟为一个假U盘，让电脑识别为U盘后，通过从电脑端拷贝升级文件到对应U盘中对设备进行升级。使用方法和配置如下：

> ```
> 使用方法
> 1、在app_config.h使用USB从机的读卡器功能和开启虚拟U盘升级相关配置。
> - #define TCFG_PC_ENABLE                1     //使能USB从机功能
> - #define TCFG_VIR_UDISK_ENABLE         1     //使能虚拟U盘功能
> - #define TCFG_VIR_UPDATE_ENABLE        1     //使能虚拟U盘升级功能
> - #define TCFG_USER_VIRTUAL_PLAY_ENABLE 0     //不使用虚拟 U 盘播放音频数据的功能时，可以关闭
>
> 2、在版籍board_xxx.c声明:extern const struct device_operations ram_disk_dev_ops;
> 3、在版籍board_xxx.c添加
> 在REGISTER_DEVICES(device_table) = {
>         //数组中添加
> {"vir_udisk",  &ram_disk_dev_ops, NULL},
>
> 4.烧录程序，将升级文件update-ota.ufw拷贝到虚拟U盘中对设备进行升级
>
> 注：wifi_story_machine 工程中已经加入了相关配置，如果其他工程需要此功能，按上述步骤进行添加
> ```

## 7.18.2. 双备份升级

**双备份分区结构**

![](img\197.png)

* RES : 为资源区，位于APP CODE区域中。(具体说明，请参考 资源区配置（RES和预留区） )
* CODE1和CODE2 ： 代码区域。
* VM : 系统配置项区域。
* RESERVED ： 预留区。(具体说明，请参考 资源区配置（RES和预留区） )

**升级流程**

双备份存储结构有两个app code区域，当运行app code 0时，升级时将新固件写入app code 1区域， 反之亦然升级时对app code N区域数据校验成功后，更新启动标志，复位后即可运行app code N代码， 当升级中断或者新写入固件校验不成功，不会影响原来app code 的运行。

![](img\198.png)

**双备份升级特点**

优点：

* 升级流程在app_code运行时执行，可以不影响正常功能使用，容易做到无感升级
* 升级意外中断仍有一份可运行代码，容灾体验好
* 无需update loader参与升级，客户可灵活在APP层自定义升级协议格式

缺点：

* 需要占用比固件大小接近多一倍flash空间
* 升级流程与app_code同步运行，升级可能受运行环境影响

适用场合：

* 对升级体验有要求的用户
* 方案的flash空间充裕
* 需要客制化升级协议格式

**双备份配置**

* 使用双备份架构时，需要在 `app_config.h` 中进行如下配置：

> ```
> #define  CONFIG_DOUBLE_BANK_ENABLE 1 //使能双备份功能
> ```

**升级文件生成方法**

* OTA升级
  编译工程后，在tools目录下双击运行 `生成升级固件.bat` 批处理，等待一定时间后会弹出第二个窗口，在第二个窗口中选择升级方式，在窗口中输入2，然后回车。然后在 `cpu\wl82\tools\upgrade` 目录中会生成用于网络升级的 `update-ota.ufw` 文件
* SD卡/U盘升级
  编译工程后，在tools目录下双击运行 `生成升级固件.bat` 批处理，等待一定时间后会弹出第二个窗口，在第二个窗口中选择升级方式，在窗口中输入1，然后回车。然后在 `cpu\wl82\tools\upgrade` 目录中会生成用于SD卡/U盘升级的 `update.ufw` 文件

Important

注意事项一：

用于OTA升级和SD卡/U盘升级必须使用对应的升级固件，否则会导致升级失败。同时需要注意的是，编译完工程后，需要点击对应的批处理文件来更新升级固件 ，否则有可能出现升级失败或升级的是旧的固件，可以通过固件的修改时间确认固件是否得到更新。

注意事项二：

`BR22_TWS_VERSION` 为固件版本号，即每次需要对设备进行升级时，需要将该值加1。初次烧录时该值为BR22_TWS_VERSION=0，需要对设备进行升级时，需要将该值加1，即此时 BR22_TWS_VERSION=1，然后编译生成升级固件对设备进行升级，以此类推，需要再次对设备升级的时，该值在原来的基础上进行递增1，因此多次升级后该值应该依次递增，0，1，2，3，…， 否则会遇到这样一个情况，设备进行OTA之后，再使用SM01-DFU.exe工具对设备烧录bin文件时，会出现设备运行的还是旧程序的情况，因为一些工具会利用到这个设置参数。 设置时请在对应 `cpu/(wl80或wl82)/tools/isd_config_rule.c` 文件下修改BR22_TWS_VERSION参数；

## 7.18.3. 单备份升级

**单备份分区结构**

![](img\199.png)

* RES : 为资源区，位于APP CODE区域中。(具体说明，请参考 资源区配置（RES和预留区） )
* CODE ： 代码区域。
* VM : 系统配置项区域。
* RESERVED ： 预留区。(具体说明，请参考 资源区配置（RES和预留区） )

**升级流程**

SDK加载otaloader程序到flash —>system reset—>uboot 检测升级状态，跳转到otaloader，运行otaloader程序，完成升级—> system reset—>uboot 检测升级状态，如果升级完成跳转到app，检测到之前没升级完成就继续跳转到otaloader进行升级；

**单备份升级特点**

优点：

* 存储固件的flash容量仅需要一份固件的容量，节省flash空间
* 单备份主要升级过程在update loader中实现，与sdk流程无关，相对稳定，单一线程升级速度相对较快

缺点：

* update loader已编译二进制方式提供，客制化难度大，暂时无法支持二次开发
* 单备份升级出现意外中断时，无法正常开机
* 需在loader中等待重新升级成功方能开机使用，影响用户体验

适用场合：

* flash空间紧张方案
* 成本敏感客户

**单备份配置**

* 在 `app_config.h` 中进行如下配置：

> ```
> #define  CONFIG_DOUBLE_BANK_ENABLE 0 //关闭双备份功能
> ```

**升级文件生成方法**

* OTA升级
  单备份架构不支持OTA升级
* SD卡/U盘升级
  编译工程后，在tools目录下双击运行 `生成升级固件.bat` 批处理，等待一定时间后会弹出第二个窗口，在第二个窗口中选择升级方式，在窗口中输入1，然后回车。然后在 `cpu\wl82\tools\upgrade` 目录中会生成用于SD卡/U盘升级的 `update.ufw` 文件

**ota loader工程说明**

单备份升级由loader来完成app code更新，地址为：fw-AC79_AIoT_SDK/tree/AC791N_OTA_loader/；使用说明：

（1）打开wl82_ota_loader.cbp工程

（2）如果需要打开调试打印，需要进行如下配置：

![](img\200.png)

* 修改”cpu/wl82/tools/isd_config_rule.c”文件，配置打印串口：UTTX=PXXX(根据自己的串口进行配置)
* 在wl82_ota_loader.cbp中也需要开启对应的配置，增加UART_DEBUG

  ![](img\201.png)

(3)修改”uboot\apps\post_build\wl82\download.bat”文件，更改配置为set PROJECT_TYPE=sd_update2

（4）rebuild工程，编译完成后会在”uboot\apps\post_build\wl82”目录下生成ota.bin和sd_update2.bin文件，替换SDK工程tools目录下的这两文件。

## 7.18.4. 预留区升级

**概述**

资源文件先升级到备份区，数据校验成功后，在将其搬运到预留区，在搬运过程中断电可以在备份区进行恢复。但是如果升级的资源文件大小大于备份区域时 就不能通过备份区进行升级。这里可以提供强刷预留区的方式进行升级，即不通过备份区，直接将资源升级到对应的预留区中。但是缺点是升级过程中断电， 预留区资源数据会导致损坏。SD卡升级和U盘升级默认打开预留区强刷升级功能，即当备份区空间不够时，直接进行预留区强刷升级。HTTP OTA升级和FTP OTA 升级可以通过配置是否打开预留区强刷升级功能。开启支持强刷升级功能时，需要修改对应工程中的配置文件 `lib_update_config.c`, 设置 `const int support_reserved_zone_forced_update = 1`。

Note

预留区升级适用于只需要更改预留区资源而无需升级整个固件的情况。需要注意的是使用预留区升级功能需要在 `[RESERVED_CONFIG]` 中配置预留区，在 `[RESERVED_EXPAND_CONFIG]` 中进行 配置的预留区时无法进行升级的。

**Note**

**SD卡/U盘升级配置**

> ```
> 步骤一：配置cpu/wl82/tools/isd_config_rule.c文件，在[RESERVED_CONFIG]区域下设置可用于资源升级的预留区（如何配置预留区请查阅参考文档）
> [RESERVED_CONFIG]
> UPDATE_FILE=fixed_res/UPDATE; //其中UPDATE为升级文件
> UPDATE_ADR=AUTO;
> UPDATE_LEN=0x4000;
> UPDATE_OPT=1;
>
> 步骤二：配置lib_update_config.c文件，使能预留区可升级功能。
> 设置const int support_reaserved_zone_file_dual_bank_update_en = 1;
> 设置const int support_passive_update_new_file_structure = 1;
>
> 步骤三：编译工程，烧写程序，此时在flash空间中会升级一个名为UPDATE的预留区
>
> 步骤四：当像升级UPDATE预留区时，如升级资源文件为UPDATE2，进行如下配置
> UPDATE_FILE=fixed_res/UPDATE2; //其中UPDATE为升级文件
> UPDATE_ADR=AUTO;
> UPDATE_LEN=0x4000;
> UPDATE_OPT=1;
>
> 步骤五：双击运行 ``升级文件.bat`` 批处理生成升级固件 update.ufw
>
> 注意：当下次升级不想对该预留区进行升级时，需要注释升级文件配置
> [RESERVED_CONFIG]
> #UPDATE_FILE=fixed_res/UPDATE; //其中UPDATE为升级文件
> UPDATE_ADR=AUTO;
> UPDATE_LEN=0x4000;
> UPDATE_OPT=1;
> ```

**HTTP/FTP升级配置**

> ```
> 步骤一：配置download.c文件，配置-update_files参数，如：
>         isd_download.exe isd_config.ini -tonorflash -dev wl82 -boot 0x1c02000 -div1 -wait 300 -uboot uboot.boot -app app.bin cfg_tool.bin -res %AUDIO_RES% %UI_RES% %CFG_FILE% -reboot 500 %KEY_FILE% -update_files normal
>         其中，参数定义为：
>         -update_files normal //生成只包含code升级文件
>         -update_files embedded_only $(files) //生成只包含资源升级文件，其中$(files)为需要添加的资源文件
>         -update_files embedded $(files) //生成包含code和资源的升级文件
>
> 步骤二：配置cpu/wl82/tools/isd_config_rule.c文件，在[RESERVED_CONFIG]区域下设置可用于资源升级的预留区
> UPDATE_ADR=AUTO;
> UPDATE_LEN=0x4000;
> UPDATE_OPT=1;
>
> 步骤三：配置lib_update_config.c文件，使能预留区可升级功能。
> 设置const int support_reaserved_zone_file_dual_bank_update_en = 1;
> 设置const int support_passive_update_new_file_structure = 1;
>
> 步骤四：编译工程
>
> 步骤五：双击运行 ``升级文件-OTA.bat`` 生成升级文件 ``update-ota.ufw``
> ```

**通过网络升级资源文件例子**

> ```
> 示例说明：
>         将test1.txt、test2.txt和test3.txt文件升级更新到UPDATE预留区，并读取test1.txt文件中的数据。
>
> （1）利用文件cpu/$(cpu)/tools/packres目录下打包工具packres.exe，将这三个文件打包为UPDATE文件，如：
>         packres.exe -n tone -o UPDATE test1.txt test2.txt test3.txt
>         其中，参数定义为：
>         -n，参数为需要把文件打包在那个文件目录下，目录名用于可以自定义。这里起名为tone目录名
>         -o，输出的打包文件，名字用户可以自定义。注意：需要升级的打包文件名字需要和预留区名字保持一致。
>
> （2）配置cpu/wl82/tools/isd_config_rule.c文件，在[RESERVED_CONFIG]区域下设置可用于资源升级的预留区
>         UPDATE_ADR=AUTO;
>         UPDATE_LEN=0x4000;//这里设置预留区大小为16k，需要注意的是用户要根据可能需要存储的最大资源上限进行设定，设定后升级的资源大小必须小于该值。
>         UPDATE_OPT=1;
>
> （3）设置好预留区后，需要烧写一次程序使得flash生成对应的预留区空间。
>
> （4）配置download.c文件，这里采用只升级资源，其配置为：
>         isd_download.exe isd_config.ini -tonorflash -dev wl82 -boot 0x1c02000 -div1 -wait 300 -uboot uboot.boot -app app.bin cfg_tool.bin -res %AUDIO_RES% %UI_RES% %CFG_FILE% -reboot 500 %KEY_FILE% -update_files embedded_only UPDATE
>
> （5）编译工程
>
> （6）双击运行“升级文件-OTA.bat” 批处理，生成升级文件 ``update-ota.ufw``
>
> （7）升级成功后，打开test1.txt文件读取其中的数据，示例代码如下：
> #include "system/includes.h"
> #include "app_config.h"
> #include "fs/fs.h"
> static void fs_test_task(void *priv)
> {
>         int rlen = 0;
>
>         FILE *f = fopen("mnt/sdfile/app/update/tone/test1.txt", "r");
>         if(!f)
>         {
>                 printf("fopen err \n");
>                 return;
>         }
>
>         rlen = flen(f);
>
>         u8 *r_buf = (u8 *)malloc(rlen);
>
>         int len = fread(r_buf, 1, rlen, f);
>         if (len != rlen) {
>                 fclose(f);
>                 return;
>         }
>
>         printf("fread data : %s\n", r_buf);
>         fclose(f);
>         free(r_buf);
> }
>
> static void c_main_t(void *priv)
> {
>         if (thread_fork("fs_test", 10, 512, 0, NULL, fs_test_task, NULL) != OS_NO_ERR) {
>         printf("thread fork fail\n");
>         }
> }
>
> late_initcall(c_main_t);
> ```

## 7.18.5. 常见问题

**(1) 预留区与res资源区有什么区别？**

答：预留区位于reserved区域，由用户自行配置，一旦生成其在flash中的位置和大小不能改变。 res资源区位于app code区，在flash空间允许的范围内，res资源区大小没有限制。在双备份升级中， res资源区也会进行双备份处理，因此res资源在flash中会占用两倍的空间。而预留区作为资源区时， 升级时资源文件大小不能超过对应预留区的空间大小。

**(2) 预留区备份升级与强刷升级有什么区别？**

答：预留区备份升级时，借用app code备份区作为临时区（前提是备份区空间必须大于资源文件大小）， 先将资源写入该区，等数据校验成功后，再将资源从备份区覆盖到预留区，这样当意外断电时，也可以从 备份区恢复到预留区。而强刷升级则是直接将资源覆盖到预留区，当意外断电时，原来的预留区资源会造 成损坏。因此当使能强刷功能时，建议用户把重要的资源放在res资源区，如：一些开机时使用到的资源。

**(3)资源升级预留区的大小如何选取？**

答：预留区设置后，其空间大小不能改变，因此用户一开始就必须评估好以后可能存放最大资源上限，超 出预留区空间的资源可以存放到res区域。

**(4) 在usb下载或OTA升级时需要擦除或保留对应reserved区域，该如何设置？**

答：需要修改 `cpu/wl82/tools/isd_config_rule.c`, 擦除对应区域时XX_OPT设置为0，不操作指定区域时XX_OPT设置为1。如：vm区默认配置VM_OPT=0,因此在 每次烧录程序或ota升级时都会清除掉改区域，需要保留原来的vm数据需要配置VM_OPT=1。

> ```
> [RESERVED_CONFIG]
> #升级之后需要保留VM数据，在生成升级文件时需要设置VM_OPT=1
> VM_ADR=0;
> VM_LEN=16K;
> VM_OPT=1;
> ```

**(5) 采用单备份升级时，显示“head crc err”和“not found ufw code file”这样的错误提示信息？**

答：主要原因是配置错误造成的，需要根据单备份升级配置进行正确配置。

**(6) 单备份和双备份可以交替使用吗？**

答：不行

**(7) 升级失败，如何确认具体原因？**

答：CONFIG_RELEASE_ENABLE定义后会屏蔽一些log信息，因此需要去掉后才能看到具体报错原因。操作如下图：

![](img\202.png)

**(8) 双击“生成升级固件.bat”没反应、没有生成“upgrade”文件夹？**

答：部分文件上传到Git，文件编码会被改成UINX，使用打包成压缩包的方式下载会导致运行异常。用 `Notepad++` 打开 `生成升级固件.bat` ，转换文档格式后保存即可。（详情查看 下载压缩包，编译不成功）

# 7.19. 资源区配置（RES和预留区）

**Overview**

资源区为用户存放资源文件的区域，其中分为两个区域：RES区域和预留区（RESERVED） (FLASH的区域分布请参考： UPDATE).

* RES区：res资源区为app code中的一部分，在flash空间允许的范围内，res资源区大小没有限制。在双备份升级中，res资源区也会进行双备份处理，因此res资源在flash中会占用两倍的空间。
* 预留区： 预留区为独立于app code的一个区域，是客户可以自行配置和使用的区域，即系统会根据客户的配置文件在flash中预留出对应的空间大小由客户自行操作。

## 7.19.1. RES资源区配置

* 添加res区资源目录：

> ```
> 修改脚本文件 ``download.c``，在“-res” 选项增加资源目录，如：添加资源目录audlogo
>
> isd_download.exe isd_config.ini -tonorflash -dev wl82 -boot 0x1c02000 -div1 -wait 300 -uboot uboot.boot
> -app app.bin cfg_tool.bin -res cfg audlogo source %AUDIO_RES% %UI_RES% %CFG_FILE%
> ```

* 添加资源文件

> ```
> 只需要在已添加的资源目录中加入资源文件,如audlogo目录中增加提示音
> ```

* 资源文件读取

> ```
> 可以通过文件系统接口fread对res区资源进行读取，其路径格式为：mnt/sdfile/res/$(user_dir)/$(filename);
> 其中user_dir为用户自定义资源目录，filename为用户添加的资
>
>     char name[128];
>     char read_buf[BUF_SIZE];
>     FILE *f = fopen("mnt/sdfile/res/audlogo/test.mp3", "r");
>     if (!f) {
>         printf("fopen err!\n")
>     }else{
>         fget_name(f, name, sizeof(name));
>         printf("file_name: %s\n", name);
>
>         int len = fread(read_buf, 1, sizeof(read_buf), f);
>         if(len > 0)
>         {
>             put_buf(read_buf, sizeof(read_buf));
>         }
>     }
> ```

## 7.19.2. 预留区配置

* 预留区配置

> ```
> 修改配置文件cpu/wl82/tools/isd_config_rule.c，[RESERVED_EXPAND_CONFIG]或[RESERVED_EXPAND_CONFIG]下添加配置项
>
> 注：具体配置说明请参考 doc/stuff/ISD_CONFIG.INI配置文件说明.pdf ，如：
>
>
> #预留区扩展
> [RESERVED_EXPAND_CONFIG]
> fixed.mp3_FILE=fixed_res/fixed.mp3;             #fixed_res目录下存放fixed.mp3文件
> fixed.mp3_ADR=AUTO;                                             #由工具自动分配起始地址
> fixed.mp3_LEN=0x4000;                                   #fixed.mp3文件的大小，需要4K对齐
> fixed.mp3_OPT=1;                                                #0:下载代码时擦除指定区域；1:下载代码时不操作指定区域；2:下载代码时给指定区域加上保护；
>
> 或
> #预留区扩展
> [RESERVED_CONFIG]
> fixed.mp3_FILE=fixed_res/fixed.mp3;             #fixed_res目录下存放fixed.mp3文件
> fixed.mp3_ADR=AUTO;                                             #由工具自动分配起始地址
> fixed.mp3_LEN=0x4000;                                   #fixed.mp3文件的大小，需要4K对齐
> fixed.mp3_OPT=1;                                                #0:下载代码时擦除指定区域；1:下载代码时不操作指定区域；2:下载代码时给指定区域加上保护；
> ```

* 预留区路径格式

> ```
> （1）[RESERVED_EXPAND_CONFIG]预留区使用方法可以通过文件系统接口fread对预留区数据进行读取，其路径格式为：mnt/sdfile/EXT_RESERVED/XXX（其中XXX为预留区文件名），如：
>     char name[128];
>     char read_buf[BUF_SIZE];
>     FILE *f = fopen("mnt/sdfile/EXT_RESERVED/fixed.mp3", "r");
>     if (!f) {
>         printf("fopen err!\n")
>     }else{
>         fget_name(f, name, sizeof(name));
>         printf("file_name: %s\n", name);
>             int len = fread(read_buf, 1, sizeof(read_buf), f);
>         if(len > 0)
>         {
>             put_buf(read_buf, sizeof(read_buf));
>         }
>     }
>
> （2）[RESERVED_CONFIG]预留区使用方法可以通过文件系统接口fread对预留区数据进行读取，其路径格式为：mnt/sdfile/app/XXX（其中XXX为预留区文件名），如：
>     char name[128];
>     char read_buf[BUF_SIZE];
>     FILE *f = fopen("mnt/sdfile/app/fixed.mp3", "r");
>     if (!f) {
>         printf("fopen err!\n")
>     }else{
>         fget_name(f, name, sizeof(name));
>         printf("file_name: %s\n", name);
>         int len = fread(read_buf, 1, sizeof(read_buf), f);
>         if(len > 0)
>         {
>             put_buf(read_buf, sizeof(read_buf));
>         }
>     }
> ```

* 预留区读写操作：可以通过fread来读取数据，但是不能使用fwrite接口来写入数据。一般采用Flash接口来对预留区进行操作，示例如下：

> ```
> #include "app_config.h"
> #include "system/includes.h"
> #include "fs/fs.h"
> #include "asm/sfc_norflash_api.h"
>
> #define USER_FLASH_SPACE_PATH "mnt/sdfile/app/exif"
>
> static u32 user_get_flash_exif_addr(void)
> {
>     u32 addr;
>
>     //打开预留区
>     FILE *profile_fp = fopen(USER_FLASH_SPACE_PATH, "r");
>     if (profile_fp == NULL) {
>         puts("user_get_flash_addr ERROR!!!\r\n");
>         return 0;
>     }
>
>     struct vfs_attr file_attr;
>     fget_attrs(profile_fp, &file_attr);
>
>     //获取预留区的flash地址
>     addr = sdfile_cpu_addr2flash_addr(file_attr.sclust);
>     fclose(profile_fp);
>
>     printf("user_get_flash_exif_addr = 0x%x, size = 0x%x \r\n", addr,file_attr.fsize);
>     return addr;
> }
>
> static int c_main(void)
> {
>     printf("\r\n\r\n\r\n\r\n\r\n ----------- USER_FLASH_EXIF example run %s-------------\r\n\r\n\r\n\r\n\r\n", __TIME__);
>
>     char buf[256];
>     u32 flash_exif_addr = user_get_flash_exif_addr();
>     if(flash_exif_addr==0)
>         return -1;
>
>     //擦除一个扇区
>     puts("USER_FLASH_EXIF ERASE_SECTOR...\r\n");
>     norflash_ioctl(NULL, IOCTL_ERASE_SECTOR, flash_exif_addr);
>
>     puts("USER_FLASH_EXIF READ\r\n");
>     memset(buf,0,sizeof(buf));
>
>     //读取预留区数据
>     norflash_read(NULL, buf, sizeof(buf), flash_exif_addr);
>     put_buf(buf,sizeof(buf));
>
>     puts("\r\n USER_FLASH_EXIF WRITE\r\n");
>     for(int i=0;i<sizeof(buf);i++)
>         buf[i] = i;
>
>     //写入数据
>     norflash_write(NULL, buf, sizeof(buf), flash_exif_addr);
>
>     puts("USER_FLASH_EXIF READ\r\n");
>     memset(buf,0,sizeof(buf));
>
>     //再次读出来，查看数据是否写入成功
>     norflash_read(NULL, buf, sizeof(buf), flash_exif_addr);
>     put_buf(buf,sizeof(buf));
>
>     return 0;
> }
> late_initcall(c_main);
> ```

## 7.19.3. 文件打包工具使用

打包工具位于 `cpu\wl82\tools\packres`, 打开packrec.bat文件， 按照说明添加需要打包的文件，如：

> ```
> REM packres.exe -n $(dir) -o $(output) $(file1) $(file2) ...
> REM 其中$(dir)为打包后的文件目录入口，$(output)打包后的输出文件，$(file1) $(file2) ...为需要打包的输入文件
> REM 放置在res资源区时，其搜索路径为mnt/sdfile/res/$(output)/$(dir)/$(file)，如：mnt/sdfile/res/tone/res1.txt
> REM 放置在[RESERVED_CONFIG]预留区时，其搜索路径为：mnt/sdfile/app/$(output)/$(dir)/$(file),如：mnt/sdfile/app/update/tone/res1.txt
> REM 放置在[RESERVED_EXPAND_CONFIG]预留区时，其搜索路径为：mnt/sdfile/EXT_RESERVED/$(output)/$(dir)/$(file),如：mnt/sdfile/EXT_RESERVED/update/tone/res1.txt
> packres.exe -n tone -o UPDATE res1.txt res2.txt res3.txt
> ::pause
> ```

## 7.19.4. 资源文件打包放在预留区或者扩展预留区

若资源区使用双备份升级时，会占用flash两倍的资源空间，为了节省双备份升级时的固件空间，现支持统一把提示音和UI资源统一放在预留区或者扩展预留区， 资源升级采用的是断点可恢复升级的单备份升级方法（若放在扩展预留区，需要在应用层上由客户手动强制升级，一般来说放在扩展预留区的资源是不升级的）。

* 资源打包放在预留区的配置

> ```
> //app_config.h配置对应的宏
> #if defined CONFIG_UI_ENABLE && !defined CONFIG_SDFILE_EXT_ENABLE
> #define CONFIG_UI_FILE_SAVE_IN_RESERVED_ZONE  //UI资源打包后放在预留区，可以通过升级预留区更新此资源，一般用于双备份时UI资源小于代码大小的方案
> #endif
> #if defined CONFIG_AUDIO_ENABLE && !defined CONFIG_SDFILE_EXT_ENABLE
> #define CONFIG_VOICE_PROMPT_FILE_SAVE_IN_RESERVED_ZONE  //提示音资源打包后放在预留区，可以通过升级预留区更新此资源，一般用于双备份时提示音资源小于代码大小的方案
> #endif
>
> //在代码编译前，需要根据实际打包后的资源文件空间大小填写tools/isd_config_rule.c里相应的flash空间区域配置
> [RESERVED_CONFIG]
> //#升级之后需要保留VM数据，在生成升级文件时需要设置VM_OPT=1
> VM_ADR=0; [设置VM]
> VM_LEN=32K;
> #if CONFIG_DOUBLE_BANK_ENABLE
> VM_OPT=0;
> #else
> VM_OPT=1;//单备份升级VM在升级时候默认VM不需要擦除,选择擦除会在ota_loader第二阶段擦除比较长，而且可能会造成VM丢失
> #endif
>
> BTIF_ADR=AUTO; [设置资源]
> BTIF_LEN=0x1000;
> BTIF_OPT=1;
>
> #if defined CONFIG_AUDIO_ENABLE && defined CONFIG_VOICE_PROMPT_FILE_SAVE_IN_RESERVED_ZONE
> AUPACKRES_FILE=packres/AUPACKRES; [打包后的资源文件的相对路径]
> AUPACKRES_ADR=0xXXXXXX; [请根据编译后FLASH INFO打印的实际地址填写，比如0x59a000，烧录后不支持升级更改]
> AUPACKRES_LEN=0xXXXXXX; [更新提示音资源打包后必须更新此实际长度，比如0x141000，建议根据后续资源升级的需求预留好足够的空间，烧录后不支持升级更改]
> AUPACKRES_OPT=1;
> #endif
>
> #if defined CONFIG_UI_ENABLE && defined CONFIG_UI_FILE_SAVE_IN_RESERVED_ZONE
> UIPACKRES_FILE=packres/UIPACKRES;
> UIPACKRES_ADR=0xXXXXXX; [请根据编译后FLASH INFO打印的实际地址填写，比如0x6db000，烧录后不支持升级更改]
> UIPACKRES_LEN=0xXXXXXX; [更新UI资源打包后必须更新此实际长度，比如0x123000， 建议根据后续资源升级的需求预留好足够的空间，烧录后不支持升级更改]
> UIPACKRES_OPT=1;
> #endif
>
> PRCT_ADR=0;
> PRCT_LEN=CODE_LEN;
> PRCT_OPT=2;
> ```

* 资源打包放在扩展预留区的配置

> ```
> //app_config.h配置对应的宏
> #if defined CONFIG_UI_ENABLE && !defined CONFIG_SDFILE_EXT_ENABLE
> #define CONFIG_UI_FILE_SAVE_IN_RESERVED_EXPAND_ZONE  //UI资源打包后放在扩展预留区，不可以通过常规升级更新此资源，一般用于UI不需要更新的方案
> #endif
> #if defined CONFIG_AUDIO_ENABLE && !defined CONFIG_SDFILE_EXT_ENABLE
> #define CONFIG_VOICE_PROMPT_FILE_SAVE_IN_RESERVED_EXPAND_ZONE  //提示音资源打包后放在扩展预留区，不可以通过常规升级更新此资源，一般用于提示音不需要更新的方案
> #endif
>
> //在代码编译前，需要根据实际打包后的资源文件空间大小填写tools/isd_config_rule.c里相应的flash空间区域配置
> [RESERVED_EXPAND_CONFIG]
> USER_ADR=AUTO; [固定预留给客户，避免客户量产后，想通过升级新增重要信息的保存却没有预先预留空间]
> USER_LEN=0x1000;
> USER_OPT=1;
>
> //packers文件夹下会生成AUPACKRES,UIPACKRES这两个包是资源文件打包好的包需要
> //根据实际大小填写AUPACKRES_ADR,AUPACKRES_LEN,
> //AUPACKRES_ADR 配置 AUTO 第一次下载后会下载不进 需要根据FLASH INFO打印的实际地址填写
> //例如AUPACKRES 378KB = 0x5e800 实际填大小可以填大一些 AUPACKRES_LEN = 0x5f000
> #if defined CONFIG_AUDIO_ENABLE && defined CONFIG_VOICE_PROMPT_FILE_SAVE_IN_RESERVED_EXPAND_ZONE
> AUPACKRES_FILE=packres/AUPACKRES; [烧录后不可升级的资源]
> AUPACKRES_ADR=0xXXXXXX; [请根据编译后FLASH INFO打印的实际地址填写，比如0x59b000，建议预留好足够的空间，烧录后不支持升级更改]
> AUPACKRES_LEN=0xXXXXXX; [更新提示音资源打包后必须更新此实际长度,比如0x141000，，建议预留好足够的空间，烧录后不支持升级更改]
> AUPACKRES_OPT=1;
> #endif
>
> #if defined CONFIG_UI_ENABLE && defined CONFIG_UI_FILE_SAVE_IN_RESERVED_EXPAND_ZONE
> UIPACKRES_FILE=packres/UIPACKRES; [烧录后不可升级的资源]
> UIPACKRES_ADR=0xXXXXXX; [请根据编译后FLASH INFO打印的实际地址填写，比如0x6dc000，建议预留好足够的空间，烧录后不支持升级更改]
> UIPACKRES_LEN=0xXXXXXX; [更新UI资源打包后必须更新此实际长度，比如0x123000，建议预留好足够的空间，烧录后不支持升级更改]
> UIPACKRES_OPT=1;
> #endif
> ```

* 非常规方法升级扩展预留区资源

> ```
> //因为扩展预留区不能通过常规的OTA升级更新，需要用户在应用层自行获取升级资源后，直接通过flash擦写的方法去更新扩展预留区资源，具体参考apps/common/update/expand_zone_file_update.c
> //测试时需要修改isd_config.ini文件把UIPACKRES_LEN设置成AUPACKRES_LEN同一个值
> static int expand_zone_packres_file_test(void)
> {
>     u32 au_update_addr, ui_update_addr;
>     void *data = malloc(SDFILE_SECTOR_SIZE);
>
>     check_expand_zone_packres_file_crc("mnt/sdfile/EXT_RESERVED/aupackres");
>     check_expand_zone_packres_file_crc("mnt/sdfile/EXT_RESERVED/uipackres");
>
>     au_update_addr = expand_zone_packres_file_update_start("mnt/sdfile/EXT_RESERVED/aupackres");
>     ui_update_addr = expand_zone_packres_file_update_start("mnt/sdfile/EXT_RESERVED/uipackres");
>
>     for (u32 offset = 0; offset < 0x141000; offset += SDFILE_SECTOR_SIZE) {
>         sdfile_reserve_zone_read(data, au_update_addr + offset, SDFILE_SECTOR_SIZE, 0);
>         //把UI资源擦写成提示音资源
>         expand_zone_packres_file_update_write(ui_update_addr + offset, data, SDFILE_SECTOR_SIZE);
>     }
>
>     free(data);
>
>     //升级完成后重新校验文件完整性
>     check_expand_zone_packres_file_crc("mnt/sdfile/EXT_RESERVED/aupackres");
>     check_expand_zone_packres_file_crc("mnt/sdfile/EXT_RESERVED/uipackres");
>
>     return 0;
> }
> ```

## 7.19.5. 常见问题

**(1) [RESERVED_CONFIG]与[RESERVED_EXPAND_CONFIG]的区别？**

答：`[RESERVED_CONFIG]` 区域最多可以设置6个配置项，其中VM、BTIF和PRCT为系统默认使用，用户不能占用。 用户可使用的只有3个配置项（如：配置文件中PROFILE、AISP和EXIF），可以根据实际需要进行使用和修改。当超出使用个数时，可以使用 `[RESERVED_EXPAND_CONFIG]` 区域。 当使用预留区作为资源升级区时，只能使用 `[RESERVED_CONFIG]`； `[RESERVED_EXPAND_CONFIG]` 区域暂时不支持作为资源升级区使用。 `[RESERVED_EXPAND_CONFIG]` 区域在flash空间足够的情况下没有个数限制。

**(2) 预留区中指定文件，但是没有填写绝对地址导致编译器报错问题，如“错误：在配置文件（isd_config.ini）中发现非标准的预留区域配置。”？**

答：当预留区指定文件时，只有编译后才知道工具实际给文件分配的地址，因此需要对isd_config_rule.c 文件进行修改。如上图：在FLASH INFO中获知AUPACKRES_RESERVED_SIZE : 0x141000， AUPACKRES_RESERVED_START : 0x6bd000，在isd_config_rule.c修改AUPACKRES_ADR=0x6bd000， AUPACKRES_LEN=0x141000。再编译工程即可。

# 7.20. PRINTF

**Overview** 提供打印的多种方式应用示例和常见问题。

## 7.20.1. 应用示例

**示例演示：**

* 各种user_printf的使用示例

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_PRINTF_TEST_DEMO` 。

* 各种字母在打印中代表的意思:* `(` 网络歌曲下载缓存中。
  * `)` 网络歌曲下载缓存中。
  * `{` 低功耗模式下，RF休眠后触发系统休眠。
  * `}` 低功耗模式下，RF休眠后触发的系统休眠已经唤醒。
  * `<` 低功耗模式下，在没有打开RF的情况下，触发系统休眠。
  * `>` 低功耗模式下，在没有打开RF的情况下，触发的系统休眠已经唤醒。
  * `C` LWIP收到的包如果是ICMP包并且不是echo和echo reply就丢弃，因为是一些Time_Ex等无用包。
  * `D` LWIP的PBUF_POOL在剩余小于PBUF_RESERVED_FOR_TCP的情况下，丢弃非TCP包。
  * `X` LWIP的PBUF_POOL用完了了，wifi底层收到的包直接丢弃
  * `Y` LWIP的PBUF_POOL在剩余小于PBUF_RESERVED_FOR_ARP的情况下, 丢弃收到的非ARP包
  * `E` BLE通讯可以发送消息。
  * `F` 经典蓝牙播放A2DP媒体流时，btctrler底层硬件的接收BUF已满。
  * `G` WIFI底层硬件的TX缓冲队列已空，上层发出去的包直接丢弃。
  * `H` WIFI底层硬件的TX缓冲队列在剩余小于WIFI_TXQ_RESERVED_FOR_TCP的情况下，丢弃上层发出去的非TCP包。
  * `O` WIFI底层硬件的TX缓冲队列在剩余小于WIFI_TXQ_RESERVED_FOR_ARP的情况下，丢弃非ARP包。
  * `@` 空中干扰/网络拥塞严重的情况,WIFI底层发送较慢,LWIP 发送UDP包处于BUSY
  * `|` 空中干扰/网络拥塞严重的情况,WIFI底层发送较慢,LWIP 发送非UDP包处于BUSY
  * `J` jpeg解码硬件底层buffer出现写越界的情况。
  * `R` JPEG图片解码模式下，图片位流是分MCU行（YUV420/422，16行），不是整帧模式。
  * `I` 经典蓝牙已打开可发现性。
  * `P` 经典蓝牙已打开可连接性。
  * `Q` 经典蓝牙正在回连中。
  * `K` 经典蓝牙A2DP播放时收到的包出现丢失或者序号出错。
  * `M` 蓝牙发射器发送媒体音频流时出现解码跟不上的情况。
  * `N` 蓝牙发射器发送媒体音频流时出现解码数据不足的情况。
  * `W` 立刻唤醒正在休眠的wifi后发送数据。
  * `Z` wifi底层硬件的收发缓冲buf不足。
  * `$` BLE当前事件收不到包，关闭latency。
  * `#` 等待BT链路释放。
  * `y` A2DP链路buffer剩余大小小于1000，通常为链接有干扰或采样率不匹配导致。
  * `LA` wifi set psm bit
  * `LB` wifi clear psm bit

## 7.20.2. 常见问题

* 如何关闭 `Y` 等字母打印
  > 答: 搜索 `putchar` ，在 `wifi_conf.c` 中注释掉对应的 `putchar('Y')` 即可。其他字母打印同样全局搜索 `putchar` ，只能逐个注释。
  >
* 如何关闭所有打印,节省代码和内存
  > 答: 在 `app_config.h` 屏蔽 `CONFIG_DEBUG_ENABLE`
  >
* 系统每分钟定时打印任务栈信息，如何关闭？
  > 答: 在 `app_config.h` 屏蔽 `RTOS_STACK_CHECK_ENABLE //是否启用定时检查任务栈`
  >
* 如何关闭SDK原来所有打印,只保留用户新增的打印
  > 答: 在 `app_config.h` 增加两个宏定义
  >
  > #define CONFIG_USER_DEBUG_ENABLE
  >
  > #define CONFIG_SYS_DEBUG_DISABLE
  >
  > 然后使用 `printf.h` 里面user_*的接口来实现打印,如user_printf
  >
* 如何关闭全部log_x的打印
  > 答：code_blocks的build_options编译选项中Compiler setting -> #define的全局宏中默认定义有CONFIG_RELEASE_ENABLE
  >
  > 如果没有定义该宏，则在 `lib_driver_config.c` 中CONFIG_DEBUG_LIB(TRUE)的对应log打印开启。如下图所示。
  >
  > ```
  > //app_config.h
  > #ifdef CONFIG_RELEASE_ENABLE
  > #define LIB_DEBUG    0
  > #else
  > #define LIB_DEBUG    1
  > #endif
  > #define CONFIG_DEBUG_LIB(x)         (x & LIB_DEBUG)
  > ```
  >
  > ![](img\204.png)
  >
  > 跟音频相关的log_x打印（编码服务、解码服务、EQ等）在 `audio_config.c` 中配置开关
  >
  > ```
  > //编码、解码和音频服务相关打印不受CONFIG_RELEASE_ENABLE通过CONFIG_DEBUG_LIB控制，可自行定义相关log开关
  > const char log_tag_const_v_AUDIO_SERVER AT(.LOG_TAG_CONST) = 0;
  > const char log_tag_const_d_AUDIO_SERVER AT(.LOG_TAG_CONST) = 0;
  > const char log_tag_const_i_AUDIO_SERVER AT(.LOG_TAG_CONST) = 1;
  > const char log_tag_const_w_AUDIO_SERVER AT(.LOG_TAG_CONST) = 1;
  > const char log_tag_const_e_AUDIO_SERVER AT(.LOG_TAG_CONST) = 1;
  >
  > const char log_tag_const_v_AUDIO_ENCODER AT(.LOG_TAG_CONST) = 0;
  > const char log_tag_const_d_AUDIO_ENCODER AT(.LOG_TAG_CONST) = 0;
  > const char log_tag_const_i_AUDIO_ENCODER AT(.LOG_TAG_CONST) = 1;
  > const char log_tag_const_w_AUDIO_ENCODER AT(.LOG_TAG_CONST) = 1;
  > const char log_tag_const_e_AUDIO_ENCODER AT(.LOG_TAG_CONST) = 1;
  >
  > const char log_tag_const_v_AUDIO_DECODER AT(.LOG_TAG_CONST) = 0;
  > const char log_tag_const_d_AUDIO_DECODER AT(.LOG_TAG_CONST) = 0;
  > const char log_tag_const_i_AUDIO_DECODER AT(.LOG_TAG_CONST) = 1;
  > const char log_tag_const_w_AUDIO_DECODER AT(.LOG_TAG_CONST) = 1;
  > const char log_tag_const_e_AUDIO_DECODER AT(.LOG_TAG_CONST) = 1;
  > ```
  >
  > WEBSOCKET库的打印控制在 `wifi_conf.c` 中配置开关
  >
* 如何动态开关打印
  > 答： extern int config_debug_enable，设置config_debug_enable值为0关闭打印，为1打开打印
  >
  > 注意：动态控制打印使用打印保存到TF卡时会有丢失问题,可使用sd_log_flush()强制将打印buf的缓存写入sd中，之后再使用config_debug_enable = 0关闭打印
  >
* 如何把打印输出到TF卡里面保存成文件
  > 答:
  >
  > (1)在 ``dubug_user.c``中开启宏定义
  >
  > #CONFIG_SDCARD_DEBUG_ENABLE//开关SD卡记录打印信息
  >
  > 注意：打印保存到sd中使用缓存buf，buf每满10k写入一次到sd卡中（避免频繁写sd），不满则不写入，如需查看最后打印可以使用sd_log_flush()强制将打印buf的缓存写入sd中，或者使用动态开关打印时候，关打印前强制将缓存写入sd中
  >
* 如何把打印输出到云端服务器保存
  答:
  > （1）在 `dubug_user.c` 中开启宏定义
  >
  > #define CONFIG_NETWORK_DEBUG_ENABLE //可以触发打印信息上传到服务器端
  >
  > （2）打开云串口调试工具，获取KeyCode值，并将生成的KeyCode值写到 ``dubug_user.c``的#define LOG_KEYCODE“”中如：
  >
  > #define LOG_KEYCODE “KRPNOCNSTGUMSRNL” //客户随机填写12-16个字符串，用于日志查询
  >
  > （3）开启wifi,使用STA模式，具体可以参考 `wifi` 配置
  >
  > （4）定时调用void upload_log_trig(void);函数，具体定时中断可以参考 `timer` 配置
  >
  > （5）在云串口调试工具中查看日志,关于云串口调试工具的使用可以参考 `云串口调试工具.pdf`
  >
* 如何使用USB虚拟串口作为打印口
  答:
  > (1)在 `dubug_user.c` 中开启宏定义
  >
  > #define CONFIG_USB_DEBUG_ENABLE //开关USB虚拟串口打印信息
  >
  > (2)在 `app_config.h` 中增加宏定义
  >
  > #define TCFG_PC_ENABLE 1
  >
  > #define USB_PC_NO_APP_MODE 2
  >
  > #define TCFG_USB_SLAVE_ENABLE 1
  >
  > #define TCFG_UDISK_ENABLE 0
  >
  > #define USB_DEVICE_CLASS_CONFIG (CDC_CLASS)
  >
  > 注意：在使用打印输出到TF卡、打印输出到云端服务器保存和USB虚拟串口作为打印口时要在 `app_config.h` 中开启宏
  >
  > #defined CONFIG_DEBUG_ENABLE
  >
  > 在跑代码时，把串口拔掉。
  >

## 7.20.3. API Reference

# 7.21. SDTAP

**Overview**

提供SDTAP操作说明和常见问题。SDTAP 用于GDB调试程序,例如通过信号(signal)、断点(breakpoint)、通过step命令执行单步调试。在程序暂停之后，你可以检查并改变变量的值，设置新的断点或者移除老的断点，然后继续执行程序。

## 7.21.1. 操作说明

* 1.在 `app_config.h` 打开宏 `SDTAP_DEBUG`
* 2.编译工程，烧录镜像，复位启动
* 3.使用下图USB Updater V4.0版本或以上,开关7拨到ON;
  ![](img\205.png)
* 4.打开SDK工具里面对应cpu的tools目录下的 DebugServer.exe
* 5.在isd_client 创建一个project 命名为: jtag, 选择工作目录为对应cpu的tools目录下的jtag
  ![](img\206.png)
* 6.在服务器linux终端输入 /opt/gdb cpu/wl82/tools/sdk.elf -ex “target remote proxy:jtag:9872”
* 7.可以继续输入命令进行GDB调试:
  >> 输入 si :汇编级单步调试
  >>
  >> 输入 ni :C语言级单步调试
  >>
  >> 输入 b 函数名 : 设置函数入口为断点
  >>
  >> 输入 Ctrl + c : 程序停止运行
  >>
  >> 输入 c : 程序继续运行
  >>
  >> 输入 bt : 查看函数调用树
  >>
  >> 输入 i r : 查看寄存器
  >>
  >> 输入 layout reg: 可以观察更多
  >>
  >> 输入 thread 1/2 : 切换另外一个核
  >>
  >> rwatch 命令：只要程序中出现读取目标变量（表达式）的值的操作，程序就会停止运行；
  >>
  >> awatch 命令：只要程序中出现读取目标变量（表达式）的值或者改变值的操作，程序就会停止运行。
  >>
  >
  > ![](img\207.png)
  >
  > ![](img\208.png)
  >
  > ![](img\209.png)
  >

## 7.21.2. 常见问题

* 目前SDTAP/JTAG只对内部开放,用户请寻求FAE援助

## 7.21.3. API Reference

# 7.22. 硬件浮点

**Overview**

提供硬件浮点应用示例和常见问题。

## 7.22.1. 应用示例

**示例演示：**

* 硬件浮点应用示例

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_HW_FLOAT_TEST_DEMO` 。

## 7.22.2. 常见问题

* 硬件浮点支持双精度吗?
  > 答:硬件只支持单精度浮点float,不支持双精度double;立即数运算要写成1.0f,不能够写成1.0,否则程序按照软件双精度浮点运算;
  >

## 7.22.3. API Reference

# 7.23. WAIT_COMPLETION

**Overview**

提供wait_completion接口使用方法和常见问题。

## 7.23.1. 应用示例

**示例演示：**

* wait_completion接口使用

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_WAIT_COMPLETION_TEST_DEMO` 。

## 7.23.2. 常见问题

* wait_completion一般什么情况下使用
  答:一般用于异步事件非阻塞处理,需要等待条件成立再去运行某个函数,并且想这个函数指定在任务中如app_core运行,避免阻塞等死,也可以达到单线程去运行函数

## 7.23.3. API Reference

**Functions**

u16 **wait_completion_add_to_task**(const char *task_name, int (*condition)(void*), int (*callback)(void*), void *priv, void *condition_priv)
条件轮询回调,回调函数将通过队列消息由指定线程接收执行

**Note**
指定的线程一定要接收任务队列消息才会执行回调函数

**Parameters:**
task_name – 指定执行回调函数的任务名
condition – 条件判断函数指针
callback – 回调函数指针
priv – 传到回调函数参数指针
condition_priv – 传到判断条件函数参数指针

**Returns:**
id:创建成功的id号 0:失败

---

u16 **wait_completion**(int (*condition)(void*), int (*callback)(void*), void *priv, void *condition_priv)
条件轮询回调,回调函数将通过队列消息由当前线程接收执行

**Note**
调用此函数的线程一定要接收任务队列消息才会执行回调函数

**Parameters:**
condition – 条件判断函数指针
callback – 回调函数指针
priv – 传到回调函数参数指针
condition_priv – 传到判断条件函数参数指针

**Returns:**
id:创建成功的id号 0:失败

---

int **wait_completion_del**(u16 id)
删除条件轮询回调函数

**Parameters:**
id – 创建的时候对应返回的ID号

**Returns:**
0:成功 非0:失败

# 7.24. WDT

## Overview

提供看门狗应用示例、配置介绍和常见问题。

## 7.24.1. 应用实例

示例演示：

- 更新看门狗清狗时间
- 关闭看门狗
- 禁止SDK内部清除看门狗操作, 用户自己外部清除看门狗

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_WDT_TEST_DEMO`。

## 7.24.2. 常见问题

1. 看门狗清狗时间通过 wdt_init 函数去设置，具体的时间参数设置可参考下面的 `API参考`。
2. 看门狗关闭通过 wdt_close() 去设置。
3. 如何禁止 SDK 内部清除看门狗操作, 用户自己外部清除看门狗？
   答： 在本示例程序中重写覆盖库内弱函数 wdt_clear，选择不再使用库内函数清看门狗, 并且开启本示例中的 wdt_clear_user 用户自己外部清狗线程即可。
4. 如何让看门狗溢出直接复位系统,不进入异常函数？
   答： 调用wdt_reset_enable让看门狗溢出不经过异常函数直接复位, 并且需要打开宏EXPCPTION_IN_SRAM,防止flash挂了,进入异常函数失败复位不了

## 7.24.3. API参考

### Functions

void **wdt_init**(u8 time)
wdt_init：看门狗初始化

**Parameters:**
time – 看门狗清狗时间

| 宏        | 数值 | 时间  |
| --------- | ---- | ----- |
| WDT_1MS   | 0x00 | 1ms   |
| WDT_2MS   | 0x01 | 2ms   |
| WDT_4MS   | 0x02 | 4ms   |
| WDT_8MS   | 0x03 | 8ms   |
| WDT_16MS  | 0x04 | 16ms  |
| WDT_32MS  | 0x05 | 32ms  |
| WDT_64MS  | 0x06 | 64ms  |
| WDT_128MS | 0x07 | 128ms |
| WDT_256MS | 0x08 | 256ms |
| WDT_512MS | 0x09 | 512ms |
| WDT_1S    | 0x0A | 1s    |
| WDT_2S    | 0x0B | 2s    |
| WDT_4S    | 0x0C | 4s    |
| WDT_8S    | 0x0D | 8s    |
| WDT_16S   | 0x0E | 16s   |
| WDT_32S   | 0x0F | 32s   |

void **wdt_close**(void)
wdt_close：关闭看门狗

void **wdt_clear**(void)
wdt_clear：清除看门狗

void **wdt_enable**(void)
wdt_enable：使能看门狗

void **wdt_disable**(void)
wdt_disable：不使能看门狗

void **wdt_reset_enable**(void)
wdt_reset_enable：看门狗溢出直接系统复位

# 7.25. LONG_PRESS_RESET

**Overview**

提供长按复位接口使用方法和常见问题。

## 7.25.1. 应用示例

**示例演示：**

* 长按复位可4秒或8秒复位。

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_LONG_PRESS_RESET_TEST_DEMO` 。

**Note**

board.c 添加长按IO配置和4秒/8秒配置:

```
/************************** PWR wakeup config ****************************/
//#define PORT_VCC33_CTRL_IO                IO_PORTA_03                                     //VCC33 DCDC控制引脚,该引脚控制DCDC器件输出的3.3V连接芯片HPVDD、VDDIO、VDD33
#define PORT_WAKEUP_IO                      IO_PORTB_01                                     //软关机和休眠唤醒引脚
#define PORT_WAKEUP_NUM                     (PORT_WAKEUP_IO/IO_GROUP_NUM)//默认:0-7:GPIOA-GPIOH, 可以指定0-7组

//软关机硬件唤醒IO相关配置
static const struct port_wakeup port0 = {
    .edge       = FALLING_EDGE,                            //唤醒方式选择,可选：上升沿\下降沿
    .attribute  = BLUETOOTH_RESUME,                        //保留参数
    .iomap      = PORT_WAKEUP_IO,                          //唤醒口选择
    .low_power      = POWER_SLEEP_WAKEUP|POWER_OFF_WAKEUP,    //低功耗IO或睡眠唤醒,不需要写0
};
//正常工作长按复位IO配置
static const struct long_press lpres_port = {
  .enable   = TRUE,                                                                 //是否使用长按复位，TRUE为使能，FALSE则禁能
  .use_sec4         = TRUE,                                                                         //enable = TRUE , use_sec4: TRUE --> 4 sec , FALSE --> 8 sec
  .edge             = FALLING_EDGE,                                                         //长按方式,可选：FALLING_EDGE /  RISING_EDGE --> 低电平/高电平
  .iomap            = PORT_WAKEUP_IO,                                                       //长按复位IO和IO唤醒共用一个IO
};
//保留参数，无需更改
static const struct sub_wakeup sub_wkup = {
    .attribute  = BLUETOOTH_RESUME,
};
//保留参数，无需更改
static const struct charge_wakeup charge_wkup = {
    .attribute  = BLUETOOTH_RESUME,
};
//唤醒参数配置
static const struct wakeup_param wk_param = {
    .port[0] = NULL,//当需要IO唤醒，详情soft_power_off例子
    .sub = &sub_wkup,
    .charge = &charge_wkup,
  .lpres = &lpres_port,//当使用正常工作时可长按复位功能，详情longpress例子
};

//电源初始化
static void board_power_init(void)
{
    power_wakeup_init(&wk_param);//唤醒参数初始化，包括长按复位
```

## 7.25.2. 常见问题

* 长按复位IO，默认根据配置边缘选择性的开启内部上下拉（下降沿则上拉，上升沿则下拉），因此长按复位硬件IO使用和唤醒IO不一样时，可以不用外接上下拉电阻；当长按复位硬件IO使用和唤醒IO为同一个IO时，长按功能不受影响，但IO需要外接上下拉来维持IO唤醒时的软关机后IO电平。
* 长按复位功能是 `board.c` 配置好对应程序后，系统上电运行就自动加载长按功能，因此系统运行后可以长按按键来完成复位功能。

## 7.25.3. API Reference

# 7.26. SERVER

**Overview**

提供server接口应用示例和常见问题。

## 7.26.1. 应用示例

**示例演示：**

* 如何创建使用server;
* server事件event响应流程;

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_SERVER_TEST_DEMO` 。

**Note**

**main.c**

> c_main()入口：* 1.创建server_example_task任务
>
> * 2. server_example_task
>      A.打开服务
>      B.注册服务事件通知回调
>      C.同步和异步请求服务做事情
>      D.清除服务队列还没执行的 server_event_handler 事件通知
>      E.关闭服务,释放资源

**test_server.c**

> * 1. SERVER_REGISTER：创建server
> * 2. test_server_open：创建一个与 SERVER_REGISTER name 同名的任务
> * 3. test_server_task
>
>   > A）响应层应用请求事件
>   >
>   > B ) 事件通知上层应用
>   >
> * 4. test_server_close
>
>   > A）删除test_server任务
>   >

## 7.26.2. 常见问题

* 为什么要使用server
  答:用户新增一个功能库, 外部直接调用功能接口有可能存在互斥的问题,引入server是为了解决这个问题,应用程序无需关心使用互斥问题,server任务统一了事件的操作,并且提供一种框架给用户使用.用户也可以通过熟悉此例子来了解其他server库的使用

## 7.26.3. API Reference

**Functions**

struct server ***server_open**(const char *name, void *arg)
打开服务

**Parameters:**
name – 服务名称
arg – 服务的私有参数

**Returns:**
server: 创建成功返回服务句柄 NULL:打开失败

void **server_register_event_handler**(struct server *server, void *priv, void (*handler)(void*, int argc, int *argv))
注册服务事件回调

**Note**
执行该函数的当前任务必须带有队列消息，并且需要接收队列消息才能执行事件回调

**Parameters:**
server – server_open返回的服务句柄
priv – 服务事件回调的私有指针
handler – 服务事件回调函数

void **server_register_event_handler_to_task**(struct server *server, void *priv, void (*handler)(void*, int argc, int *argv), const char *task_name)
注册服务事件回调，并指定执行服务事件回调函数的任务

**Note**
指定的任务必须带有队列消息，并且需要接收队列消息才能执行事件回调

**Parameters:**
server – server_open返回的服务句柄
priv – 服务事件回调的私有指针
handler – 服务事件回调函数
task_name – 指定执行服务事件回调函数的任务名称

void **server_close**(struct server *server)
关闭服务

**Parameters:**
server – server_open返回的服务句柄

int **server_request**(struct server *server, int req_type, void *arg)
同步请求服务，待服务请求成功才退出函数

**Parameters:**
server – server_open返回的服务句柄
req_type – 服务请求的类型
arg – 对应服务请求的参数

**Returns:**
0:请求成功 非0:请求失败

int **server_request_async**(struct server *server, int req_type, void *arg, ...)
异步请求服务，该函数退出并不代表服务已经请求成功

**Parameters:**
server – server_open返回的服务句柄
req_type – 服务请求的类型
arg – 对应服务请求的参数

**Returns:**
0:请求成功 非0:请求失败

int **server_req_complete**(struct server_req *req)
服务请求响应完成

**Parameters:**
req – 服务请求信息

**Returns:**
0:成功 非0:失败

int **server_event_handler**(void *server, int argc, int *argv)
服务有事件通知上层应用处理

**Parameters:**
server – server_open返回的服务句柄
argc – 事件的参数个数
argv – 事件参数数组

**Returns:**
0:成功 非0:失败

int **server_event_handler_del**(void *server, int argc, int *argv)
清除任务消息回调还没执行的通过server_event_handler的事件通知, 参数必须与server_event_handler指定事件相同

**Parameters:**
server – server_open返回的服务句柄
argc – 通知时对应的事件的参数个数
argv – 通知时对应的事件参数数组

**Returns:**
0:成功 非0:失败

# 7.27. SOFT_POWER_OFF

**Overview**

提供软关机低功耗接口使用方法和常见问题。

## 7.27.1. 应用示例

**示例演示：**

* 电源配置
* 关机唤醒IO选择配置（边缘选择等）
* 关机前的IO配置
* 电源和唤醒初始化
* 调用power_set_soft_poweroff关机。

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_SOFT_POWER_OFF_TEST_DEMO` 。

Note

* 1.board.c 添加电源配置和IO唤醒配置参数，并添加到初始化。

> ```
> 1. sys_timer_test()入口：
>
>     - A）timer_id = sys_timer_add(NULL, callback_example, 5 * 1000);//注册一个定时器timer，定时时间5秒，并返回id
>
>     - B）
>       #if 0   //条件0执行修改后的定时时间2秒，条件1继续执行定时时间5秒
>
>       printf("timer_id = %d\r\n", timer_id);      //打印分配的timer id
>
>       #else
>         if(timer_id)
>         {
>           printf("timer_id = %d\r\n", timer_id);
>           sys_timer_modify(timer_id, 2 * 1000);   //修改timer的定时时间为2秒
>         }
>
>       #endif
>
>
>
>     - C）每隔2秒的定时时间，则回调一次callback_example()
>
>     - D）回调3次callback_example()后，执行sys_timer_del(timer_id);//删除timer，回调3次即删除timer
>
> 2. sys_timeout_test()入口：
>
>    - A）timeout_id = sys_timeout_add(NULL, callback_example, 5 * 1000);//注册一个timeout，并返回id，定时时间到了自动删除timeout
>
>    - B）#if 0   //条件0执行修改后的定时时间2秒;条件1删除定时时间为5秒的timeout
>          printf("timeout_id = %d\r\n", timeout_id);
>
>             sys_timeout_del(timeout_id);    //删除timeout，会自动删除，实际用不到该函数。
>
>             #else
>          if(timeout_id)
>         {
>           printf("timeout_id = %d\r\n", timeout_id);
>           //sys_timeout_modify(timeout_id, 2 * 1000);  //库里暂时没有该函数，仍执行5秒定时
>         }
>
>       #endif
>
>    - C）一旦5秒的定时时间到，仅回调一次callback_example()，自动删除timeout
>
> 3. usr_timer_test()入口:
>
>    - A) timer_id = usr_timer_add((void* )1, callback_example, 2*1000, 1); //注册一个高精度timer，传参为1，定时时间2秒，并返回id
>
>    - B) #if 0   //条件0执行修改后的定时时间500毫秒，条件1执行定时时间2秒
>         printf("timer_id = %d\r\n", timer_id);
>         #else
>           if(timer_id)
>          {
>             printf("timer_id = %d\r\n", timer_id);
>             usr_timer_modify(timer_id, 500);  //修改timer的定时时间为500毫秒
>          }
>
>          #endif
>
>    - C )  每隔500毫秒的定时时间，则回调一次callback_example(1)
>
>    - D）回调3次callback_example(1)后，执行sys_timer_del(timer_id); //删除timer，回调3次即删除timer
>
> 4. usr_timeout_test()入口：
>
>    - A）timeout_id = usr_timeout_add((void* )1, callback_example, 2*1000, 1); //注册一个高精度timeout，定时时间2秒，并返回id，只回调一次
>
>    - B）#if 0   //条件0执行修改后的定时时间500毫秒;条件1删除定时时间为2秒的timeout
>
>          printf("timeout_id = %d\r\n", timeout_id);
>
>          usr_timeout_del(timeout_id);    //删除timeout
>
>             #else
>          if(timeout_id)
>         {
>            printf("timeout_id = %d\r\n", timeout_id);
>            usr_timeout_modify(timeout_id, 500);  //修改timeout的定时时间为500毫秒
>         }
>       #endif
>
>   - C）一旦500毫秒的定时时间到，仅回调一次callback_example()
> ```

**在board_power_init的power_keep_state函数参数为关机要保持的功能** ，VMC手动复位：POWER_KEEP_RESET，DAC电源：POWER_KEEP_DACVDD，RTC走时：POWER_KEEP_RTC，需要则在传参或上即可。

 **关机函数之一** ： `void power_set_soft_poweroff(void)` 。

 **唤醒原因函数** ： `int system_reset_reason_get(void)` , IO唤醒则函数返回值为 `SYS_RST_PORT_WKUP`，各项原因文件： `system_reset_reason.h` ,

**多IO唤醒原因获取函数：** `apps/common/system/system_reset_reason.c` 文件的 `int system_wakeup_port_get(void)` ，当唤醒原因为IO唤醒则该函数返回>0（不是IO唤醒则小于0），使用返回值的位0到7来判断唤醒组， 对应值为board_xxx.c（如上述代码区域）的 `static const struct wakeup_param wk_param` 的port[x]参数，返回值的位0为1，即0x1，则对应port[0]的IO；返回值的位1为1，即0x2，则对应port[1]的IO；返回值的位2为1，即0x4，则对应port[2]的IO，以此类推。

> ```
> //多个IO唤醒配置
> static const struct port_wakeup port0 = {
>     .edge       = FALLING_EDGE,                            //唤醒方式选择,可选：上升沿\下降沿
>     .attribute  = BLUETOOTH_RESUME,                        //保留参数
>     .iomap      = IO_PORTA_00,                          //唤醒口选择
>     .low_power  = POWER_SLEEP_WAKEUP|POWER_OFF_WAKEUP,    //低功耗IO唤醒,不需要写0
> };
> static const struct port_wakeup port1 = {
>     .edge       = FALLING_EDGE,                            //唤醒方式选择,可选：上升沿\下降沿
>     .attribute  = BLUETOOTH_RESUME,                        //保留参数
>     .iomap      = IO_PORTA_01,                          //唤醒口选择
>     .low_power  = POWER_SLEEP_WAKEUP|POWER_OFF_WAKEUP,    //低功耗IO唤醒,不需要写0
> };
> static const struct port_wakeup port2 = {
>     .edge       = FALLING_EDGE,                            //唤醒方式选择,可选：上升沿\下降沿
>     .attribute  = BLUETOOTH_RESUME,                        //保留参数
>     .iomap      = IO_PORTA_02,                          //唤醒口选择
>     .low_power  = POWER_SLEEP_WAKEUP|POWER_OFF_WAKEUP,    //低功耗IO唤醒,不需要写0
> };
> //...
> static const struct wakeup_param wk_param = {
>     .port[0] = &port0,//多个IO唤醒配置则port从0开始
>     .port[1] = &port1,
>     .port[2] = &port2,
>     .sub = &sub_wkup,
>     .charge = &charge_wkup,
>     .lpres = &lpres_port,
> };
> ```

 **唤醒IO配置** ：如 `static const struct port_wakeup port0` 的iomap变量，可以设置IO_PORTA_01到IO_PORTH_15，芯片是791x则还可以设置IO_PORT_USB_DMA和IO_PORT_USB_DPA，如在791x设置usb0(FUSB)插入唤醒，则应当设置在IO_PORT_USB_DMA，usb1(HUSB)不支持持IO唤醒。

> ```
> staticconststructport_wakeupport0={
> .edge=FALLING_EDGE,//唤醒方式选择,可选：上升沿\下降沿
> .attribute=BLUETOOTH_RESUME,//保留参数
> .iomap=IO_PORT_USB_DMA,//唤醒口选择
> .low_power=POWER_SLEEP_WAKEUP|POWER_OFF_WAKEUP,//低功耗IO唤醒,不需要写0
> };
> //...
> staticconststructwakeup_paramwk_param={
> .port[0]=&port0,//port从0开始
> .sub=&sub_wkup,
> .charge=&charge_wkup,
> .lpres=&lpres_port,
> };
> ```

 **唤醒IO的内置上下拉电阻配置** ：如 `static const struct port_wakeup port0` 的edge变量或上AUTO_PUPD，则完成内部根据唤醒边缘方式进行IO的上下拉自动配置，前提是：外部IO不能接其他电路电压高于休眠的VDDIO电压，否则开启内部上下拉会倒灌电流；同时在IO外部没接电路也没接电阻情况下，要开启AUTO_PUPD。

> ```
> static const struct port_wakeup port0 = {
>     .edge       = FALLING_EDGE | AUTO_PUPD,                //唤醒方式选择,可选：上升沿\下降沿，开启内部上下自动跟随边缘选择配置
>     .attribute  = BLUETOOTH_RESUME,                        //保留参数
>     .iomap      = IO_PORT_USB_DMA,                          //唤醒口选择
>     .low_power  = POWER_SLEEP_WAKEUP|POWER_OFF_WAKEUP,    //低功耗IO唤醒,不需要写0
> };
> //...
> static const struct wakeup_param wk_param = {
>     .port[0] = &port0,//port从0开始
>     .sub = &sub_wkup,
>     .charge = &charge_wkup,
>     .lpres = &lpres_port,
> };
> ```

* 2. `app_config.h` 添加电源配置参数（步骤1的 `board.c` 使用）

  ```
  //*********************************************************************************//
  //                                  低功耗配置                                     //
  //*********************************************************************************//
  #define TCFG_LOWPOWER_BTOSC_DISABLE                       0
  #define TCFG_LOWPOWER_LOWPOWER_SEL                        0//SLEEP_EN  //该宏在睡眠低功耗才用到，此处设置为0
  #define TCFG_LOWPOWER_VDDIOM_LEVEL                        VDDIOM_VOL_32V //正常工作的内部vddio电压值，一般使用外部3.3V，内部设置需比外部3.3V小
  #define TCFG_LOWPOWER_VDDIOW_LEVEL                        VDDIOW_VOL_21V //软关机或睡眠的内部vddio最低电压值
  #define VDC14_VOL_SEL_LEVEL                                       VDC14_VOL_SEL_140V //内部的1.4V默认1.4V
  #define SYSVDD_VOL_SEL_LEVEL                              SYSVDD_VOL_SEL_126V //系统内核电压，默认1.26V
  ```

## 7.27.2. 常见问题

* 1.当需要按键触发关机时，在调用power_set_soft_poweroff()函数前最好先等待按键释放完全再调用关机函数。
* 2.由于内部上下拉电阻精度不高（10K左右），因此IO唤醒的硬件IO需要外接上下拉电阻，具体看看需求接上拉还是下拉，系统进软关机后会把内部的上下拉都关闭，因此需要硬件上芯片外部上下拉电阻维持IO状态。
* 3.当芯片的IO唤醒外部硬件没加上下拉（或者想省外部上下拉）的前提：外部IO不能接其他电路电压高于休眠的VDDIO电压，否则开启内部上下拉会倒灌电流；同时在IO外部没接电路也没接电阻情况下，要开启AUTO_PUPD。

## 7.27.3. API Reference

# 7.28. SYSTEM_RESET_REASON

**Overview**

提供系统复位使用方法和常见问题。

## 7.28.1. 应用示例

**示例演示：**

* 长按复位可4秒或8秒复位。

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_SYSTEM_RESET_REASON_TEST_DEMO` 。

**Note**

* 1、使用说明

系统上电运行后自动调用 `system_reset_reason_get();` 来获取系统复位信息，同时也打印出系统复位原因，例如：

========= system reset reason: SOFT =========

* 2、系统复位原因

system_reset_reason_get() 函数返回值对应的位表示不同的复位原因，可获取复位原因后做其他的操作（比如IO唤醒则检测是不是长按还是短按，或者闹钟唤醒时更改闹钟时间等），对应CPU的头文件 system_reset_reason.h。

> ```
> enum sys_reset_type {
> SYS_RST_NONE = 0,
> SYS_RST_12V = BIT(1),//1.2V内核复位
> SYS_RST_WDT = BIT(2),//看门狗复位
> SYS_RST_VCM = BIT(3),//复位键复位
> SYS_RST_SOFT = BIT(4),//软件复位
> SYS_RST_ALM_WKUP = BIT(5),//闹钟唤醒复位
> SYS_RST_PORT_WKUP = BIT(6),//IO唤醒复位
> SYS_RST_LONG_PRESS = BIT(7),//长按复位
> SYS_RST_VDDIO_PWR_ON = BIT(8),//上电复位
> SYS_RST_VDDIO_LOW_PWR = BIT(9),//低电压复位
> };
> ```

**复位原因解析：**

* 1.2V内核复位：一般不会出现。
* 看门狗复位：程序跑飞或者程序死循环导致不能清狗。
* 复位键复位：芯片的VCM复位引脚被置高电平（3.3V左右）。
* 软件复位：系统调用cpu_reset()或者system_reset()。
* 闹钟唤醒复位：使用RTC并且使能闹钟唤醒功能后软关机到达唤醒时间。
* IO唤醒复位：软关机后IO被触发唤醒。
* 上电复位：一般正常通电启动就是上电复位。
* 低电压复位：电压不足。

## 7.28.2. 常见问题

* 长按复位IO，默认根据配置边缘选择性的开启内部上下拉（下降沿则上拉，上升沿则下拉），因此长按复位硬件IO使用和唤醒IO不一样时，可以不用外接上下拉电阻；当长按复位硬件IO使用和唤醒IO为同一个IO时，长按功能不受影响，但IO需要外接上下拉来维持IO唤醒时的软关机后IO电平。
* 长按复位功能是board.c配置好对应程序后，系统上电运行就自动加载长按功能，因此系统运行后可以长按按键来完成复位功能。

## 7.28.3. API Reference

# 7.29. SYSTEM_TIMER

**Overview**

提供系统定时器使用示例方法和常见问题。

## 7.29.1. 应用示例

**示例演示：**

* sys_timer、sys_timeout、usr_timer、usr_timeout四种定时函数使用示例

example:

* 1.使用sys_timer例子在 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_SYS_TIMER_TEST_DEMO` 。
* 2.使用sys_timeout例子在 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_SYS_TIMEROUT_TEST_DEMO` 。
* 3.使用usr_timer例子在 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_USR_TIMER_TEST_DEMO` 。
* 4.使用usr_timeout例子在 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_USR_TIMEROUT_TEST_DEMO` 。

**代码流程：**

> ```
> 1. sys_timer_test()入口：
>
>     - A）timer_id = sys_timer_add(NULL, callback_example, 5 * 1000);//注册一个定时器timer，定时时间5秒，并返回id
>
>     - B）
>       #if 0   //条件0执行修改后的定时时间2秒，条件1继续执行定时时间5秒
>
>       printf("timer_id = %d\r\n", timer_id);      //打印分配的timer id
>
>       #else
>         if(timer_id)
>         {
>           printf("timer_id = %d\r\n", timer_id);
>           sys_timer_modify(timer_id, 2 * 1000);   //修改timer的定时时间为2秒
>         }
>
>       #endif
>
>
>
>     - C）每隔2秒的定时时间，则回调一次callback_example()
>
>     - D）回调3次callback_example()后，执行sys_timer_del(timer_id);//删除timer，回调3次即删除timer
>
> 2. sys_timeout_test()入口：
>
>    - A）timeout_id = sys_timeout_add(NULL, callback_example, 5 * 1000);//注册一个timeout，并返回id，定时时间到了自动删除timeout
>
>    - B）#if 0   //条件0执行修改后的定时时间2秒;条件1删除定时时间为5秒的timeout
>          printf("timeout_id = %d\r\n", timeout_id);
>
>             sys_timeout_del(timeout_id);    //删除timeout，会自动删除，实际用不到该函数。
>
>             #else
>          if(timeout_id)
>         {
>           printf("timeout_id = %d\r\n", timeout_id);
>           //sys_timeout_modify(timeout_id, 2 * 1000);  //库里暂时没有该函数，仍执行5秒定时
>         }
>
>       #endif
>
>    - C）一旦5秒的定时时间到，仅回调一次callback_example()，自动删除timeout
>
> 3. usr_timer_test()入口:
>
>    - A) timer_id = usr_timer_add((void* )1, callback_example, 2*1000, 1); //注册一个高精度timer，传参为1，定时时间2秒，并返回id
>
>    - B) #if 0   //条件0执行修改后的定时时间500毫秒，条件1执行定时时间2秒
>         printf("timer_id = %d\r\n", timer_id);
>         #else
>           if(timer_id)
>          {
>             printf("timer_id = %d\r\n", timer_id);
>             usr_timer_modify(timer_id, 500);  //修改timer的定时时间为500毫秒
>          }
>
>          #endif
>
>    - C )  每隔500毫秒的定时时间，则回调一次callback_example(1)
>
>    - D）回调3次callback_example(1)后，执行sys_timer_del(timer_id); //删除timer，回调3次即删除timer
>
> 4. usr_timeout_test()入口：
>
>    - A）timeout_id = usr_timeout_add((void* )1, callback_example, 2*1000, 1); //注册一个高精度timeout，定时时间2秒，并返回id，只回调一次
>
>    - B）#if 0   //条件0执行修改后的定时时间500毫秒;条件1删除定时时间为2秒的timeout
>
>          printf("timeout_id = %d\r\n", timeout_id);
>
>          usr_timeout_del(timeout_id);    //删除timeout
>
>             #else
>          if(timeout_id)
>         {
>            printf("timeout_id = %d\r\n", timeout_id);
>            usr_timeout_modify(timeout_id, 500);  //修改timeout的定时时间为500毫秒
>         }
>       #endif
>
>   - C）一旦500毫秒的定时时间到，仅回调一次callback_example()
> ```

## 7.29.2. 常见问题

* sys_timer/sys_timeout与usr_timer/usr_timeout分别适用于哪些应用？
  答：sys_timer 和sys_timeout适用于在任务中执行，对时间精度要求不高的应用，usr_timer 和usr_timeout 适用于对时间精度要求高的应用。
* sys_timer/usr_timer 与 sys_timerout/usr_timerout 接口的区别？
  答：sys_timer/usr_timer 与 sys_timerout/usr_timerout 接口区别在于 timeout 接口的回调只会被调一次，也就是设定一个未来的时间， 时间到了响应之后便结束这个定时器的生命周期。
* sys_timer 与usr_timer同步异步问题
  答：sys_timer 由 systimer 线程提供时基，属于同步接口，也就是说在哪个线程 add 的 sys_timer，定时时基到了 systimer 线程会发事件通知对应 的 add 线程响应（回调函数被执行）；usr_timer 属于异步接口， add 的时候注册的回调函数将在硬件定时器中时基到时候被调用。
* 函数 `usr_timer_add(void *priv, void (*func)(void *priv), u32 msec, u8 priority)` 中参数 priority（优先级）的问题
  答：usr_timer 的参数 priority（优先级）为 1，系统无法进入低功耗，参数 priority（优先级）为 0，系统低功耗会忽略该节拍，节拍不会丢失，但是周期会变。
* sys_hi_timer/sys_s_hi_timer与usr_timer等同问题
  答：sys_hi_timer 等同为 priority 为 1 的 usr_timer， 在 include_lib/system/timer.h 被宏定义
  sys_s_hi_timer 等同为 priority 为 0 的 usr_timer，在 include_lib/system/timer.h 被宏定义

# 7.29.3. API Reference

**Functions**

u16 **sys_timer_add**(void *priv, void (*func)(void *priv), u32 msec)
sys_timer定时扫描增加接口

**Note**
timer使用说明
系统会进入低功耗，节拍不会丢失
sys_timer由systimer线程提供时基，属于同步接口，也就是说在哪个线程add的sys_timer，定时时基到了，systimer线程会发事件通知对应的add线程响应（回调函数被执行）
与sys_timer_del成对使用

**Parameters:**
priv – 私有参数
func – 定时扫描回调函数
msec – 定时时间， 单位：毫秒

**Returns:**
定时器分配的id号

u16 **sys_timer_add_to_task**(const char *task_name, void *priv, void (*func)(void *priv), u32 msec)
sys_timer定时扫描增加接口

**Note**
timer使用说明
系统会进入低功耗，节拍不会丢失
sys_timer由systimer线程提供时基，属于同步接口，也就是说在哪个线程add的sys_timer，定时时基到了，systimer线程会发事件通知对应的add线程响应（回调函数被执行）
与sys_timer_del成对使用

**Parameters:**
task_name – 指定任务名称
priv – 私有参数
func – 定时回调函数
msec – 定时时间， 单位：毫秒

**Returns:**
定时器分配的id号

void **sys_timer_del**(u16 id)
sys_timer定时扫描删除接口

**Note**
与sys_timer_add成对使用

**Parameters:**
id – sys_timer_add分配的id号

u16 **sys_timeout_add**(void *priv, void (*func)(void *priv), u32 msec)
sys_timer超时增加接口

**Note**
timer使用说明
系统会进入低功耗，节拍不会丢失
sys_timeout由systimer线程提供时基，属于同步接口，也就是说在哪个线程add的sys_timeout，定时时基到了，systimer线程会发事件通知对应的add线程响应（回调函数被执行）
timeout回调只会被执行一次
与sys_timeout_del成对使用

**Parameters:**
priv – 私有参数
func – 超时扫描回调函数
msec – 超时时间， 单位：毫秒

**Returns:**
定时器分配的id号

u16 **sys_timeout_add_to_task**(const char *task_name, void *priv, void (*func)(void *priv), u32 msec)
sys_timer超时增加接口

**Note**
timer使用说明
系统会进入低功耗，节拍不会丢失
sys_timeout由systimer线程提供时基，属于同步接口，也就是说在哪个线程add的sys_timeout，定时时基到了,systimer线程会发事件通知对应的add线程响应（回调函数被执行）
timeout回调只会被执行一次
与sys_timeout_del成对使用

**Parameters:**
task_name – 指定任务名称
priv – 私有参数
func – 超时回调函数
msec – 超时时间， 单位：毫秒

**Returns:**
定时器分配的id号

void **sys_timeout_del**(u16 id)
sys_timer超时删除接口

**Note**
与sys_timeout_add成对使用

**Parameters:**
id – sys_timeout_add分配的id号

void **sys_timer_re_run**(u16 id)
sys_timer定时器重置

**Note**
在定时时间到之前进行重置之后重新计时,sys_timeout定时到之后会被删除,re_run无效

**Parameters:**
id – sys_timer和分sys_timeout配的id号

void **sys_timer_set_user_data**(u16 id, void *priv)
sys_timer定时器设置私有参数

**Parameters:**
id – sys_timer分配的id号
priv – 私有参数

void *sys_timer_get_user_data(u16 id)
sys_timer定时器获取私有参数

**Note**
如果有通过sys_timer_set_user_data重新设置私有参数,则返回的是设置后的私有参数

**Parameters:**
id – sys_timer分配的id号

**Returns:**
返回add时的私有参数

int **sys_timer_modify**(u16 id, u32 msec)
sys_timer修改定时扫描时间接口

**Parameters:**
id – sys_timer_add和sys_timeout_add分配的id号
msec – 定时时间， 单位：毫秒

**Returns:**
0

int **sys_usec_timer_add**(void *priv, void (*func)(void *priv), u32 usec, u8 call_in_irq, u8 once)
微秒级重复定时器添加

**Note**
微秒级定时器同一时间只能运行一个

**Parameters:**
priv – 私有参数
func – 回调函数
usec – 定时时间， 单位：微秒
call_in_irq – 回调函数是否在中断里面执行
once – 是否只运行一次

**Returns:**
定时器分配的id号

void **sys_usec_timer_set**(int id, u32 usec)
微秒级定时器的定时时间修改

**Parameters:**
id – sys_usec_timer_add分配的id号
usec – 定时时间， 单位：微秒

void **sys_usec_timer_del**(int id)
微秒级定时器删除接口

**Note**
与sys_usec_timer_add成对使用

**Parameters:**
id – sys_usec_timer_add分配的id号

u16 **usr_timer_add**(void *priv, void (*func)(void *priv), u32 msec, u8 priority)
usr_timer定时扫描增加接口

**Note**
timer使用说明
usr_timer的参数priority（优先级）为1，使用该类定时器，系统无法进入低功耗
usr_timer的参数priority（优先级）为0，使用该类定时器，系统低功耗会忽略该节拍，节拍不会丢失，但是周期会变
usr_timer属于异步接口， add的时候注册的扫描函数将在硬件定时器中时基到时候被调用。
对应释放接口usr_timer_del

**Parameters:**
priv – 私有参数
func – 定时扫描回调函数
msec – 定时时间， 单位：毫秒
priority – 优先级,范围：0/1

**Returns:**
定时器分配的id号

u16 **usr_timeout_add**(void *priv, void (*func)(void *priv), u32 msec, u8 priority)
usr_timer超时增加接口

**Note**
timer使用说明
usr_timeout的参数priority（优先级）为1，使用该类定时器，系统无法进入低功耗
usr_timeout的参数priority（优先级）为0，使用该类定时器，系统低功耗会忽略该节拍，节拍不会丢失，但是周期会变
usr_timeout属于异步接口， add的时候注册的扫描函数将在硬件定时器中时基到时候被调用。
对应释放接口usr_timerout_del
timeout回调只会被执行一次

**Parameters:**
priv – 私有参数
func – 超时回调函数
msec – 超时时间， 单位：毫秒
priority – 优先级,范围：0/1

**Returns:**
定时器分配的id号

int **usr_timer_modify**(u16 id, u32 msec)
usr_timer修改定时扫描时间接口

**Parameters:**
id – usr_timer_add时分配的id号
msec – 定时时间， 单位：毫秒

**Returns:**
0

int **usr_timeout_modify**(u16 id, u32 msec)
usr_timeout修改超时时间接口

**Parameters:**
id – usr_timeout_add时分配的id号
msec – 超时时间， 单位：毫秒

**Returns:**
0

void **usr_timer_del**(u16 id)
usr_timer删除接口

**Note**
注意与usr_timer_add成对使用

**Parameters:**
id – usr_timer_add时分配的id号

void **usr_timeout_del**(u16 id)
usr_timeout删除接口

**Note**
注意与usr_timeout_add成对使用

**Parameters:**
id – usr_timerout_add时分配的id号

void **usr_timer_dump**(void)
usr_time输出调试信息

**Note**
调试时可用，将输出所有被add定时器的id及其时间(msec)

# 7.30. 系统启动时间

**Overview**

在sdk的打印宏 `CONFIG_DEBUG_ENABLE` 关闭的情况下，分别测试demo_hello跑sfc模式、wifi_camera跑sfc模式、wifi_camera跑sdram模式的系统启动时间。

系统详细的启动流程参考：sdk启动流程章节

## 7.30.1. demo_hello跑sfc的启动时间

运行demo_hello工程工作在sfc模式下，sys_clk为320MHz，hsb_clk为160MHz，lsb_clk为53.3MHz，sfc_clk为80MHz，通过逻辑分析仪测试系统的启动时间如下：

![](img\210.png)

## 7.30.2. wifi_camera跑sfc的启动时间

运行wifi_camera工程仅工作sfc模式下，关闭sdram，sys_clk为320MHz，hsb_clk为160MHz，lsb_clk为53.3MHz，sfc_clk为80MHz，通过逻辑分析仪测试系统的启动时间如下：

![](img\211.png)

Important

①运行wifi_camera工程仅工作sfc模式下，关闭sdram，系统启动uboot过程中的具体时间划分如下：

| **阶段**                      | **时间** | **主要耗时**   |
| ----------------------------------- | -------------- | -------------------- |
| uboot启动开始-sys_clk_init开始      | 4.8ms          | get_boot_cmdline函数 |
| sys_clk_init开始-sys_clk_init结束   | 5.0ms          | sys_clk_init函数     |
| sys_clk_init结束-sfc_mode_boot开始  | 3.6ms          | 耗时较分散           |
| sfc_mode_boot开始-sfc_mode_boot跳转 | 3.8ms          | get_trim_value函数   |
| sfc_mode_boot跳转-sdk中main开始     | 2.9ms          | 数据初始化           |

②运行wifi_camera工程工作sfc模式下，并打开sdram，测试系统启动uboot的总时间会增加23ms，具体时间划分如下：

| **阶段**                      | **时间** | **主要耗时**   |
| ----------------------------------- | -------------- | -------------------- |
| uboot启动开始-sys_clk_init开始      | 20.5ms         | get_boot_cmdline函数 |
| sys_clk_init开始-sys_clk_init结束   | 6.4ms          | sys_clk_init函数     |
| sys_clk_init结束-sfc_mode_boot开始  | 4.0ms          | 耗时较分散           |
| sfc_mode_boot开始-sfc_mode_boot跳转 | 3.8ms          | get_trim_value函数   |
| sfc_mode_boot跳转-sdk中main开始     | 8.5ms          | 数据初始化           |

## 7.30.3. wifi_camera跑sdram的启动时间

运行wifi_camera工程仅工作在sdram模式下，关闭sfc，sys_clk为320MHz，sdram_clk为192MHz，hsb_clk为160MHz，lsb_clk为53.3MHz，通过逻辑分析仪测试系统的启动时间如下：

![](img\212.png)

# 7.31. 获取代码运行时间的方法

**Overview**

提供获取代码运行时间(精确到秒或毫秒)的API和应用示例。

## 7.31.1. API参考

```
/**
 *@brief 获取系统的滴答秒（系统启动以来经过的秒）
 */
u32 timer_get_sec(void)

/**
 *@brief 获取系统的滴答毫秒（系统启动以来经过的毫秒）
 */
u32 timer_get_ms(void)
```

## 7.31.2. 应用实例

以如下伪代码为例，说明获取代码运行时间（精确到秒或毫秒）的方法：

```
void run_time_sec_test()
{
  u32 start_time = timer_get_sec(); //获取起始滴答秒
  test_part_code();                 //需要测试运行时间的代码
  u32 end_time = timer_get_sec();   //获取结束滴答秒
  printf("run_time = %d s\n", end_time - start_time); //打印获取的代码运行时间(精确到秒)
}


void run_time_ms_test()
{
  u32 start_time = timer_get_ms();  //获取起始滴答毫秒
  test_part_code();                 //需要测试运行时间的代码
  u32 end_time = timer_get_ms();    //获取结束滴答毫秒
  printf("run_time = %d ms\n", end_time - start_time); //打印获取的代码运行时间（精确到毫秒）
}
```

# 7.32. 库符号重定位到指定段方法

**Overview**

介绍如何将库代码定位到指定段。

---

## 7.32.1. 操作流程

为了节省内存或者提升性能, 用户想把整个库例如orig_libx.a文件的全部代码定位到内部ram或者flash或者sdram:

* 新建一个批处理, 执行 `tools/utils/` 目录下 `override-seg.exe --input orig_libx.a --output libx.a --code_seg ".libx.text" --const_seg ".libx.rodata"`
* 在对应cpu目录下的库目录下（如： `include_lib/liba/wl82` ） 把 `orig_libx.a` 替换 `libx.a`
* 如果芯片封装有SDRAM, 想把库代码放置SDRAM运行的情况,在对应cpu目录下(如： `cpu/wl82/` )的 `sdk_ld_sdram.c` 配置如下图:
* 如果芯片封装有SDRAM, 想把库代码放置内部ram运行的情况,在对应cpu目录下(如： `cpu/wl82/` )的 `sdk_ld_sdram.c` 配置如下图:
* 如果芯片封装没有SDRAM, 想把库代码放置内部ram运行的情况,在对应cpu目录下(如： `cpu/wl82/` )的 `sdk_ld_sfc.c` 配置如下图:
* 如果芯片封装没有SDRAM, 想把库代码放置FLASH运行的情况,在对应cpu目录下(如： `cpu/wl82/` )的 `sdk_ld_sfc.c` 配置如下图：

**Warning**

如果出现异常报错pc_limit_err，是由于程序代码跑到其他段系统误以为跑飞，需要把debug_init的pc_rang_limit注释掉。

# 7.33. 源文件变量符号重定位到指定段的方法

**Overview**

介绍如何将C程序内的变量重定位到指定段。

## 7.33.1. 应用示例

**示例演示：**

首先进入想要指定的.C源文件中，比如 `apps/demo/demo_DevKitBoard/app_main.c` ，在 `app_main.c` 的头部加上如下设置：

> ```
> #pragma bss_seg(".appmain_bss")
> #pragma data_seg(".appmain_data")
> #pragma const_seg(".appmain_const")
> #pragma code_seg(".appmain_code")
> #pragma str_literal_override(".appmain_str")
> ```

上述代码主要是用来指定bss，data等变量在ld文件中存放的节，可根据自身需求定义节名称。示例中将节名称定义为 `appmain_xx` (xx分别为bss，data，const，code，str)。

接着进入 `cpu/wl82/sdk_ld.c` 来指定 `appmain_xx` 存放的段。比如本示例中将 `.appmain_data` 、 `.appmain_const` 、 `.appmain_str` 、 `.appmain_code` 节指定到 `.ram0_data` 中，将 `.appmain_bss` 节指定到sdram的 `.bss` 段中。

![](img\217.png)

![](img\218.png)

再在 `app_main.c` 中，分别定义：一个未初始化的全局数组、一个已初始化的全局数组、const常量一个字符串，并 查看使用细节，即每个函数、变量的存放位置和大小

筛选出 `demo_DevKitBoard/app_main.c` 的变量。

![](img\219.png)

其中，task_info_table为const数组，ts_array_data为已初始化的全局数组，ts_string为字符串，均被指定到 `ram0_data` 中，而ts_array_data为未初始化的全局数组，被指定到 `.bss` 段中。

# 7.34. SDK 库说明

**Overview**

介绍SDK中每个库的作用

## 7.34.1. 库功能说明

| 库名称                                     | 功能说明                                                              |
| ------------------------------------------ | --------------------------------------------------------------------- |
| fs.a                                       | 文件系统                                                              |
| system.a                                   | 操作系统、内存管理、日志管理、系统定时器等系统一系列接口              |
| cfg_tool.a                                 | VM管理系统                                                            |
| cpu.a                                      | 底层设备驱动                                                          |
| update.a                                   | 固件升级                                                              |
| common_lib.a                               | 补充libc.a一些缺失的标准库函数                                        |
| ui.a res.a font.a ui_draw.a                | UI界面功能                                                            |
| audio_server.a                             | 音频编解码的中间层服务                                                |
| echo_server.a                              | 混响功能的中间层服务                                                  |
| lib_mp3_dec.a                              | MP3格式解码库                                                         |
| lib_mp3_enc.a                              | MP3格式编码库                                                         |
| lib_m4a_dec.a                              | M4A和AAC格式解码库                                                    |
| lib_aac_enc.a                              | AAC格式编码库                                                         |
| lib_opus_dec.a                             | OPUS格式解码库                                                        |
| lib_opus_enc.a                             | OPUS格式编码库                                                        |
| libspeex.a                                 | SPX格式编解码库                                                       |
| lib_wma_dec.a                              | WMA格式解码库                                                         |
| lib_wma_dec_hw.a                           | 带硬件FFT优化的WMA格式解码库                                          |
| lib_ape_dec.a                              | APE格式解码库                                                         |
| lib_flac_dec.a                             | FLAC格式解码库                                                        |
| lib_wav_dec.a                              | WAV格式解码库                                                         |
| lib_dts_dec.a                              | DTS格式解码库                                                         |
| lib_amr_dec.a                              | AMR格式解码库                                                         |
| lib_amr_enc.a                              | 8K采样率AMR格式编码库                                                 |
| lib_amrwb_enc.a                            | 16K采样率AMR格式编码库                                                |
| lib_adpcm_enc.a                            | ADPCM格式编码库                                                       |
| libvad.a                                   | 语音活动检测                                                          |
| lib_rmono2stereo.a                         | 单声道数据立体声化（混响功能需要）                                    |
| lib_reverb_cal.a                           | 混响处理（混响功能需要）                                              |
| lib_pitchshifter.a                         | 移频变声等魔音处理（混响功能需要）                                    |
| lib_howling.a                              | 啸波抑制（混响功能需要）                                              |
| lib_pitch_speed.a                          | 音频变速变调功能                                                      |
| liblimiter.a                               | 软件限幅器                                                            |
| libaec.a                                   | 回声消除                                                              |
| lib_usb_syn.a                              | UAC时钟信号同步处理                                                   |
| lib_sbc_eng.a                              | SBC格式音频数据能量检测                                               |
| lib_roobo_aec.a                            | roobo打断唤醒算法                                                     |
| lib_roobo_fig.a                            | roobo打断唤醒算法授权管理                                             |
| lib_wanson_asr.a                           | 华镇打断唤醒算法                                                      |
| libauth.a libauth_aisp.a                   | 思必驰打断唤醒算法授权管理                                            |
| aisIntlib_single_xiaoai.a libaisp_single.a | 思必驰单麦打断唤醒算法（小爱同学唤醒词）                              |
| aisIntlib_dual_xiaoai.a libaisp_dual.a     | 思必驰双麦打断唤醒算法（小爱同学唤醒词）                              |
| video_rec_server.a                         | 视频录像编码的中间层服务                                              |
| video_dec_server.a                         | 视频播放解码的中间层服务                                              |
| net_server.a                               | 视频网络实时流封装器                                                  |
| stream_media_server.a                      | 视频实时流RTSP回放                                                    |
| ai_server.a                                | 第三方AI平台SDK的中间层管理接口                                       |
| profile.a                                  | 第三方AI平台license授权管理                                           |
| btctrler.a                                 | 蓝牙协议栈（底层驱动）                                                |
| btstack.a                                  | 蓝牙协议栈                                                            |
| lib_sig_mesh.a                             | ble mesh组网协议                                                      |
| crypto_toolbox_Osize.a                     | 蓝牙专用加解密工具箱                                                  |
| lib_ccm_aes.a                              | ble配对AES硬件加解密                                                  |
| wl_rf_common.a                             | RF模拟初始化接口                                                      |
| cJSON.a json.a                             | 两套JSON格式构造和解析接口（第三方开源）                              |
| ftpclient.a                                | FTP协议客户端                                                         |
| ftpserver.a                                | FTP协议服务端                                                         |
| http_cli.a                                 | HTTP协议客户端                                                        |
| http_server.a                              | HTTP协议服务端                                                        |
| lib_mqtt.a                                 | MQTT客户端协议                                                        |
| iperf.a                                    | iperf网络带宽测速工具（第三方开源）                                   |
| libmpeg.a                                  | M3U8格式解析（第三方开源）                                            |
| kcp.a                                      | KCP协议                                                               |
| libairplay.a libmdns.a                     | AIRPLAY协议                                                           |
| libdlna.a                                  | DLNA投屏协议（音箱功能）                                              |
| libcoap.a                                  | COAP协议（第三方开源）                                                |
| websocket.a                                | WEBSOCKET协议                                                         |
| libJlCloud.a                               | 杰理平台（第三方AI SDK）                                              |
| libecho_cloud.a                            | 回声云平台（第三方AI SDK）                                            |
| libdui.a                                   | 思必驰平台（第三方AI SDK）                                            |
| libduer-device.a                           | 小度平台（第三方AI SDK）                                              |
| libdcl.a                                   | 义语平台（第三方AI SDK）                                              |
| libaliyun.a                                | 阿里云平台（第三方AI SDK）                                            |
| libtelecom.a                               | 电信云平台（第三方AI SDK）                                            |
| libtencent.a                               | 腾讯云平台（第三方AI SDK）                                            |
| libturing.a                                | 图灵平台（第三方AI SDK）                                              |
| libvtbk.a libwt.a                          | 玩瞳绘本识别平台（第三方AI SDK）                                      |
| tmallgenie.a tmallgenie_todo.a             | 天猫精灵平台（第三方AI SDK）                                          |
| zliblite.a                                 | zip压缩解压（第三方开源）                                             |
| pixel_flow.a                               | 杰理飞控算法                                                          |
| page_turning_dect.a                        | 杰理翻页检测算法                                                      |
| network_download.a                         | 网络歌曲下载接口                                                      |
| lib_sound_wave.a                           | 声波识别                                                              |
| libqrcode.a                                | 二维码识别                                                            |
| mongoose.a                                 | 为客户端和服务端实现HTTP等网络协议的事件驱动的非阻塞API（第三方开源） |
| mbedtls.a                                  | 嵌入式SSL/TLS功能（第三方开源）                                       |
| uip.a                                      | 轻量级TCP/IP协议栈（第三方开源）                                      |
| wolfmqtt.a                                 | MQTT客户端（第三方开源）                                              |
| wolfssl.a                                  | 嵌入式SSL/TLS功能（第三方开源）                                       |
| lwip_2_1_2.a lwip_2_1_3.a                  | TCP/IP协议栈（第三方开源）                                            |
| lwip_2_1_2_sfc.a lwip_2_1_3_sfc.a          | TCP/IP协议栈（第三方开源）（内存优化版）                              |
| hsm.a                                      | WIFI中间层状态机和事件回调管理                                        |
| wpasupplicant.a                            | WEP,WPA/WPA2和WAPI无线协议和加密认证的                                |
| wl_wifi.a                                  | WIFI协议栈（支持AP+STA模式)                                           |
| wl_wifi_sfc.a                              | WIFI协议栈（支持AP+STA模式)（内存优化版）                             |
| wl_wifi_ap.a                               | WIFI协议栈（支持AP模式)                                               |
| wl_wifi_ap_sfc.a                           | WIFI协议栈（支持AP模式)（内存优化版）                                 |
| wl_wifi_sta.a                              | WIFI协议栈（支持STA模式)                                              |
| wl_wifi_sta_sfc.a                          | WIFI协议栈（STA模式)（内存优化版）                                    |

# 7.35. 代码运行在FLASH或SDRAM配置方法

**Overview**

介绍如何将代码运行在FLASH或DRAM的方法，同时如何指定库代码放到内存中运行，或指定某些函数位于SDRAM或RAM的方法。

## 7.35.1. 配置说明

**（1）如果芯片封装没有SDRAM, 代码只能够跑FLASH的情况：**

* 在SDK主工程cbp文件或者主工程Makefile加上宏定义 `CONFIG_SFC_ENABLE` 和 `CONFIG_NO_SDRAM_ENABLE`

**（2）如果芯片封装有SDRAM, 代码放置FLASH运行的情况：**

* 在SDK主工程cbp文件或者主工程Makefile加上宏定义 `CONFIG_SFC_ENABLE`
* 在SDK主工程cbp文件或者主工程Makefile去掉宏定义 `CONFIG_NO_SDRAM_ENABLE`

**（3）如果芯片封装有SDRAM, 代码放置SDRAM运行的情况：**

* 在SDK主工程cbp文件或者主工程Makefile去掉宏定义 `CONFIG_SFC_ENABLE` 和 `CONFIG_NO_SDRAM_ENABLE`

**（4）指定库代码放到指定内存运行的方法:**

* 具体请参考库符号重定位到指定段方法

**（5）代码跑flash或者代码跑sdram的情况下, 指定函数放到内部ram运行的方法：**

* 在函数定义前面加上 `SEC_USED(.volatile_ram_code)`，具体请参考 MEMORY

**（6）芯片封装有SDRAM,代码跑flash下, 指定函数放到sdram运行的方法：**

* 在函数定义前面加上 `SEC_USED(.data)`

# 7.36. SDRAM配置

**Overview**

介绍sdram的常规配置

## 7.36.1. SDRAM使能以及SDRAM大小配置

* 芯片封装不带sdram时，在SDK主工程cbp文件或者主工程Makefile加上宏定义 `CONFIG_NO_SDRAM_ENABLE`。
* 芯片封装带有sdram时，在SDK主工程cbp文件或者主工程Makefile去掉宏定义 `CONFIG_NO_SDRAM_ENABLE`，并在 `board_config.h` 中修改 `__SDRAM_SIZE__`，请根据实际内存修改。

**Note**

芯片不带sdram，去掉宏定义 CONFIG_NO_SDRAM_ENABLE 打开sdram，则会跑不起，当实际封装的sdram大小为8M却配置__SDRAM_SIZE__=2M，则系统正常运行后，程序使用超过2M大小地址会出现异常死机等现象。

## 7.36.2. SDRAM时钟配置

sdram时钟在可以在对应CPU目录下的 `isd_config_rule.c` 文件中 `SDRAM_CL=3;` 修改时钟配置 sdram时钟应根据系统时钟来配置，SYS_CLK<=240M或=320M时：[0-120M,1-160M,2-192M,3-240M,4-246M,5-252M,6-258M,7-264M,8-270M,9-276M,10-282M,11-288M]，详见下图。

**Note**

sdram时钟尽量<=192M，大于192M以上时钟sdram稳定性性不高，特别是240M以上，温度漂移对sdram稳定性影响较大。 一般情况下SDK默认192M，用户只能减小sdram时钟，不能随意增大，建议使用默认即可。

> ① `isd_config_rule.c` 文件中 `SDRAM_PLL3_NOUSB_EN` 和 `SDRAM_PLL3_EN` 选项全配置0。 当系统时钟SYS_CLK>320M并且 < 384M时：SDRAM时钟为SYS_CLK*1.5/2，SYS_CLK >= 384M时：SDRAM时钟为SYS_CLK/2。 当系统时钟SYS_CLK>240M并且 < 320M时：SDRAM时钟为SYS_CLK*1.5/2；SDRAM时钟为SYS_CLK/2或SYS_CLK*1.5/2，此时 `SDRAM_CL=2` 更改无效。 系统时钟配置详情 系统各模块时钟介绍。
>
> ② `isd_config_rule.c` 文件中 `SDRAM_PLL3_NOUSB_EN` 和 `SDRAM_PLL3_EN` 选项其中一个为1。 此时系统时钟：任意值（120M-396M），sdram时钟固定在240M、192M、160M、120M等时钟。
>
> 如：当需要系统时钟为396M：修改配置为 `SYS_CLK=396MHz;`。 sdram时钟配置在 `isd_config_rule.c` 文件中 `SDRAM_PLL3_EN=0;` 和 `SDRAM_PLL3_NOUSB_EN=0;` 选项， **注意** ：两个选项只能开启其中1个。 当开启 `SDRAM_PLL3_EN=1;` 则sdram强制为240M，SDK程序  **允许使用硬件USB2.0接口** ，当开启 `SDRAM_PLL3_NOUSB_EN=1;` ， 则sdram跟随 `SDRAM_CL=2;` 的选项选择对应时钟，此时 `SDRAM_DQ_DLY_TRM=3;` 也需要更改对应值，SDK程序  **禁止使用硬件USB2.0接口** 。
>
> **注意** ：系统时钟>320M,则高速时钟分频系数为2，即 `HSB_DIV=2;` ，否则系统可能出现无法正常运行，特别是系统时钟>=360M。

# 7.37. 系统各模块时钟介绍

> **Overview**
>
> 介绍系统的时钟结构
>
> ---

## 7.37.1. 时钟类型

> * `sys_clk：` 系统时钟，可以在对应CPU目录下（如： `cpu/wl82/tools` ）的 `isd_config_rule.c` 文件中 `SYS_CLK=320MHz;` 修改配置
> * `sdram_clk：` sdram时钟，当芯片不带sdram，则该时钟为0，可以在对应CPU目录下（如： `cpu/wl82/tools` ）的 `isd_config_rule.c` 文件中 `SDRAM_CL=3;` 修改配置
> * `hsb_clk：` 高速时钟（系统时钟分频），可以在对应CPU目录下（如： `cpu/wl82/tools` ）的 `isd_config_rule.c` 文件中 `HSB_DIV=1;` 修改配置
> * `lsb_clk：` 低速时钟（高速时钟分频），可以在对应CPU目录下（如： `cpu/wl82/tools` ）的 `isd_config_rule.c` 文件中 `LSB_DIV=2;` 修改配置
> * `sfc_clk：` flash时钟（高速时钟分频，正常跑系统时从flash读取程序的时钟），可以在对应CPU目录下（如： `cpu/wl82/tools` ）的 `isd_config_rule.c` 文件中 `[SYS_CFG_PARAM]` 的 `#clk [0-255]` 修改配置，如sfc_clk分频系数为2:SPI=2_1_0_0; sfc_clk分频系数为4:SPI=2_3_0_0;
>
> Note
>
> 上述的hsb_clk、lsb_clk、sfc_clk的配置项是对应时钟分频系数，计算方法为：时钟/(分频系数+1)，写0则没有分频（即1分频），1则为2个分频。 注意事项：一般系统：sys_clk为160M-320M，hsb_clk应为80M-160M，lsb_clk应为30M-60M，sfc_clk应为60M-80M，时钟越低越有助于降低系统功耗。
>
> ---

## 7.37.2. 高低速（HSB/LSB）时钟硬件模块

> **AC790x型号**
>
> 高速时钟硬件模块：SFC、SDRAM、PSRAM、AES、DCP、JPEG、ISC。 低速时钟硬件模块：USB、SD、SPI、IIC、PAP、TIME、PWM、ADC、DAC、UART、SHA、RDEC、IR、CTMU、PLINK、ALINK、AUDIO、ENC、SBC、SRC、WIFI、BT、DMA_COPY、EQ等。
>
> **AC791x型号**
>
> 高速时钟硬件模块：SFC、SDRAM、PSRAM、AES、DCP、JPEG、ISC、IMD、EMI。 低速时钟硬件模块：USB、SD、SPI、IIC、PAP、EMI、TIME、PWM、ADC、DAC、UART、SHA、RDEC、IR、CTMU、PLINK、ALINK、AUDIO、ENC、SBC、SRC、WIFI、BT、DMA_COPY、EQ等。
>
> Important
>
> 通过对芯片进行温度范围-40℃到80℃测试,探测芯片最高稳定运行频率,得到如下测试结论：
>
> ①默认推荐系统频率320MHz和SDRAM频率192MHz；
>
> ②若有更高性能要求，系统频率可设为396MHz,和SDRAM频率可设为240MHz(由于内封SDRAM有些不支持，生产会导致较多不良率)，和内核电压档位设为最高挡位1.38V。
>
> 当需要系统时钟为396M：修改配置为 `SYS_CLK=396MHz;`
>
> sdram时钟配置在 `isd_config_rule.c` 文件中 `SDRAM_PLL3_EN=0;` 和 `SDRAM_PLL3_NOUSB_EN=0;` 选项， **注意** ：两个选项只能开启其中1个。 当开启 `SDRAM_PLL3_EN=1;` 则sdram强制为240M，SDK程序  **允许使用硬件USB2.0接口** 。 当开启 `SDRAM_PLL3_NOUSB_EN=1;` ，则sdram跟随 `SDRAM_CL=2` 的选项选择对应时钟，此时 SDRAM_DQ_DLY_TRM=3; 也需要更改对应值，SDK程序  **禁止使用硬件USB2.0接口** 。
>
> **注意** ：系统时钟>320MM,则高速时钟分频系数为2，即 ``HSB_DIV=2;``，否则系统可能出现无法正常运行，特别是系统时钟>=360M。。
>
> ③若客户系统频率配置超过396MHz或者SDRAM频率配置超过192MHz，存在极大的风险，生产上必然会有不良芯片；

# 7.38. 系统动态时钟

**Overview**

介绍系统的动态时钟

---

## 7.38.1. 动态时钟API

* 系统时钟动态调节：时钟可以在SDK中根据用户需求进行系统时钟和sdram时钟进行调节，使用API头文件 `include_lib/driver/cpu/wl82/asm/clock.h`。使用的API接口如下：

  ```
  //系统空闲模式时钟切换函数：系统和Sdram时钟固定在24M
  voidsystem_clock_set_idle(void);

  //系统时钟切换函数：时钟参数，clk范围：24000000 - 396000000 （24M-396M）
  voidsystem_clock_set(u32clk);

  //系统时钟+sdram时钟切换：sys_clk时钟参数，范围：24000000 - 396000000 （24M-396M）；sdram_clk时钟参数，范围：24000000 - 244000000 （24M-244M）
  voidsystem_sdram_clock_set(u32sys_clk,u32sdram_clk);

  //sdram时钟切换：clk时钟参数，范围：24000000 - 244000000 （24M-244M）
  voidsdram_clock_set(u32clk);

  //恢复SDK默认系统+sdram时钟：恢复到系统上电的初始值
  voidsystem_clock_set_default(void);
  ```

Note

同时更改系统时钟(sys_clk)和sdram时钟(sdram_clk)时，尽量系统和sdram时钟差别不能太大，如系统24M、sdram 120M是不可行的；在系统时钟<160M时，建议sdram时钟和系统时钟一样，另外使用sdram同时不能频繁切换sdram时钟，否则可能出现不可预估结果。 在SDK使用API动态修改时钟，需要注意：不是所有的频率都可以设置，关键在 `isd_config_rule.c` 文件中选择：

①SDRAM_PLL3_EN = 0，且 SDRAM_PLL3_NOUSB_EN = 0； sys_clk = 320M、240M、192M、160M、120M、96M、48M、40M、24M，则SDK动态修改系统时钟均只能在这些时钟中选择，sdram时钟可在24M到244M选择任意一个即可，即24M <= sdram_clk <= 244M。 240M < sys_clk < 384M，则SDK动态修改系统时钟：240M < sys_clk < 384M，sdram时钟无法修改，此时sdram_clk=sys_clk*1.5/2。 384M <= sys_clk <= 396M，则SDK动态修改系统时钟：384M <= sys_clk <= 396M，sdram时钟无法修改，此时sdram_clk=sys_clk/2。

②SDRAM_PLL3_EN = 1，且 SDRAM_PLL3_NOUSB_EN = 0； 24M < sys_clk < 396M，但是sdram时钟固定240M，因此系统时钟调节时候不能过低。

③SDRAM_PLL3_EN = 0，且 SDRAM_PLL3_NOUSB_EN = 1； 24M < sys_clk < 396M，24M < sdram_clk < 244M，但是SDK不能使用USB2.0接口。

Important

> 工程运行过程中，切换系统时钟所消耗的时间参考如下：

| **时钟切换** | **时间** |
| ------------------ | -------------- |
| 24MHz->320MHz      | 6.20ms         |
| 320MHz->24MHz      | 4.05ms         |
| 24MHz->32MHz       | 7.16ms         |
| 240MHz->320MHz     | 3.21ms         |

> 从系统时钟切换测试的消耗时间可知，如果原始时钟频率较低，则切换时间就较长。

# 7.39. 系统休眠

**Overview**

介绍系统休眠

---

## 7.39.1. 系统休眠配置与API

* 系统休眠配置：配置文件在 `app_config.h` ，参考： `apps/wifi_story_machine/include/app_config.h`。
  > * wifi处于STA模式或者开启蓝牙情况下，整个系统自动休眠。
  >   > ①在打开app_config.h打开如下宏，没有则添加上 `#define CONFIG_LOW_POWER_ENABLE //低功耗开关` 。
  >   >
  >   > ②在打开app_config.h修改 `TCFG_LOWPOWER_LOWPOWER_SEL` 宏，没有则添加上 `#define TCFG_LOWPOWER_LOWPOWER_SEL (RF_SLEEP_EN | SYS_SLEEP_EN | RF_FORCE_SYS_SLEEP_EN)`。
  >   >
  >   > Note
  >   >
  >   > 一般只开启 `(RF_SLEEP_EN)` 或者 `(RF_SLEEP_EN | SYS_SLEEP_EN | RF_FORCE_SYS_SLEEP_EN)` ，
  >   >
  >   > `SYS_SLEEP_EN` ：操作系统时休眠使能，需要使操作系统空闲休眠或跟随RF休眠的必须使能。
  >   >
  >   > `SYS_SLEEP_BY_IDLE` ：允许操作系统时空闲休眠使能，前提使能 `SYS_SLEEP_EN`。
  >   >
  >   > `RF_SLEEP_EN` ：允许wifi和蓝牙的RF休眠。
  >   >
  >   > `RF_FORCE_SYS_SLEEP_EN` ：允许RF休眠时强制操作系统休眠，前提使能 `SYS_SLEEP_EN`。
  >   >
  >   > 操作系统空闲休眠则RF必须处于休眠。以上配置是根据系统状态进行的休眠，最好的效果是 `(RF_SLEEP_EN | SYS_SLEEP_EN | RF_FORCE_SYS_SLEEP_EN)` 。
  >   >
  >   > ③在打开board.c需添加上：低功耗配置和版籍电源初始化加上power_init()函数，参考 `apps/wifi_story_machine/board/wl82/board_7911B.c`。
  >   >
  >   > ```
  >   > /************************** LOW POWER config ****************************/
  >   > static const struct low_power_param power_param = {
  >   >         .config         = TCFG_LOWPOWER_LOWPOWER_SEL,
  >   >         .btosc_disable  = TCFG_LOWPOWER_BTOSC_DISABLE,         //进入低功耗时BTOSC是否保持
  >   >         .vddiom_lev     = TCFG_LOWPOWER_VDDIOM_LEVEL,          //强VDDIO等级,可选：2.2V  2.4V  2.6V  2.8V  3.0V  3.2V  3.4V  3.6V
  >   >         .vddiow_lev     = TCFG_LOWPOWER_VDDIOW_LEVEL,          //弱VDDIO等级,可选：2.1V  2.4V  2.8V  3.2V
  >   >         .vdc14_dcdc     = TRUE,                                                            //打开内部1.4VDCDC，关闭则用外部
  >   >         .vdc14_lev              = VDC14_VOL_SEL_LEVEL,                             //VDD1.4V配置
  >   >         .sysvdd_lev             = SYSVDD_VOL_SEL_LEVEL,                            //内核、sdram电压配置
  >   >         .vlvd_enable    = TRUE,                                //TRUE电压复位使能
  >   >         .vlvd_value             = VLVD_SEL_25V,                        //低电压复位电压值
  >   > };
  >   >
  >   > static void board_power_init(void)
  >   > {
  >   >         power_init(&power_param);//电源初始化，包括休眠的参数
  >   >         ....
  >   > }
  >   > ```
  >   >
  > * 强制整个系统休眠API函数
  >   > ```
  >   > u8low_power_all_group_force_sleep(u32us);//强制休眠API函数
  >   > ```
  >   >
  >   > Note
  >   >
  >   > **注意** ：强制休眠API函数，单位us，返回值：0正常休眠，大于0被io唤醒（值和board.c的唤醒IO配置的.attribute相关），小于0休眠失败（两次休眠时间间隔小于10ms，应用层需要在返回值小于0情况下，可多次尝试请求休眠，或者延时10ms后即可）
  >   >
  >   > `low_power_all_group_force_sleep()` 休眠函数使用不能使用在开启蓝牙，可以使用在开启wifi，但开启wifi情况下需要注意掉线等问题（休眠时间不能过长，一般1秒内） 使用该函数是wifi的RF和操作系统都会进入休眠状态。
  >   >
  > * 禁止和允许wifi或蓝牙的RF硬件自动休眠API函数
  >   > ```
  >   > voidlow_power_hw_unsleep_lock(void);//RF硬件禁止休眠
  >   >
  >   > voidlow_power_hw_unsleep_unlock(void);//RF硬件允许休眠
  >   > ```
  >   >
  >   > Note
  >   >
  >   > RF硬件休眠的禁止和允许函数，和强制休眠函数 `low_power_all_group_force_sleep()` 无关，当强制休眠则禁止RF硬件休眠函数也无效。 当需要禁止RF硬件自动休眠，则调用low_power_hw_unsleep_lock(); 当需要允许RF硬件自动休眠，则调用low_power_hw_unsleep_unlock(); 当开启禁止RF硬件自动休眠，则操作系统不会进入休眠。
  >   >
  > * 设置系统idle空闲休眠时间API函数
  >   > ```
  >   > voidpower_set_sys_sleep_internal_us(u32sys_sleep_internal_us);//设置系统的idle空闲休眠时间
  >   > ```
  >   >
  >   > Note
  >   >
  >   > 设置系统空闲休眠时间和操作系统相关，只有当操作系统都处于空闲状态才能进入休眠，休眠时间也根据操作系统空闲时间进行休眠，一般为20ms-50ms，用户需要加大休眠时间达到降低功耗，则使用power_set_sys_sleep_internal_us()函数自定义时间， 同时app_config.h的 `TCFG_LOWPOWER_LOWPOWER_SEL` 需要或上 `SYS_SLEEP_BY_IDLE` 和 `SYS_SLEEP_EN`。
  >   >
  >

## 7.39.2. 低功耗时候进行io保持

* 参考 `apps/wifi_story_machine/board/wl82/board_7911B.c` 在使用的板级文件board.c中对于进低功耗前和退出低功耗时候的回调函数中进行io的配置

```
//退出低功耗时候回调函数
static void sleep_exit_callback(u32 usec)
{

}

//进入低功耗前回调函数，此函数禁止添加打印
static void sleep_enter_callback(u8  step)
{
if (step == 1) {
        dac_power_off();
} else {  //在此处step == 2进行保持某些 IO 状态
                gpio_direction_output(IO_PORTA_07, 1); //进低功耗前设置为高电平，硬件外部没有上下拉，则使用内部上下拉：根据输出1开上拉关下拉，输出0关上拉开下拉
                gpio_set_pull_up(IO_PORTA_07, 1);      //打开上拉
                gpio_set_pull_down(IO_PORTA_07, 0);    //关下拉
        gpio_set_direction(IO_PORTA_07, 1);    //设置引脚方向为输入
        gpio_set_die(IO_PORTA_07, 0);          //设置引脚为跟电压相关的模拟功能
        }
}

//设置进出低功耗时回调函数
static void board_power_init(void)
{
        ...
        ...
        power_init(&power_param);
power_set_callback(TCFG_LOWPOWER_LOWPOWER_SEL, sleep_enter_callback, sleep_exit_callback, NULL); //第三个参数为设置进soft poweroff软关机前配置，此处为说明休眠低功耗powerdown，故设为空
        ...
        ...
}
```

* 如果想保证修改之后不被任何地方更改 IO 的值，则可以加 gpio_latch_en()函数锁定，前提修改先需要解锁 gpio_latch_en(x, 0)，修改后锁住 gpio_latch_en(x,1)，才能有效，注意：在修改 IO 状态先务必解锁对应 IO 才有效。应用层在休眠后时，需要保持某些 IO 状态，在 power_set_callback()函数第三个参数函数里面完成，如下sleep_exit_callback()函数进行恢复

```
//退出低功耗时候回调函数
static void sleep_exit_callback(u32 usec)
{
        gpio_latch_en(IO_PORTA_07, 0);         //解锁PA7
}

//进入低功耗前回调函数，此函数禁止添加打印
static void sleep_enter_callback(u8  step)
{
if (step == 1) {
        dac_power_off();
} else {
                gpio_latch_en(IO_PORTA_07, 0);         //解锁PA7
                gpio_direction_output(IO_PORTA_07, 1); //进低功耗前设置为高电平，硬件外部没有上下拉，则使用内部上下拉：根据输出1开上拉关下拉，输出0关上拉开下拉
                gpio_set_pull_up(IO_PORTA_07, 1);      //打开上拉
                gpio_set_pull_down(IO_PORTA_07, 0);    //关下拉
        gpio_set_direction(IO_PORTA_07, 1);    //设置引脚方向为输入
        gpio_set_die(IO_PORTA_07, 0);          //设置引脚为跟电压相关的模拟功能
                gpio_latch_en(IO_PORTA_07, 1);         //锁定PA7
        }
}
```

## 7.39.3. 低功耗IO唤醒时获取具体的IO唤醒源

* 板级配置需要设置IO唤醒源

```
#define PORT_WAKEUP_IO                  IO_PORTB_01                                     //软关机和休眠唤醒引脚
#define PORT_WAKEUP_NUM                 (PORT_WAKEUP_IO/IO_GROUP_NUM)//默认:0-7:GPIOA-GPIOH, 可以指定0-7组

static const struct port_wakeup port0 = {
.edge       = FALLING_EDGE,                            //唤醒方式选择,可选：上升沿\下降沿
.attribute  = BLUETOOTH_RESUME,                        //不能屏蔽
.iomap      = PORT_WAKEUP_IO,                          //唤醒口选择
.low_power      = POWER_SLEEP_WAKEUP | POWER_OFF_WAKEUP,   //低功耗IO唤醒,不需要写0
};

static void io_wakeup_callback(void)
{
        //休眠时IO唤醒会进去这个回调函数
        int wakeup_io = hw_power_get_last_wakeup_io();  //获取上一次IO唤醒源
}

static void board_power_init(void)
{
        power_init(&power_param);

        set_port_wakeup_cb(io_wakeup_callback);         //需要设置IO唤醒回调函数

        ....
}
```

# 7.40. 操作系统单双核使用方法

## 7.40.1. 操作说明

* SDK默认运行双核操作系统的方法, 所有就绪任务按照哪个核心空闲分配到哪个核心调度的策略运行;
* 在某些情况,用户增加的功能对CPU占据特别大,或者对时序要求特别苛刻,可以把双核分开使用, 一个核跑操作系统,另外一个核专门跑用户功能,配置方法如下:
  * 1.修改 include_libdrivercpu对应cpu目录asmcpu.h的宏定义 #define CPU_CORE_NUM 1
  * 2.寻求杰理技术团队替换单核专用的system.a库
  * 3.在 app_main.c的 irq_info_table 显式增加需要安装到核1的中断,其余没有显式增加的中断会全部安装到核0
  * 4.最后核0运行操作系统, 核1运行到cpu1_main,用户可以在此增加功能

## 7.40.2. 常见问题

* cpu1_main是否可以调用操作系统接口？
  > 答：不可以,并且printf/puts等打印接口内部也用到操作系统接口,因此也不可以, 调试过程中可以加入打印,但是会有概率引发概率性死机
  >
* 核0和核1如何互斥？
  > 答：使用spin_lock
  >
* cpu1_main 函数的 __asm__ volatile(“idle”); 有什么作用?
  > 答:是为了让cpu1休闲降低功耗,但是如果cpu1没有中断触发,会导致cpu1停止运行,用户根据情况要不要删除掉
  >
* 如果运行在SFC模式下,写FLASH的时候会挂起CPU1,如果不希望引起CPU1挂起,应该怎么办?
  > 答：在 `apps/common/system/init.c` 的 `EnableOtherCpu()` ;后面增加一句话 cpu1_run_flag = 0;但是需要保证cpu1_main调用到的所有函数全部放到内部ram或者sdram,防止写flash过程中引起死机
  >

# 7.41. 不可屏蔽中断

**Overview**

提供不可屏蔽中断使用方法和常见问题。下面为建议开启不可屏蔽中断。

> * 中断频繁，则可以开启不可屏蔽中断;
> * 中断请求时需要立刻执行中断函数，例如接收数据：系统进临界区时中断响应需要立刻执行；

## 7.41.1. 应用示例

**示例演示：**

* 本例子使用硬件定时器来模拟中断请求

example: 进入 `apps/demo/demo_DevKitBoard/include/demo_config.h` ，开启宏 `USE_TIMER_TEST1_DEMO` ；进入 `apps/demo/demo_DevKitBoard/include/app_config.h` ，开启宏 `CONFIG_IPMASK_ENABLE` 。

**Note**

* 1.注意：建议中断函数和中断函数调用函数都指定在内部sram，指定方法：在函数定义加上 SEC_USED(.volatile_ram_code)，使用到的全局数据有初始化加 SEC_USED(.volatile_ram)，没初始化或初始化为0的加 SEC_USED(.sram)。如下程序的TSEC和全局变量宏使用。

**不可屏蔽中断方式的中断函数，和中断函数中使用的函数和const要全部放在内部ram，中断函数在调试阶段可以调用打印函数等，但需要注意打印函数可能影响到接收数据。**

> ```
> #include "app_config.h"
> #include "system/includes.h"
> #include "device/device.h"
> #include "asm/clock.h"
>
> //用户只能选择：JL_TIMER2、JL_TIMER3、JL_TIMER4、JL_TIMER5
> //PWM使用定时器2或者3映射PWM时候，不能用于定时
>
> static SEC_USED(.volatile_ram) JL_TIMER_TypeDef *TMR = JL_TIMER4;//选择定时器4
> static SEC_USED(.volatile_ram) u8 timer_irq = IRQ_TIMER4_IDX;//选择定时器4
>
> static SEC_USED(.volatile_ram) u32 timer_clk = 0;
>
> #define AWINLINE   __attribute__((always_inline))
>
> #define TSEC SEC_USED(.volatile_ram_code) //不可屏蔽中断函数放在内部ram
> //#define TSEC
>
> static AWINLINE TSEC void timer_cfg(u32 freq, u32 us)
> {
>   u8 timer_index[16] =  {0, 4, 1, 5, 2,  6,  3,  7,   8,   12,  9,    13,   10,   14,   11,    15};
>   u32 timer_table[16] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768};
>   u32 clock = timer_clk;
>   u8 psc = 0;
>   u8 tmp = 0;
>   u32 prd = 0;
>   u32 ts = us / (1000 * 1000);//计算秒
>   u32 tu = us % (1000 * 1000);//计算秒剩余us
>   u8 i;
>   float tp = 0;
>
>   if (freq >= clock)
>     {
>         freq = clock;
>       }
>     else if (freq <= 1)
>     {
>         freq = 1;
>           if (ts)
>           {
>               tp = (float)tu / (1000 * 1000);
>           }
>       }
>     /*求prd值*/
>     prd = clock / freq;
>     if (prd > 65535)
>     {
>         for (psc = 0; psc < 16; psc++)
>           {
>               prd = (u32)(clock / (timer_table[psc]) / freq);
>               if (prd <= 65535)
>               {
>                   break;
>               }
>               else if (psc == 15)
>               {
>                   prd = 65535;
>                   break;
>               }
>           }
>       }
>     prd = ts ? (prd * ts + tp * prd) : prd;
>     psc = timer_index[psc];
>     TMR->CON = 0;
>     TMR->CNT = 0;
>     TMR->CON |= BIT(14);
>     TMR->PRD = prd;
>     TMR->CON |= psc << 4; //lsb_clk分频
>     TMR->CON |= BIT(0);
> }
> static void TSEC timer_set(u32 us)//设置时间，该函数可以在中断调用重新设置定时器值
> {
>   u32 freq = 1000000 / us;
>   timer_cfg(freq, us);
> }
> static void TSEC timer_freq_set(u32 freq)//设置频率，该函数可以在中断调用重新设置定时器值
> {
>   timer_cfg(freq, 0);
> }
> static ___interrupt TSEC void timer_isr(void)//中断
> {
>   if (TMR->CON & BIT(15))
>   {
>       TMR->CON |= BIT(14);
>         putchar('@');
>         //todo，中断函数执行程序...
>   }
> }
>
> //example test
> static int c_main(void)
> {
>   timer_clk = clk_get("timer");//先获取定时器的时钟源
>   request_irq(timer_irq, 3, timer_isr, 0);//注册中断函数定和中断优先级
>   #if 1
>   timer_set(50 * 1000); //初始化50ms进一次中断
>   #else
>   //timer_freq_set(10000);//设置10K频率进中断
>   #endif
>   return 0;
> }
> late_initcall(c_main);
> ```

* 2. `app_main.c` 中断列表添加：指定的中断号和优先级和指定核， **中断优先级务必设置为7才能生效** ，如下为IRQ_TIMER4_IDX定时器4的中断号添加：

```
//中断号           //指定中断优先级为7(最高为7)    //指定注册到核1(0/1)
#ifdef CONFIG_IPMASK_ENABLE
//不可屏蔽中断方法：支持写flash，但中断函数和调用函数和const要全部放在内部ram
{IRQ_SOFT5_IDX,6,0},//此中断强制注册到cpu0
{IRQ_SOFT4_IDX,6,1},//此中断强制注册到cpu1
#if 1 //如下，TIMER4使用不可屏蔽中断设置,优先级固定7
{IRQ_TIMER4_IDX,7,1},//本次测试用到的是定时器4
#endif
#endif
```

![](img\223.png)

## 7.41.2. 常见问题

**Note**

* 不可屏蔽中断的中断响应函数里不能使用临界区和spin_lock等操作，否则会出现死锁导致看门狗复位的问题

## 7.41.3. API Reference

# 7.42. VDDIO_SYSVDD_DCDC14系统电压配置说明

**Overview**

本工程展示了VDDIO、SYSVDD、DCDC14系统电压配置和低电关机常见问题。

## 7.42.1. 应用示例

**示例演示：**

在board_xxx.c选择电源参数power_param配置选择，具体在工程添加步骤可见 `soft_power_off` 的电源配置参数，电压设置在 `app_config.h` 的电源低功耗配置宏定义。

* 1. `board.c` 的电源配置参数

  ```
  //----------------------------------电源配置参数------------------------------------------//

  /************************** LOW POWER config ****************************/
  staticconststructlow_power_parampower_param={
  .config=TCFG_LOWPOWER_LOWPOWER_SEL,
  .btosc_disable=TCFG_LOWPOWER_BTOSC_DISABLE,//进入低功耗时BTOSC是否保持(不需要需修改)
  .vddiom_lev=TCFG_LOWPOWER_VDDIOM_LEVEL,//强VDDIO等级,可选：2.2V  2.4V  2.6V  2.8V  3.0V  3.2V  3.4V  3.6V
  .vddiow_lev=TCFG_LOWPOWER_VDDIOW_LEVEL,//弱VDDIO等级,可选：2.1V  2.4V  2.8V  3.2V
  .vdc14_dcdc=TRUE,//打开内部1.4VDCDC，关闭则用外部
  .vdc14_lev=VDC14_VOL_SEL_LEVEL,//VDD1.4V配置
  .sysvdd_lev=SYSVDD_VOL_SEL_LEVEL,//系统内核、sdram电压配置
  .vlvd_value=VLVD_SEL_25V,//低电压复位电压值
  };
  ```
* 2. `app_config.h` 的低功耗配置参数

  ```
  //*********************************************************************************//
  //                                  电源低功耗配置                                    //
  //*********************************************************************************//
  #define TCFG_LOWPOWER_BTOSC_DISABLE     0
  #define TCFG_LOWPOWER_LOWPOWER_SEL      0              //该宏在睡眠低功耗才用到，此处设置为0
  #define TCFG_LOWPOWER_VDDIOM_LEVEL      VDDIOM_VOL_32V //正常工作的内部vddio电压值，一般使用外部3.3V，内部设置需比外部3.3V小
  #define TCFG_LOWPOWER_VDDIOW_LEVEL      VDDIOW_VOL_21V //软关机或睡眠的内部vddio最低电压值
  #define VDC14_VOL_SEL_LEVEL             VDC14_VOL_SEL_140V //内部的1.4V默认1.4V
  #define SYSVDD_VOL_SEL_LEVEL            SYSVDD_VOL_SEL_126V //系统内核电压，默认1.26V
  ```
* 3.struct low_power_param power_param结构体参数使用说明
  （1）.config：低功耗休眠配置项（默认0），包含：SYS_SLEEP_EN（系统休眠使能）、SYS_SLEEP_BY_IDLE（系统空闲休眠使能）、RF_SLEEP_EN（）、RF_FORCE_SYS_SLEEP_EN。
  （2）.btosc_disable：低功耗休眠保留参数（一般不用修改）。
  （3）vddiom_lev：设置芯片正常工作的IO口的电压（即VDDIO电压），一般实际PCB电路会把VDDIO接到外部的3.3V，这种情况时：当VDDIO设置电压档位小于3.3V则芯片使用外部的3.3V，当VDDIO设置电压档位大于3.3V时，芯片使用内部的VDDIO电压；VDDIO没有外接3.3V则使用内部的电压。 具体档位在对应的cpu路径下的 `power_interface.h` 文件，例如AC790:VDDIOM_VOL_22V - VDDIOM_VOL_36V； AC791:VDDIOM_VOL_28V - VDDIOM_VOL_35V。
  （4）vddiow_lev：设置芯片低功耗情况下工作的IO口的电压（即VDDIO电压），一般实际PCB电路会把VDDIO接到外部的3.3V，这种情况时：低功耗情况下会切断外部3.3连接VDDIO电路；VDDIO没有外接3.3V则使用内部的电压。
  具体档位在对应的cpu路径下的 `power_interface.h` 文件，例如AC790:VDDIOM_VOL_21V - VDDIOM_VOL_32V； AC791:VDDIOM_VOL_21V - VDDIOM_VOL_32V。
  （5）vdc14_dcdc：使能内部DCDC-1.4V，芯片内部1.4V为wifi和蓝牙硬件的提供工作电压，分为：LDO-1.4V和DCDC-1.4V，当vdc14_dcdc = TRUE则开启内部DCDC-1.4V,一般需要打开（否则wifi初始化可能会瞬间消耗大电流导致死机发生）；当vdc14_dcdc = FALSE，则为关闭内部的DCDC1.4V，使用内部LDO-1.4V。
  （6）vdc14_lev：（.vdc14_dcdc = TRUE有效）DCDC-1.4V电压档位，具体档位在对应的cpu路径下的 `p33.h` 文件，例如AC790:VDC14_VOL_SEL_120V - VDC14_VOL_SEL_155V； AC791:VDC14_VOL_SEL_125V - VDC14_VOL_SEL_160V。一般默认使用1.4V以上。
  （7）sysvdd_lev：系统内核电压配置（sdram的电压使用改电压），具体档位在对应的cpu路径下的 `p33.h` 文件，例如AC790:SYSVDD_VOL_SEL_087V - SYSVDD_VOL_SEL_132V； AC791:SYSVDD_VOL_SEL_093V - SYSVDD_VOL_SEL_138V。一般默认使用1.26V以上。
  （8）vlvd_value：VBAT的低电压复位电压值（VBAT电压某时刻掉低于vlvd_value值则系统复位），VLVD_SEL_19V - VLVD_SEL_26V，具体详情 `p33.h` 含有VLVD_SEL_19V的联合体。
* 4.低电关机电压
  (1)在app_power_manage.h中

  ```
  #ifdef CONFIG_INTERNAL_VDDIO_POWER_SUPPLY_ENABLE
  #define LOW_POWER_SHUTDOWN    350  //低电直接关机电压, 如果VDDIO使用内部LDO供电, 建议低于3.6V关机
  #define LOW_POWER_OFF_VAL           360  //低电关机电压
  #define LOW_POWER_WARN_VAL          370  //低电提醒电压
  #else
  #define LOW_POWER_SHUTDOWN    320  //低电直接关机电压, 如果VDDIO使用内部LDO供电, 建议低于3.6V关机
  #define LOW_POWER_OFF_VAL           330  //低电关机电压
  #define LOW_POWER_WARN_VAL          340  //低电提醒电压
  #endif
  #define LOW_POWER_WARN_TIME   (60 * 1000)  //低电提醒时间
  ```

  （2）在app_config.h打开宏

  ```
  #define CONFIG_AUTO_SHUTDOWN_ENABLE          //自动倒数关机
  ```

  （3）在板级文件board_xxx.c的board_init()板级初始化中

  ```
  #ifdef CONFIG_AUTO_SHUTDOWN_ENABLE
    sys_power_init();
  #endif
  ```

  （4）在power_manage.c中

  ```
  void sys_power_init(void)
  {
    vbat_check_init();    //初始化检查vbat电压

    if (get_vbat_level() <= LOW_POWER_SHUTDOWN) {  //判断开机初始化低电直接关机关机
        power_set_soft_poweroff(0);
    }
  #ifdef CONFIG_AUTO_SHUTDOWN_ENABLE     //开启倒计时关机，仅进行低电检查功能时可注释掉此部分
    u8 auto_off_time = 0;
    syscfg_read(CFG_AUTO_OFF_TIME_ID, &auto_off_time, sizeof(auto_off_time));
    sys_power_auto_shutdown_start(auto_off_time * 60);
  #endif
  }
  ```

Note

sysvdd_lev系统内核电压关系到sdram稳定性，在sdram速度120M以上，则系统内核电压最好需配置1.26V以上。

使用内部LDO-1.4V则wifi可能会在fi初始化可能会瞬间消耗大电流导致异常发生（wifi工作在AP模式时候会容易发生），因此强烈建议使用内部的DCDC-1.4V。

使用内部VDDIO供电时，需要在app_config.h打开宏CONFIG_INTERNAL_VDDIO_POWER_SUPPLY_ENABLE，带sdram的封装使用内部VDDIO供电时，需要保证实际工作电压3.3V， 考虑到芯片内部VDDIO电压的允许范围误差，SDK默认将VDDIO电压设成3.5V，确保能覆盖所有芯片。

## 7.42.2. 常见问题

# 7.43. 功耗优化说明

**Overview**

## 7.43.1. 操作说明

* 电压配置
  > 详情查看 `系统部分` 的 `VDDIO_SYSVDD_DCDC14系统电压配置说明`
  >
* `tools/isd_config_rule.c` 系统频率配置
  > ```
  > /*clock modules configuration*/
  > OSC=OSC0;             [OSC0|OSC1|OSC_RTC|HTC]
  > OSC_FREQ=24MHz;
  > OSC_HC_EN=0;
  > OSC_1PIN_EN=0;
  > #if defined CONFIG_OVERCLOCKING_ENABLE
  > SYS_CLK=396MHz;          [320M 240M 192M 160M 120M 96M 48M 24M 40M 24M，当SYS_CLK为其他值时sdram时钟跟随系统时钟]
  > HSB_DIV=1; [高速总线时钟分频系数 HSB_DIV+1]
  > LSB_DIV=1; [低速总线时钟分频系数 LSB_DIV+1]
  > #else
  > SYS_CLK=320MHz;          [320M 240M 192M 160M 120M 96M 48M 24M 40M 24M，当SYS_CLK为其他值时sdram时钟跟随系统时钟]
  > HSB_DIV=1; [高速总线时钟分频系数 HSB_DIV+1]
  > LSB_DIV=2; [低速总线时钟分频系数 LSB_DIV+1]
  > #endif
  > ```
  >
  > SYS_CLK配置如上, 频率从大到小, 功耗依次降低, 如需最优功耗, 在不影响程序使用前提下, 往低的配(如opus编解码最小需要在96MHz系统时钟下运行)
  >
* `sdk_ld_sfc.c` 代码段放置与缓存区配置(不带SDRAM情况下)
  > ```
  > FREE_DACHE_WAY = 7; //max is 7
  > FREE_IACHE_WAY = 0; //max is 7
  > CACHE_RAM_SIZE = FREE_DACHE_WAY*4K+FREE_IACHE_WAY*4K;
  > ```
  >
  > 默认工程FREE_DACHE_WAY配置为7, 如需最优功耗, 则配置成0, 由于此时CACHE_RAM_SIZE = 0, 放在cache_ram的段需要移动位置
  >
  > ```
  > . =ORIGIN(cache_ram);
  > .cache_ram_data ALIGN(4):
  > {
  >     #include "driver/cpu/wl82/system_data.ld"
  >     . = ALIGN(4); // must at tail, make ram0_data size align 4
  > } > cache_ram
  >
  > .cache_ram_bss ALIGN(4):
  > {
  >     *(.memp_memory_x)
  >     . = ALIGN(4); // must at tail, make ram0_data size align 4
  > } > cache_ram
  > ```
  >
  > `cache_ram_bss` 段内容放到 `ram0_bss` 里, `cache_ram_data` 段内容放到 `ram0_data` 里
  >
* 降低BLE功耗配置(以demo_ble为例)
  * 降低BLE模拟发射功率:需在BLE初始化完后调用, 可以在 `app_main.c` bt_ble_module_init()之后调用

    ```
    void app_main()
    {
        puts("------------- demo_ble app main-------------\n");

        extern void bt_ble_module_init(void);
        bt_ble_module_init();
        wifi_set_pwr(6); //功率选择档位 0-6, 0功率最低
    }
    ```
  * 降低BLE数字发射功率:需在BLE初始哈完成前调用, 可以在 `app_main.c` bt_ble_module_init()之前调用

    ```
    void app_main()
    {
        puts("------------- demo_ble app main-------------\n");

        extern void bt_ble_module_init(void);
        extern void bt_max_pwr_set(u8 pwr, u8 pg_pwr, u8 iq_pwr, u8 ble_pwr);
        bt_max_pwr_set(6, 6, 6, 11);  //第4个参数为BLE功率参数, 0-11
        bt_ble_module_init();
    }
    ```
* 蓝牙不操作，只操作wifi的开关控制功耗(如此关wifi, 功耗相当于SDK只开启了蓝牙, 注意函数的调用先后)

```
//关闭wifi
extern void wifi_rf_off();
wifi_off();
wifi_rf_off();

//开启wifi
extern void wifi_rf_on();
wifi_rf_on();
wifi_on();
```

## 7.43.2. 功耗场景

详情参考[场景功耗测试] `doc/stuff/场景功耗测试.xlsx`

## 7.43.3. 常见问题

# 7.44. UBOOT使用说明

在 `cpu\wl82\tools` 目录中提供了多个uboot文件选择，需要使用到单备份升级时必须选用支持单备份升级的uboot；debug支持指该uboot是否支持输出调试信息，当选择支持debug的uboot后，需要 在串口中输出uboot的调试信息时，需要修改 `cpu\wl82\tools\isd_config_rule.c` 文件中UTTX参数。默认使用的uboot文件名为 `uboot.boot` ，因此需要使用非默认uboot时，需要更名为 `uboot.boot`， 或者修改 `cpu\wl82\tools\download.c` 中-uboot 参数，更换为对应的uboot名称。uboot类型如下：

* uboot.boot (支持单备份升级，不支持debug)；
* uboot.boot_debug (支持单备份升级，支持debug)；
* uboot_no_ota.boot (不支持单备份升级，不支持debug)；
* uboot_no_ota.boot_debug （不支持单备份升级，支持debug）；

# 7.45. 长文件名使用注意说明

**Overview**

提供长文件名的使用及注意事项

## 7.45.1. 打开或创建长文件名说明

```
//暂时仅适用于纯ascii码的长文件名和目录，不适用于中文，中文名请自行手动拼接
int long_file_name_encode(const char *input, u8 *output, u32 output_buf_len);        //返回拼接后的长度
```

* 1.实现中文名长文件名打开或创建具体实现例程 `apps/common/example/storage/sd_fs/main1.c`
* 2.长文件名中的字符采用unicode（UTF16LE）形式编码，每个字符占据2字节的空间
* 3.下列代码中file_name字符串数组中
* ‘/’ 目录分隔符
* ‘\’, ‘U’,使用unicode编码
* ‘/’,0x00 使用unicode两个字节编码，目录分隔符补充0x00才能被识别到
* 打开已有文件，unicode编码的扩展名与原名大小写要相同，不然会打开失败

```
//文件名：longfilename.txt  通过字符转UTF16LE编码写入
char file_name[128] = {'/', '\\', 'U', 0x6C, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x66, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x2E, 0x00, 0x74, 0x00, 0x78, 0x00, 0x74, 0x00};

//文件名：hello/测试创建长文件名测试.txt
//char file_name[128] = {'/','h', 'e','l','l','o','/','\\','U',0x4B,0x6D,0xD5,0x8B,0x1B,0x52,0xFA,0x5E,0x7F,0x95,0x87,0x65,0xF6,0x4E,0x0D,0x54,0x4B,0x6D,0xD5,0x8B,0x2E,0x00,0x74,0x00,0x78,0x00,0x74,0x00};

//文件夹名：测试创建长文件名测试
//char file_name[128] = { '/','\\','U',0x4B,0x6D,0xD5,0x8B,0x1B,0x52,0xFA,0x5E,0x7F,0x95,0x87,0x65,0xF6,0x4E,0x0D,0x54,0x4B,0x6D,0xD5,0x8B};


//  测试长文件夹名测试/测试创建长文件名测试.txt
/* char file_name[128] = {'/', '\\', 'U', 0x4B, 0x6D, 0xD5, 0x8B, 0x7F, 0x95, 0x87, 0x65, 0xF6, 0x4E, 0x39, 0x59, 0x0D, 0x54, 0x4B, 0x6D, 0xD5, 0x8B, '/', 0x00, '\\', 'U', 0x4B, 0x6D, 0xD5, 0x8B, 0x1B, 0x52, 0xFA, 0x5E, 0x7F, 0x95, 0x87, 0x65, 0xF6, 0x4E, 0x0D, 0x54, 0x4B, 0x6D, 0xD5, 0x8B, 0x2E, 0x00, 0x74, 0x00, 0x78, 0x00, 0x74, 0x00}; */
```

* 4.拼接路径名称

```
char path[256] = "storage/sd0/C";//路径
memcpy(path + strlen(path), file_name, sizeof(file_name)); //将文件名file_name复制到path路径后
```

* 5. 使用fopen打开长文件名进行使用

```
fd = fopen(path, "w+");//打开可 读/写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。
```

## 7.45.2. 使用长文件名说明

* 1.打开已有长文件名文件，unicode编码的扩展名与源文件扩展名原名大小写要相同，不然会打开失败
* 2.使用fget_name获取长文件名长度，注意参数 `name` 和 `len` 的设置不然会获取到短文件名，获取后使用put_buf打印文件名，不要用printf（遇到0会停止）

```
/**
 * @brief 获取文件名(不包含目录)
 *
 * @param file 指向文件流的文件指针
 * @param name 保存文件名的buffer,获取长文件名时buffer大小要大于长文件名长度，否则会获取到文件的短文件名"LFN~xxx",打印长文件名用put_buf方式
 * @param len buffer的长度，大于15个字节获取的是长文件名，小于16个字节获取的是短文件名
 *
 * @return 文件名的长度(大于0)
 */
int fget_name(FILE *file, u8 *name, int len);
```

* 3.使用frename将文件重命名为长文件名。将短文件名rename成长文件名，注意在创建短文件名后要将短文件名fclose后再打开进行rename，直接在创建的短文件中rename会导致长度不对应重命名失败

```
/**
 * @brief 重命名文件
 *
 * @param file 指向文件流的文件指针
 * @param path 文件的新文件名，不需要加目录路径
 *
 * @return 0: 成功
 * @return other: 失败
 * @note  操作完毕后需要调用fclose关闭文件句柄
 */
int frename(FILE *file, const char *fname);
```

* 4.使用fget_attrs获取长文件名创建/修改/访问时间，SDK版本V1.1.x及以前，创建文件后需要fclose，之后进行fget_attrs才能获取到长文件名创建/修改/访问时间，不然会显示未赋值默认时间“1980-0-0-0-0-0”

```
/**
 * @brief 文件属性
 */
struct vfs_attr {
   u8 attr;                                    /*!< 文件属性标志位 */
   u32 fsize;                                  /*!< 文件大小 */
   u32 sclust;                                 /*!< 最小分配单元 */
   struct sys_time crt_time;   /*!< 文件创建时间 */
   struct sys_time wrt_time;   /*!< 文件最后修改时间 */
   struct sys_time acc_time;   /*!< 文件最后访问时间 */
};

/**
 * @brief 获取文件的详细信息如属性、簇号、大小等
 *
 * @param file 指向文件流的文件指针
 * @param attr 保存操作成功后文件的详细信息
 *
 * @return 0: 获取成功
 * @return other: 获取失败
 */
int fget_attrs(FILE *file, struct vfs_attr *attr);
```

# 7.46. 扩展外部存储器

**Overview**

为了降低芯片内部FLASH容量, 可以把固件代码和资源文件加载到外部存储器, 芯片启动后搬迁外部存储器代码到可执行代码内存单元运行

## 7.46.1. 名称定义

* 外部存储器: 芯片外挂用于加载代码和资源文件的介质, 一般指SD卡, U盘, NAND_FLASH等;
* 隐藏SDFILE区: 位于外部存储器, 使用跟FLASH内的sdfile结构一致的文件系统(仅缺少UBOOT), 用于存放固件代码以及重要资源文件;
* 隐藏FAT区: 位于外部存储器的FAT32文件系统, 用于存放PC端盘符不可见的文件;
* 第二FAT区:位于外部存储器的FAT32文件系统, 用于存放PC端盘符可见的文件;
* EX_APP.BIN:加载到外部存储器的固件代码可执行文件, 一般就是固件SDK代码;
* APP.BIN:加载到FLASH的固件代码可执行文件, 在这里的作用是把外部存储器的EX_APP.BIN拷贝到可直接运行代码的内存器如DDR/SDRAM/RAM/PSAM运行;

## 7.46.2. 外部存储器分区结构

## 7.46.3. 隐藏SDFILE分区结构

## 7.46.4. FLASH分区结构

注意：隐藏SDFILE和FLASH中VM区、RESERVED区是相互独立。

## 7.46.5. 启动流程

## 7.46.6. SD LOADER流程

sd loader运行在FLASH中，用于初始化外部存储器，加载主工程ex_app.bin到sdram，并完成解密和数据校验工作，校验成功后就会跳转到ex_app.bin中运行。

![](img\229.png)

```
static volatile unsigned int (*sdramEntryAddr)(void *) = 0x4000120;
static SD_BOOT_INFO sd_info;
#define IRQ_MEM_ADDR    (0x1c7fe00)

void jumpApp(void)
{
    //提供ex_app.bin需要的一些运行参数
    BOOT_DEVICE_INFO *info = (BOOT_DEVICE_INFO *)(((u32)IRQ_MEM_ADDR) + 8);
    info->fs_info = (u32)info + sizeof(BOOT_DEVICE_INFO);
    info->fs_info->FlashSize = boot_info.flash_size;//flash 大小
    info->fs_info->align =  boot_info.vm.align;//vm对齐方式
    info->trim_value = boot_info.trim_value ;//trim值
    info->chip_id = boot_info.chip_id; //chip id
    memcpy(&(info->sfc), &(boot_info.sfc), sizeof(struct sfc_info));  //sfc 相关参数
    memcpy(info->bt_mac_addr, &(boot_info.mac), sizeof(boot_info.mac)); //mac
    memcpy((u32)info + sizeof(BOOT_DEVICE_INFO) * 2 + 32, &sdram_info, sizeof(SDRAM_CFG_INFO)); //sdram相关参数
    memcpy((u32)info + sizeof(BOOT_DEVICE_INFO) * 2 + 32 + sizeof(SDRAM_CFG_INFO), &sd_info, sizeof(SD_BOOT_INFO)); //sd 启动相关参数

    //跳转，跳转后不再返回
    u32 ret = sdramEntryAddr((void *)info);
}

void sd_loader_task(void *priv)
{
    int filelen;
    int rlen;
    char headInfoBuf[SECTOR_SIZE];
    int err;
    JL_FILE_HEAD appBinHead;
    JL_FILE_HEAD appDirHead;
    u32 appAddr;
    u32 caclCrc = 0;
    u32 time_now = jiffies_to_msecs(jiffies);

    //获取ini配置参数，初始化串口
    uart_debug_init();
    logInfo("\r\n\r\n\r\n\r\n\r\n ------------sd loader %s-------------\r\n\r\n\r\n\r\n\r\n", __TIME__);

    //获取ini配置参数，初始化sd设备
    if (sdnand_init()) {
        errInfo("sdnand_init err!\n");
        return;
    }

    err = sdnand_read(headInfoBuf, 0x0, sizeof(headInfoBuf));
    if (!err) {
        errInfo("sdnand_read head info err!\n");
        return;
    }

    int ret = getAppDirHead(headInfoBuf, sizeof(headInfoBuf), &appDirHead);
    if (!ret) {
        logInfo("[%s info]len: 0x%x, appaddr: 0x%x\n", appDirHead.szFileName, appDirHead.u32Length, appDirHead.u32Address);
    }

    //获取ex_app.bin头部信息
    if (0 == getAppAreaHeadInfo(appDirHead.u32Address, "app.bin", &appBinHead)) {
        logInfo("[%s info] len: 0x%x, addr: 0x%x, attr :0x%x\n",
                appBinHead.szFileName,
                appBinHead.u32Length,
                appBinHead.u32Address,
                appBinHead.u8Attribute);

        u32 destAddr = sdramEntryAddr;
        u32 appLen = appBinHead.u32Length;
        u32 offset = appBinHead.u32Address;
        u32 rLen = 0;

        //加载ex_app.bin 到sdram
        err = sdnand_read(destAddr, appBinHead.u32Address + appDirHead.u32Address, appBinHead.u32Length);
        if (!err) {
            errInfo("sdnand_read head info err!\n");
            return;
        }

        //判断是否需要解密,如果开启加密功能，由于是软件解密一定程度上会影响启动速度
        if (appBinHead.u8Attribute == (FILE_ATTR_REG | FILE_ATTR_ENC)) {
            //解密ex_app.bin
            while (rLen < appLen) {
                decode_data_by_user_key(get_chip_id(), destAddr, sizeof(JL_FILE_HEAD), offset, sizeof(JL_FILE_HEAD));
                destAddr += sizeof(JL_FILE_HEAD);
                rLen += sizeof(JL_FILE_HEAD);
                offset += sizeof(JL_FILE_HEAD);
            }
        }

        //校验ex_app.bin
        caclCrc = calc_crc16_with_init_val(caclCrc, sdramEntryAddr, appLen);
        if (caclCrc != appBinHead.u16DataCrc) {
            errInfo("crc err, caclCrc : 0x%x, app crc : 0x%x\n", caclCrc, appBinHead.u16DataCrc);
        } else {
            //更新sfc_base_addr
            sd_info.app_addr = appDirHead.u32Address;

            //关中断，清cache
            __local_irq_disable();
            flush_all_icache();

            logInfo("the time to load app : %d ms\n", jiffies_to_msecs(jiffies) - time_now);
            logInfo("load app OK, jump Now!\n");

            //跳转到ex_app.bin运行
            jumpApp();
        }
    } else {
        errInfo("get app head info err!\n");
    }
}
```

参数说明：串口初始化和sd设备初始化时获取ini文件（ini文件由isd_config_rule_loader.c编译时生成）中的相关配置，对应配置说明如下：

* EX_SDCARD=SD_1_0_1_24XX；[SD_X(SD0:0 SD1:1)_X(A:0 B:1 C:2 D:3)_X(SD 数据宽度)_X(SD 时钟, 一共占4位，其余位补X，如：设置为24XX，即时钟为24 * 1000000)；设置为3XXX，即时钟位3 * 1000000] 其中：(SD配置请参考： SD )
* SDTX=PC00; [配置SD调试输出Pin] //串口tx
* SDBD=1000000; [配置SD调试波特率]//串口波特率

## 7.46.7. 外部存储器分区配置使用说明

### 7.46.7.1. 一般分为四种使用情况：

* 注意：只有使用以下第2种情况（SD卡分为两个分区(隐藏FAT区，FAT1区，无隐藏SDFILE区)） 需自行进行修改增加内容。使用以下第3和第4中情况只需根据以下说明打开对应宏即可
* 情况1：常规用法，SD卡只有一个分区,无需配置
* 情况2：SD卡分为两个分区(隐藏FAT区，FAT1区，无隐藏SDFILE区)

> （1）一个为隐藏FAT区，通过msd（使用msd（USB做masstorge从机方法））用户不可见；
>
> （2）一个为可见FAT区，用户可见；
>
> （3）注意由于没有隐藏SDFILE区，不要开启#define CONFIG_SDFILE_EXT_ENABLE 和 #define CONFIG_DMSDX_ENABLE
>
> （4）使用者需自行在app_config.h增加宏去控制apps/common/system/device_mount.c对于隐藏FAT区和第二FAT区挂载
>
> （5）使用者需自行在cpu/wl82/tools/isd_config_rule_loader.c 中增加隐藏FAT区和第二FAT区配置，默认代码是被CONFIG_SDFILE_EXT_ENABLE所包，但是没有隐藏SDFILE区
>
> （6）修改download.c可以在烧录时将tools文件夹下hfat_dir和fat1_dir内容烧录到对应分区

```
 //a.在app_config.h中增加
 #define CONFIG_DFAT_ENABLE
 #ifdef CONFIG_DFAT_ENABLE

 #define CONFIG_SDNAND_HFS_LEN_TEXT  0M  //没有SDFILE区，设置为0
 #define CONFIG_SDNAND_HFAT_LEN_TEXT 2G  //hfat隐藏FAT区大小
 #define CONFIG_SDNAND_FAT1_LEN_TEXT 8G  //第二FAT区大小
 #define CONFIG_SDNAND_HFS_LEN       (0llu * 1024 * 1024)         //没有SDFILE区，设置为0
 #define CONFIG_SDNAND_HFAT_LEN      (2llu * 1024 * 1024 * 1024)  //hfat隐藏FAT区大小
 #define CONFIG_SDNAND_FAT1_LEN      (8llu * 1024 * 1024 * 1024)  //第二FAT区大小

 //每个簇有多少个block，比如簇大小设置为32768时，该值为32768 / 512 = 0x40
 #if CONFIG_SDNAND_HFAT_LEN > 0x80000000
 #define CONFIG_SDNAND_HFAT_CLUSTER_SIZE 0x40
 #elif CONFIG_SDNAND_HFAT_LEN > 0x40000000
 #define CONFIG_SDNAND_HFAT_CLUSTER_SIZE 0x20
 #elif CONFIG_SDNAND_HFAT_LEN > 0x20000000
 #define CONFIG_SDNAND_HFAT_CLUSTER_SIZE 0x10
 #elif CONFIG_SDNAND_HFAT_LEN > 0x10000000
 #define CONFIG_SDNAND_HFAT_CLUSTER_SIZE 0x8
 #elif CONFIG_SDNAND_HFAT_LEN > 0x8000000
 #define CONFIG_SDNAND_HFAT_CLUSTER_SIZE 0x4
 #elif CONFIG_SDNAND_HFAT_LEN > 0x4000000
 #define CONFIG_SDNAND_HFAT_CLUSTER_SIZE 0x2
 #else
 #define CONFIG_SDNAND_HFAT_CLUSTER_SIZE 0x1
 #endif

 #if CONFIG_SDNAND_FAT1_LEN > 0x80000000
 #define CONFIG_SDNAND_FAT1_CLUSTER_SIZE 0x40
 #elif CONFIG_SDNAND_FAT1_LEN > 0x40000000
 #define CONFIG_SDNAND_FAT1_CLUSTER_SIZE 0x20
 #elif CONFIG_SDNAND_FAT1_LEN > 0x20000000
 #define CONFIG_SDNAND_FAT1_CLUSTER_SIZE 0x10
 #elif CONFIG_SDNAND_FAT1_LEN > 0x10000000
 #define CONFIG_SDNAND_FAT1_CLUSTER_SIZE 0x8
 #elif CONFIG_SDNAND_FAT1_LEN > 0x8000000
 #define CONFIG_SDNAND_FAT1_CLUSTER_SIZE 0x4
 #elif CONFIG_SDNAND_FAT1_LEN > 0x4000000
 #define CONFIG_SDNAND_FAT1_CLUSTER_SIZE 0x2
 #else
 #define CONFIG_SDNAND_FAT1_CLUSTER_SIZE 0x1
 #endif

 #endif

//b.在apps/common/system/device_mount.c
static int mount_sd_to_fs(const char *sd_name)
 ...
 /* #ifdef CONFIG_SDFILE_EXT_ENABLE */
 #if defined CONFIG_SDFILE_EXT_ENABLE || defined CONFIG_DFAT_ENABLE //增加app_config.h中增加的宏CONFIG_DFAT_ENABLE去挂载隐藏FAT区和第二FAT区
 ...

 //c.在cpu/wl82/tools/isd_config_rule.c
 ...
 //#if defined CONFIG_SDFILE_EXT_ENABLE //源代码
 #if defined CONFIG_SDFILE_EXT_ENABLE || defined CONFIG_DFAT_ENABLE //增加CONFIG_DFAT_ENABLE宏判断
 #if TCFG_SD0_ENABLE
 #if TCFG_SD_PORTS == 'A'
 EX_SDCARD=SD_0_0_1_1_24;
 #elif TCFG_SD_PORTS == 'B'
 ...
 ...
 [BURNER_CONFIG]
 SIZE=32;
 //文件最后位置加入以下内容
 #if defined CONFIG_DFAT_ENABLE
 [SDCARD_CONFIG]
 HFAT_FILE=jl_hfat.bin
 HFAT_ADR=AUTO
 HFAT_LEN=CONFIG_SDNAND_HFAT_LEN_TEXT
 HFAT_OPT=1

 FAT1_FILE=jl_fat1.bin
 FAT1_ADR=AUTO
 FAT1_LEN=CONFIG_SDNAND_FAT1_LEN_TEXT
 FAT1_OPT=1
 #endif

 //d.在download.c中增加
 //使用linux编译 在#ifdef __SHELL__部分修改增加
 #if defined CONFIG_SDFILE_EXT_ENABLE
 echo -n "fat_image_tool.exe --size " >> ${PROJ_BUILD}
 ...
 echo "isd_download.exe isd_config.ini -gen2 -to-sdcard -dev wl82 -boot 0x1c02000 -div1 -app app.bin cfg_tool.bin -res %AUDIO_RES% %UI_RES% cfg -extend-bin -output-bin jl_hfs.bin %UPDATE_FILES% -no-app-bin-enc" >> ${PROJ_BUILD}
 #elif defined CONFIG_DFAT_ENABLE  //CONFIG_DFAT_ENABLE 宏包着内容为需自行增加内容
 echo -n "fat_image_tool.exe --size " >> ${PROJ_BUILD}
 echo -n CONFIG_SDNAND_HFAT_LEN_TEXT >> ${PROJ_BUILD}
 echo -n " --sectors-per-cluster " >> ${PROJ_BUILD}
 echo -n CONFIG_SDNAND_HFAT_CLUSTER_SIZE >> ${PROJ_BUILD}
 echo " --lfn true --n-root 512 --volume-name HFAT_IMG --output jl_hfat.bin --fat-dir hfat_dir" >> ${PROJ_BUILD}
 echo -n "fat_image_tool.exe --size " >> ${PROJ_BUILD}
 echo -n CONFIG_SDNAND_FAT1_LEN_TEXT >> ${PROJ_BUILD}
 echo -n " --sectors-per-cluster " >> ${PROJ_BUILD}
 echo -n CONFIG_SDNAND_FAT1_CLUSTER_SIZE >> ${PROJ_BUILD}
 echo " --lfn true --n-root 512 --volume-name FAT1_IMG --output jl_fat1.bin --fat-dir fat1_dir" >> ${PROJ_BUILD}
 echo "isd_download.exe isd_config.ini -gen2 -to-sdcard -dev wl82 -boot 0x1c02000 -uboot uboot.boot -app app.bin" >> ${PROJ_BUILD}
 echo "isd_download.exe isd_config.ini -tonorflash -dev wl82 -boot 0x1c02000 -div1 -wait 300 -uboot uboot.boot -app app.bin cfg_tool.bin -res %AUDIO_RES% %UI_RES% cfg -reboot 500 %UPDATE_FILES% -extend-bin" >> ${PROJ_BUILD}
 #elif defined CONFIG_SFC_ENABLE
 echo "isd_download.exe isd_confi
 ....

 //使用windows编译的话，在#ifdef __SHELL__对应的 #else下面修改
 #if defined CONFIG_SDFILE_EXT_ENABLE
 fat_image_tool.exe --size CONFIG_SDNAND_HFAT_LEN_TEXT --sectors-per-cluster CONFIG_SDNAND_HFAT_CLUSTER_SIZE --lfn true --n-root 512 --volume-name HFAT_IMG --output jl_hfat.bin --fat-dir hfat_dir
 fat_image_tool.exe --size CONFIG_SDNAND_FAT1_LEN_TEXT --sectors-per-cluster CONFIG_SDNAND_FAT1_CLUSTER_SIZE --lfn true --n-root 512 --volume-name FAT1_IMG --output jl_fat1.bin --fat-dir fat1_dir
 isd_download.exe isd_config.ini -gen2 -to-sdcard -dev wl82 -boot 0x1c02000 -div1 -app app.bin cfg_tool.bin -res %AUDIO_RES% %UI_RES% cfg -extend-bin -output-bin jl_hfs.bin %UPDATE_FILES% -no-app-bin-enc
 #elif defined CONFIG_DFAT_ENABLE  //CONFIG_DFAT_ENABLE 宏包着内容为需自行增加内容
 fat_image_tool.exe --size CONFIG_SDNAND_HFAT_LEN_TEXT --sectors-per-cluster CONFIG_SDNAND_HFAT_CLUSTER_SIZE --lfn true --n-root 512 --volume-name HFAT_IMG --output jl_hfat.bin --fat-dir hfat_dir
 fat_image_tool.exe --size CONFIG_SDNAND_FAT1_LEN_TEXT --sectors-per-cluster CONFIG_SDNAND_FAT1_CLUSTER_SIZE --lfn true --n-root 512 --volume-name FAT1_IMG --output jl_fat1.bin --fat-dir fat1_dir
 isd_download.exe isd_config.ini -gen2 -to-sdcard -dev wl82 -boot 0x1c02000 -uboot uboot.boot -app app.bin
 isd_download.exe isd_config.ini -tonorflash -dev wl82 -boot 0x1c02000 -div1 -wait 300 -uboot uboot.boot -app app.bin cfg_tool.bin -res %AUDIO_RES% %UI_RES% %CFG_FILE% -reboot 500 %KEY_FILE% %UPDATE_FILES% -extend-bin
 #elif defined CONFIG_SFC_ENABLE
 ...
```

* 情况3：开启#define CONFIG_SDFILE_EXT_ENABLE //外挂多分区存储器支持 SD卡分为三个区，分别为：

> （1）隐藏SDFILE区，用于存放主工程资源代码，通过运行flash中sd loader将其加载到sdram中运行；
>
> （2）隐藏FAT区，通过msd用户不可见；
>
> （3）第二FAT区（可见FAT区），用户可见；
>
> （4）情况3与情况2独立，需使用三个分区直接开启宏CONFIG_SDFILE_EXT_ENABLE即可，不需情况2中自行增加内容

* 情况4：在情况三的基础上开启#define CONFIG_DMSDX_ENABLE //msd多分区显示支持 时SD分为三个区：

> （1）隐藏SDFILE区
>
> （2）隐藏FAT区此时通过msd用户可见
>
> （3）第二FAT区可见
>
> （4）使用其它板级时，参考apps/wifi_story_machine/board/wl82/board_7916A.c中CONFIG_DMSDX_ENABLE宏所包内容进行两个FAT区的偏移量设置和sdx.0和sdx.1设备的注册

```
//app_config.h
#define CONFIG_SDFILE_EXT_ENABLE         //外挂多分区存储器支持
#define CONFIG_DMSDX_ENABLE              //msd多分区显示支持 需定义CONFIG_SDFILE_EXT_ENABLE 打开外挂多分区存储器前提下使用

#ifdef CONFIG_SDFILE_EXT_ENABLE

#undef CONFIG_SFC_ENABLE
#undef __FLASH_SIZE__
#define __FLASH_SIZE__    (16 * 1024 * 1024)

//隐藏SDFILE区大小、隐藏FAT区大小和第二FAT区大小设置需对应的两个参数同时修改
#define CONFIG_SDNAND_HFS_LEN_TEXT  16M    //隐藏SDFILE区大小
#define CONFIG_SDNAND_HFAT_LEN_TEXT 4G     //隐藏FAT区大小
#define CONFIG_SDNAND_FAT1_LEN_TEXT 8G     //第二FAT区大小
#define CONFIG_SDNAND_HFS_LEN       (16llu * 1024 * 1024)       //隐藏SDFILE区大小
#define CONFIG_SDNAND_HFAT_LEN      (4llu * 1024 * 1024 * 1024) //隐藏FAT区大小
#define CONFIG_SDNAND_FAT1_LEN      (8llu * 1024 * 1024 * 1024) //第二FAT区大小
...
#endif
```

* 两个FAT区的读写示例

```
#include "fs/fs.h"
static void sd_fs_test(void)
{
    extern int storage_device_ready(void);

    while (!storage_device_ready()) {//等待sd文件系统挂载完成
            os_time_dly(2);
    }

    //读写测试
    u8 *test_data = "123456789";
    u8 *test_data1 = "abcdefghijkadcp";
    u8 read_buf[32];
    u8 read_buf1[32];
    memset(read_buf,0,sizeof(read_buf));
    memset(read_buf1,0,sizeof(read_buf1));
    int len;

    //1.第二FAT区创建写读文件
    //路径storage/sd0/C
    FILE *fd = fopen("storage/sd0/C/test11.txt", "w+");
    if (fd) {
            fwrite(test_data, 1, strlen(test_data), fd);
            fclose(fd);
    }

    fd = fopen("storage/sd0/C/test11.txt", "r");
    if (fd) {
            len = flen(fd);
            fread(read_buf, 1, len, fd);
            fclose(fd);
            printf("FAT1 read file : %s \n", read_buf);
    }


//2.hfat 创建读写
//路径storage/sdh/C
FILE *fd1 = fopen("storage/sdh/C/test22.txt", "w+");
    if (fd1) {
            fwrite(test_data1, 1, strlen(test_data1), fd1);
            fclose(fd1);
    }

    fd1 = fopen("storage/sdh/C/test22.txt", "r");
    if (fd1) {
            len = flen(fd1);
            fread(read_buf1, 1, len, fd1);
            fclose(fd1);
            printf("HFAT read file : %s \n", read_buf1);
    }

    while (1) {
            os_time_dly(2);
    }

}
static int c_main(void)
{
        os_task_create(sd_fs_test, NULL, 12, 1000, 0, "sd_fs_test");
        return 0;
}
late_initcall(c_main);
```

（1）SD卡只有一个分区

> 为常规用法，正常配置使用即可；

（2）SD卡分为两个区，隐藏FAT区和第二FAT区（可见FAT区）

* download.bat（由download.c编译生成，因此需要在对应位置增加配置）应存在以下配置：

> ```
> //步骤一：生成FAT镜像文件。
> fat_image_tool.exe --size 4G --sectors-per-cluster 0x40 --lfn true --n-root 512 --volume-name FAT_IMG --output jl_hfat.bin --fat-dir hfat_dir
> 主要参数说明：
> --size ：为fat镜像大小，需要和isd_config_rule_loader.c配置文件中保持一致。
> --sectors-per-cluster：簇大小配置。
> --output：输出的fat镜像文件。
> --fat-dir：目录资源文件，会一同打包到fat镜像文件中。
>
> //步骤二：将FAT镜像烧录到SD卡。注意：步骤二需再步骤三上面，即先烧录FAT镜像再烧录jl_isd.bin
> isd_download.exe isd_config.ini -gen2 -to-sdcard -dev wl82 -boot 0x1c02000
>
> //步骤三：将jl_isd.bin烧录到flash
> isd_download.exe isd_config.ini -tonorflash -dev wl82 -boot 0x1c02000 -div1 -wait 300 -uboot uboot.boot -app app.bin cfg_tool.bin -res %AUDIO_RES% %UI_RES% cfg -reboot 500 -update_files normal -extend-bin
>
> //参考示例：某工程下编译时生成的download.bat示例
> set OBJDUMP=C:\JL\pi32\bin\llvm-objdump.exe
> set OBJCOPY=C:\JL\pi32\bin\llvm-objcopy.exe
> set ELFFILE=sdk.elf
> %OBJCOPY% -O binary -j .text %ELFFILE% text.bin
> %OBJCOPY% -O binary -j .data %ELFFILE% data.bin
> %OBJCOPY% -O binary -j .ram0_data  %ELFFILE% ram0_data.bin
> %OBJCOPY% -O binary -j .cache_ram_data  %ELFFILE% cache_ram_data.bin
> %OBJDUMP% -section-headers -address-mask=0x1ffffff %ELFFILE%
> %OBJDUMP% -t %ELFFILE% > symbol_tbl.txt
> copy /b text.bin+data.bin+ram0_data.bin+cache_ram_data.bin app.bin
> packres\packres.exe -n tone -o packres/AUPACKRES audlogo
> fat_image_tool.exe --size 8G --sectors-per-cluster 0x40 --lfn true --n-root 512 --volume-name FAT_IMG --output jl_hfat.bin --fat-dir hfat_dir
> isd_download.exe isd_config.ini -gen2 -to-sdcard -dev wl82 -boot 0x1c02000
> isd_download.exe isd_config.ini -tonorflash -dev wl82 -boot 0x1c02000 -div1 -wait 300 -uboot uboot.boot -app app.bin cfg_tool.bin -res %AUDIO_RES% %UI_RES% cfg -reboot 500 -update_files normal -extend-bin
> fw_add.exe -noenc -fw jl_isd.fw -add script.ver -out jl_isd.fw
> ufw_maker.exe -fw_to_ufw jl_isd.fw
> copy jl_isd.ufw update.ufw
> ping /n 2 127.1>null
> del cache_ram_data.bin
> del data.bin
> del ram0_data.bin
> del text.bin
> TIMEOUT /T 3
> exit /b 0
> ```

* isd_config.ini（由isd_config_rule.c编译生成，因此需要在对应位置增加配置）应存在以下配置：

> ```
> //步骤一：增加SD卡配置参数，工具会读取该参数来初始化SD卡
> EX_SDCARD=SD_0_1_1_24XX;
>
> //步骤二：增加FAT区配置
> [SDCARD_CONFIG]
> /* 隐藏FAT区配置*/
> HFAT_FILE=jl_hfat.bin                //隐藏FAT区bin文件
> HFAT_ADR=AUTO                        //在外部存储器中的偏移地址,auto为由工具自动分配，即该区域会紧随着隐藏SDFILE区
> HFAT_LEN=CONFIG_SDNAND_HFAT_LEN_TEXT //隐藏FAT区大小
> HFAT_OPT=1
>
> /* 第二FAT区配置*/
> FAT1_ADR=AUTO                       //在外部存储器中的偏移地址,auto为由工具自动分配，即该区域会紧随着隐藏FAT区
> FAT1_LEN=CONFIG_SDNAND_FAT1_LEN_TEXT//第二FAT区大小
> FAT1_OPT=1
> ```

(3)SD卡分为三个区：SDFILE区、隐藏FAT区和第二FAT区：

* loader_tools目录下isd_config.ini（由isd_config_rule_loader.c编译生成，因此需要在对应位置增加配置）应存在以下配置：

> ```
> //步骤一：增加SD卡配置参数，工具会读取该参数来初始化SD卡
> EX_SDCARD=SD_0_1_1_24XX;
>
>
> //步骤二：增加SDFILE区配置和FAT区配置
> /* 隐藏SDFILE区配置*/
> HFS_FILE=jl_hfs.bin                  //隐藏SDFILE区bin文件
> HFS_ADR=0G                           //在外部存储器中的偏移地址
> HFS_LEN=CONFIG_SDNAND_HFS_LEN_TEXT   //隐藏SDFILE区大小
> HFS_OPT=1
>
> /* 隐藏FAT区配置*/
> HFAT_FILE=jl_hfat.bin                //隐藏FAT区bin文件
> HFAT_ADR=AUTO                        //在外部存储器中的偏移地址,auto为由工具自动分配，即该区域会紧随着隐藏SDFILE区
> HFAT_LEN=CONFIG_SDNAND_HFAT_LEN_TEXT //隐藏FAT区大小
> HFAT_OPT=1
>
> /* 第二FAT区配置*/
> FAT1_ADR=AUTO                       //在外部存储器中的偏移地址,auto为由工具自动分配，即该区域会紧随着隐藏FAT区
> FAT1_LEN=CONFIG_SDNAND_FAT1_LEN_TEXT//第二FAT区大小
> FAT1_OPT=1
> ```

* download.bat（由download.c编译生成，因此需要在对应位置增加配置）应存在以下配置：

> ```
> fat_image_tool.exe --size 4G --sectors-per-cluster 0x40 --lfn true --n-root 512 --volume-name FAT_IMG --output jl_hfat.bin --fat-dir hfat_dir
> 主要参数说明：
> --size ：为fat镜像大小，需要和isd_config_rule_loader.c配置文件中保持一致。
> --sectors-per-cluster：簇大小配置。
> --output：输出的fat镜像文件。
> --fat-dir：目录资源文件，会一同打包到fat镜像文件中。
>
> isd_download.exe isd_config.ini -gen2 -to-sdcard -dev wl82 -boot 0x1c02000 -div1 -app app.bin cfg_tool.bin -res %AUDIO_RES% %UI_RES% cfg -extend-bin -output-bin jl_hfs.bin -update_files normal
> 主要参数说明：
> -output-bin ：输出的隐藏SDFILE区镜像文件，改文件由uboot、app.bin、cfg_tool.bin和res资源文件打包生成。
> -to-sdcard/-tonorflash:-to-sdcard为生成sd卡镜像，-tonorflash为生成flash镜像。
> -no-app-bin-enc：存在该参数时不对app.bin加密。app.bin加密后，sd loader将app.bin加载到sdram后会进行软件解密，因此会增加ex_app.bin的启动时间。
>
> copy isd_config_loader.ini loader_tools\isd_config.ini
> copy jl_hfs.bin loader_tools\jl_hfs.bin
> copy jl_hfs.bin.clear loader_tools\jl_hfs.bin.clear
> copy jl_hfat.bin loader_tools\jl_hfat.bin
>
> del jl_hfs.bin
> del jl_hfs.bin.clear
> del jl_hfat.bin
> cd loader_tools
> call download.bat
> ```

* 工程示例

wifi_story_machine工程已提供示例，通过在app_config.h中定义#define CONFIG_SDFILE_EXT_ENABLE进行使能。其他工程需要使用到该方式时，请参考进行移植。

* SD LOADER更改说明

sd loader工程和主工程为两个独立工程，出于开发需要需要对sd loader进行更新。此时只需要将sd loader编译生成的sdk.elf替换掉主工程”cpu\wl82\tools\loader_tools\”目录下的sdk.elf即可。

* SD卡镜像文件生成方法

SD卡镜像文件用于对SD卡进行外部烧录，修改”cpu\wl82\tools\loader_tools\download.bat”文件，添加配置-output-sdcrad-image jl_sdcard.img。如下：

> ```
> set OUTPUT_IMAGE=-output-sdcrad-image jl_sdcard.img
> isd_download.exe isd_config.ini -gen2 -tonorflash -dev wl82 -boot 0x1c02000 -div1 -wait 300 -uboot uboot.boot -app app.bin cfg_tool.bin -reboot 500 -update_files normal -extend-bin %OUTPUT_IMAGE%
> ```

## 7.46.8. OTA升级

扩展外部存储器升级涉及到FLASH升级和外部存储器升级，因此需要将两个升级固件进行打包，该项目中提供了一个简易的打包工具(路径：”cpu\wl82\tools\packufw\”)，同时提供源代码，由用户根据自己的需求进行修改使用；提供的例程中，打包架构如下：

> ```
> /*JLpack打包格式*/
> // |首头部| |输入文件1头部| |输入文件2头部| |输入文件1数据| |输入文件2数据|
>
> //首头部和输入文件的头部结构如下：
> #define JLFILE_VERSION_LEN 32
> typedef struct {
>     unsigned short headCrc;           //头部crc
>     unsigned short dataCrc;           //数据crc
>     unsigned int   address;           //数据地址
>     unsigned int   length;            //数据长度
>
>     unsigned char u8Attribute;        //文件属性
>     unsigned char res;                //保留
>     unsigned short fileNum;           //文件个数，这里代表携带了多少问文件数据
>     char fileName[16];                //名称
>     char version[JLFILE_VERSION_LEN]; //版本号
> } JLExtUpateHead;
>
> //固件打包命令
> JLpack.exe -f exAppUpdate.ufw -v 3.4.5 -f appUpdate.ufw -v 2.1.2  -o otaUpdate.ufw
> 其中：
> -f : Input file
> -v : File version, -f must be followed by -v
> -o : output file
> 7.46.9. OTA升级流程
> ```

## 7.46.9. OTA升级流程

> ```
> //具体请参考"apps/common/example/update/http_upgrade/example3/ex_ota_example.c" 。
> static void download_task(void *priv)
> {
>     struct download_hdl *hdl = priv;
>     void *update_fd = NULL;
>     int ret = 0;
>     int err = 0;
>     char sock_err = 0;
>     int total = 0;
>     JLExtUpateHead extHead;
>
>
> _reconnect_:
>     //发起连接请求，建立socket连接
>     ret = hdl->download_ops->init(&hdl->ctx);
>     if (ret != HERROR_OK) {
>         if (hdl->ctx.req_exit_flag == 0) {
>             if (hdl->reconnect_cnt < MAX_RECONNECT_CNT) {
>                 hdl->reconnect_cnt++;
>                 goto _reconnect_;
>             } else {
>                 log_e("download reconnect upto max count.\n");
>                 goto _out_;
>             }
>         }
>     }
>
>     /* 获取打包固件首头部信息 */
>     ret = hdl->download_ops->read(&hdl->ctx, (char *)&extHead, sizeof(JLExtUpateHead));
>     if (ret !=  sizeof(JLExtUpateHead)) {
>         printf("get extHead err!");
>         sock_err = 1;
>         goto _out_;
>     }
>
>     put_buf(&extHead, sizeof(JLExtUpateHead));
>     if (ext_head_vaild_check(&extHead)) {
>         printf("check extHead err!\n");
>         sock_err = 1;
>         goto _out_;
>     } else {
>         /* 判断是否是ext_update 升级接口*/
>         if (0 == memcmp(extHead.fileName, "EXT_UPDATE", strlen("EXT_UPDATE"))) {
>             printf("get EXT_UPDATE head\n");
>         } else {
>             printf("EXT_UPDATE information not found\n");
>             sock_err = 1;
>             goto _out_;
>         }
>     }
>
>     /* 保存需要升级的固件头部信息 */
>     char *r_buf = (char *)&gupdateTable;
>     char r_len = extHead.fileNum * sizeof(JLExtUpateHead);
>     int len = 0;
>     while (1) {
>         ret = hdl->download_ops->read(&hdl->ctx, r_buf + len, r_len - len);
>         if (ret < 0) {
>             sock_err = 1;
>             goto _out_;
>         } else {
>             len += ret;
>         }
>
>         if (len >= r_len) {
>             break;
>         }
>     }
>
>     /* 对需要升级的设备进行升级 */
>     int cnt = 0;
>     while (cnt < extHead.fileNum) {
>         if (ext_head_vaild_check(&gupdateTable[cnt])) {
>             printf("ext_head_vaild_check gupdateTable head err!\n");
>             sock_err = 1;
>             goto _out_;
>         } else {
>             if (0 == memcmp(gupdateTable[cnt].fileName, "appUpdate.ufw", strlen("appUpdate.ufw"))) {
>                 printf("find %s\n", gupdateTable[cnt].fileName);
>
>                 /* 升级flash时需要转换到flash设备 */
>                 switch_upgrade_dev(FLASH_DEV_TYPE);//flash
>             } else if (0 == memcmp(gupdateTable[cnt].fileName, "exAppUpdate.ufw", strlen("exAppUpdate.ufw"))) {
>                 printf("find %s\n", gupdateTable[cnt].fileName);
>
>                 /* 升级SD时需要转换到SD设备 */
>                 switch_upgrade_dev(SD_DEV_TYPE);//sd
>             } else {
>                 printf("unable to find the upgrade firmware\n");
>                 sock_err = 1;
>                 goto _out_;
>             }
>
>             /* 获取当前设备的固件版本号 */
>             get_current_version(g_currentVersion);
>             if (0 == strcmp(gupdateTable[cnt].version, g_currentVersion)) {
>                 printf("the upgrade firmware version information is the same\n");
>                 strcpy(get_latest_version(), gupdateTable[cnt].version);
>                 cnt++;
>                 continue;
>             } else {
>                 //版本号不一致更新版本信息
>                 strcpy(get_latest_version(), gupdateTable[cnt].version);
>             }
>
>             update_fd = net_fopen(CONFIG_UPGRADE_OTA_FILE_NAME, "w");
>             if (!update_fd) {
>                 log_e("open update_fd error\n");
>                 goto _out_;
>             }
>
>             int dsize = 0;
>             hdl->file_size = gupdateTable[cnt].length;
>             hdl->download_len = 0;
>             while (hdl->ctx.req_exit_flag == 0) {
>                 dsize = (hdl->file_size - hdl->download_len) > hdl->recv_buf_size ? hdl->recv_buf_size : (hdl->file_size - hdl->download_len);
>                 ret = hdl->download_ops->read(&hdl->ctx, (char *)hdl->recv_buf, dsize);//最大接收为recv_buf_size
>                 if (ret <  0) {  //读取数据失败
>                     sock_err = 1;
>                     goto _out_;
>                 } else {
>                     hdl->download_len += ret;
>                     err = net_fwrite(update_fd, hdl->recv_buf, ret, 0);
>                     if (err != ret) {
>                         goto _out_;
>                     }
>                 }
>
>                 if (hdl->download_len >= hdl->file_size) {
>                     printf("download %s success!\n", gupdateTable[cnt].fileName);
>                     total++;
>                     sock_err = 0;
>                     net_fclose(update_fd, sock_err);
>                     update_fd = NULL;
>                     break;
>                 }
>             }
>
>             hdl->download_len = 0;
>             cnt++;
>         }
>     }
>
> _out_:
>
>     if (total) {
>         system_reset();
>     }
>
>     //关闭网络连接
>     hdl->download_ops->close(&hdl->ctx);
>
>     if (update_fd) {
>         net_fclose(update_fd, sock_err);
>         update_fd = NULL;
>     }
>     free(hdl->url);
>     free(hdl->recv_buf);
>     free(hdl);
>
> }
> ```

注意事项：

> 扩展外部存储器升级涉及到FLASH升级和外部存储器升级，其isd_config.ini配置文件分别由isd_config_rule.c和isd_config_rule_loader.c编译生成，在编译升级固件时需要对对应ini文件中BR22_TWS_VERSION版本号进行递增，否则会出现升级完成后再次在线烧录程序时跑的还是旧程序的情况，这时候需要重新擦除整块flash或重新格式化SD卡。
>
>
> # 7.47. 第三方数据（认证码）烧写功能
>
> **Overview**
>
> 将认证码烧写到flash提供两种方式：1.通过tools目录下isd_download.exe进行烧写，主要用于测试使用；2.通过烧写器烧写，主要用于量产。
>
> **1.方式一：利用tools进行烧录**
>
>> ```
>> （1）修改download.c文件，增加配置-auth-code $(fileName), 如：-auth-code auth_code.txt
>> isd_download.exe isd_config.ini -tonorflash -dev wl82 -boot 0x1c02000 -div1 -wait 300 -uboot uboot.boot -app app.bin cfg_tool.bin -res %AUDIO_RES% %UI_RES% cfg -reboot 500 %UPDATE_FILES% -extend-bin -auth-code auth_code.txt
>>
>> （2）在download.c同级目下增加auth_code.txt文件，内容为auth code。
>> ```
>>
>
> **2.方式二：通过烧写器进行烧写**
>
>> (具体请参考： 第三方数据（认证码）烧写功能 ).
>>
>
> **3.设备端读取AUTH CODE方法**
>
>> ```
>> （1）将auth_code_cfg.c加入到工程中。
>>
>>  (2)读取：
>>   char code[127]; //用于保存读取到的auth code
>>   int len;        //读取到的auth code长度
>>
>>   if (0 == get_auth_code(code, &len))
>>   {
>>         put_buf(code, len);
>>   }else{
>>         puts("get_auth_code err\n");
>>   }
>> ```
>>
