# 6. VIDEO部分

# 6.1. 有关摄像头的应用

* wifi_camera:工程为航拍图传工程，将摄像头数据传到手机。
* wifi_story:绘本故事，将摄像头数据采集上发到服务器进行算法处理。
* 二维码类:收款播音盒-识别二维码算法本地端，二维码配网。
* 扫描笔:将摄像头数据上发服务器进行图像拼接，本地端也支持图像拼接。
* 儿童相机:拍照功能。
* 791x系列支持摄像DVP8BIT(yuv422),DVP单线（YUV422）,SPI单线双线（YUV420,YUV422,only_y）,uvc(usb摄像头)支持UVC1.1-USB2.0（有些摄像头不兼容）。
* 有关航拍图传数据，任何摄像头均能进行图传到手机进行显示。Y数据需要补齐UV数据格式后才行，最高帧数30fps。

## 6.1.1. 有关摄像头帧数,以及图层

直推：(数据直接到屏)1280*720帧数12帧648*480帧数25帧

带图层：(带软件图像合成开放源代码具体请参考ui部分)1280*720帧数10帧640*480帧数20帧

UVC摄像头出图（VGA摄像头）直推 屏320*240（动态30帧）屏480*320（动态15帧）

图像合成 屏320*240（动态20帧）屏480*320（动态14帧）

app_config.h中需要开启CONFIG_QR_CODE_NET_CFG //二维码配网 该宏 以及需要包含二维码算法库libqrcode.a 二维码测试线程,路径apps/wifi_camera/ui_camera_demo/qr_code.c

### 6.1.1.1. 图传、录卡或者UVC显示的摄像头-高帧率说明

摄像头高帧率：20帧以上，则需要修改工程配置才能达到高帧率传输或显示，以下修改为：**wifi_camera**工程，其他工程大同小异。

**（1）修改app_config.h的VIDEO_REC buffer模式和输出帧率**

> 注释乒乓buff模式，恢复使用lbuf如下：
>
> ```
> //（1）buffer模式：注释CONFIG_VIDEO_REC_PPBUF_MODE。
> //#define CONFIG_VIDEO_REC_PPBUF_MODE
>
> //（2）图传或UVC显示的输出帧率：如设置25。
> #define  NET_VIDEO_REC_FPS0               25  //不使用0作为默认值，写具体数值
>
> //（3）音频数据：有则采样率为8000，没有则为0，如下为0。
> #define VIDEO_REC_AUDIO_SAMPLE_RATE     0
>
> //（4）SD卡录像的帧率：没有SD卡则0或不修改，如25帧。
> #define VIDEO_REC_FPS                   25
> ```

**（2）确定工程没有开CONFIG_NO_SDRAM_ENABLE宏，工程使用sdram**

> windows环境，coldblocks：打开cbp工程，右键工程，build options—>compiler—>#define选项，查看是否含有：CONFIG_NO_SDRAM_ENABLE，有则说明不需要sdam，没有则需要sdram。在高帧率情况下，都是需要sdram，内存才足够，否则是无法满足高帧率。因此需要去掉：CONFIG_NO_SDRAM_ENABLE。
>
> linux环境，makefile：关闭CONFIG_NO_SDRAM_ENABLE宏。

**（3）修改video_buf_config.h的应用层视频缓冲区大小**

> video_buf_config.h对应内存配置说明如下，一般修改图传和UVC显示：NET_VREC0_FBUF_SIZE为300K即可。
>
> ```
> #define VIDEO0_REC_FORMAT   VIDEO_FMT_AVI
> #define VIDEO1_REC_FORMAT   VIDEO_FMT_AVI
> #define VIDEO2_REC_FORMAT   VIDEO_FMT_AVI
> #ifdef CONFIG_PSRAM_ENABLE
> #define VREC0_FBUF_SIZE     (512*1024)
> #define VREC1_FBUF_SIZE     (256*1024)
> #define VREC2_FBUF_SIZE     (256 * 1024)
> #define AUDIO_BUF_SIZE      (256*1024)
> #else
> #if (!defined CONFIG_NO_SDRAM_ENABLE && __SDRAM_SIZE__ >= (2 * 1024 * 1024))
> #define VREC0_FBUF_SIZE     (500*1024)//开sdram，SD卡录像视频缓冲区
> #define VREC1_FBUF_SIZE     (0)
> #define VREC2_FBUF_SIZE     (0)
> #define AUDIO_BUF_SIZE      (64*1024)//开sdram，SD卡录像音频缓冲区，没有音频写0
> #else
> #define VREC0_FBUF_SIZE     (150*1024)//不开sdram，SD卡录像修改这里
> #define VREC1_FBUF_SIZE     (0)
> #define VREC2_FBUF_SIZE     (0)
> #define AUDIO_BUF_SIZE      (16*1024)//不开sdram，SD卡录像音频缓冲区，没有音频写0
> #endif
> #endif
>
> #define USB_CAMERA_BUF_SIZE (1 * 1024 * 1024) // + 512 * 1024)
> #define CAMERA_CAP_BUF_SIZE (1 * 1024 * 1024)
>
>
> #if (!defined CONFIG_NO_SDRAM_ENABLE && __SDRAM_SIZE__ >= (2 * 1024 * 1024))
> #define NET_VREC0_FBUF_SIZE     (200*1024)//开sdram，图传或UVC显示视频缓冲区
> #define NET_VREC1_FBUF_SIZE     (0)
> #define NET_AUDIO_BUF_SIZE      (64*1024)//开sdram，图传或UVC显示音频缓冲区，没有音频写0
> #else
> #define NET_VREC0_FBUF_SIZE     (100*1024)//不开sdram，图传或UVC显示视频缓冲区
> #define NET_VREC1_FBUF_SIZE     (0)
> #define NET_AUDIO_BUF_SIZE      (16*1024)//开sdram，图传或UVC显示音频缓冲区，没有音频写0
> #endif
> ```
>
> ①当使用SD卡录像则可以修改：VREC0_FBUF_SIZE 和 AUDIO_BUF_SIZE大小；当需要提高视频帧率或者视频卡顿现象，改大：VREC0_FBUF_SIZE（一般VGA 500K， 720P 800K）；当需要提高音频卡顿现象，改大：AUDIO_BUF_SIZE（一般128K）。
>
> ②当使用网络图传或UVC显示则可以修改：NET_VREC0_FBUF_SIZE 和 NET_AUDIO_BUF_SIZE大小；当需要提高视频帧率或者视频卡顿现象，改大：NET_VREC0_FBUF_SIZE （ **一般VGA 300K， 720P 500K** ）；当需要提高音频卡顿现象，改大：NET_AUDIO_BUF_SIZE（一般128K）。
>
> ③**确定user_video_rec.c有没有添加到工程，wifi_camera工程默认不加**
>
> 当user_video_rec.c添加到工程编译，则在文件中修改：USER_VREC0_FBUF_SIZE 大小（一般为300K，使用音频需改善音频卡顿则修改：USER_AUDIO_BUF_SIZE（一般128K），没有音频则USER_AUDIO_BUF_SIZE为0），其他demo则USER_VREC0_FBUF_SIZE在对应的app_config.h。

**（4）修改提高摄像头源视频输出帧率，确定摄像头源输出高帧率**

> ①例如DVP-GC0308摄像头驱动设置25帧：
>
> #define CONFIG_INPUT_FPS 25
>
> **注意：摄像头输出帧率需要确保是源头帧率，不能只修改CONFIG_INPUT_FPS的值，如原本驱动只能15帧，修改驱动软件的CONFIG_INPUT_FPS为25是不能提高摄像头帧率的，需要修改摄像头寄存器配置。**
>
> ②UVC摄像头则默认20-25帧，具体需要查看UVC摄像头数据手册如何更改帧率，一般不修改。

**（5）使用网络图传则更换lwip库和wifi库**

> 使用网络进行视频传输（图传功能）则： ①lwip_2_1_2_sfc.a换lwip_2_1_2.a；
>
> ②wl_wifi_ap_sfc.a换wl_wifi_ap.a；
>
> 或使用STA的wl_wifi_sta_sfc.a换wl_wifi_sta.a；
>
> 或者wl_wifi_sfc.a换wl_wifi.a。

**（6）在图传中，需要提高图片质量**

> 在 ``https://doc.zh-jieli.com/AC79/zh-cn/master/module_example/video/1.camera.html#id3)net_video_rec.c `` 修改码率，适当提高码率（1000-6000），如下。
>
> ```
> /*码率控制，根据具体分辨率设置*/
> static int net_video_rec_get_abr(u32 width)
> {
>  /*视频码率kbps使用说明:
>   码率：一帧图片以K字节为单位大小 * 帧率 * 8，比如：一帧图片为30KB，帧率为20帧，则码率为30*20*8=4800
>   VGA图片大小说明：低等质量(小于20K)，中等质量(20K-40K)，高质量(大于40K，极限70K)
>   720P图片大小说明：低等质量(小于50K)，中等质量(50k-100K)，高质量(大于100K，极限150K)
>  */
>
>  if (width <= 640) {
>      return 1800;
>  } else {
>      return 1000;
>  }
> }
> ```
>
> 如果是SD卡录像，则修改码率在 `video_rec.c` 的 `video_rec_get_abr()` 函数。

# 6.2. DVP摄像头出图

* 代码路径 `apps/common/example/video/camera/dvp/dvp_8bit_mode/main.c`
* 使用工程 `apps/demo/demo_DevKitBoard/board/wl82/AC791N_DEMO_DEMO_DEVKITBOARD.CBP`
* 开发板提供了两个摄像头一个为1280x720大小的DVP摄像头另一个为640x480大小的SPI摄像头
* 找到 `demo_config.h` 文件,将USE_CAMERA_DVP_SHOW_TO_LCD_DEMO开起（确保其余宏全关闭）
* 编译即可

## 6.2.1. 实验现象

屏幕出现摄像头的数据

## 6.2.2. 摄像头介绍

该摄像头型号为GC2145,最高分辨率1600x1200,最高帧数30帧。 代码里面采用1280x720大小，帧数20帧。

## 6.2.3. 代码讲解

代码流程: —>系统服务层—>系统设备层—>设备层驱动层—>摄像头驱动—>屏幕。

* 通过调用get_yuv_init(get_yuv); 开启摄像头。
* 驱动遍历所有摄像头驱动逐个读取摄像头ID到直达读对ID号
* 确认摄像头型号后将发送摄像头配置，收摄像头数据。
* 硬件接摄像头数据将YUV420数据传到应用层。
* 应用层在get_yuv();回调函数中进行取数据;
* YV420数据进行缩放为屏幕大小的YUV数据传给屏驱动里面进行处理
* 屏驱数据处理里面会将YUV屏大小的数据转RGB565然后推到屏幕显示。
* 用户不需要关心底层是如何收数据，加快工程的开发进度。

## 6.2.4. 摄像头分辨率配置说明

`app_config.h` 中 进行配置摄像头的大小

```
//摄像头尺寸，此处需要和摄像头驱动可匹配，默认摄像头为640*480
//#define CONFIG_VIDEO_720P
#ifdef CONFIG_VIDEO_720P
#define CONFIG_VIDEO_IMAGE_W    1280
#define CONFIG_VIDEO_IMAGE_H    720
#else
#define CONFIG_VIDEO_IMAGE_W    640
#define CONFIG_VIDEO_IMAGE_H    480
#endif
```

文件路径： `apps\demo\demo_DevKitBoard\board\wl82\JL_AC79_DevKitBoard`

板级配置如下，工程默认是给配置好了的 以下的为举例说明

```
//---------------------------摄像头相关硬件配置------------------------//
/*
*摄像头软件IIC
*/
SW_IIC_PLATFORM_DATA_BEGIN(sw_iic0_data)
    .clk_pin = IO_PORTC_01,//摄像头的IIC CLK IO
    .dat_pin = IO_PORTC_02,//摄像头的IIC SDA IO
    .sw_iic_delay = 50,//软件iic延时nop
SW_IIC_PLATFORM_DATA_END()

/*
*摄像头IO-PORT
*/
#ifdef CONFIG_VIDEO_ENABLE
#define CAMERA_GROUP_PORT   ISC_GROUPA //摄像头数据接口接芯片的PA口
/* #define CAMERA_GROUP_PORT        ISC_GROUPC //摄像头数据接口接芯片的PC口 */
static const struct camera_platform_data camera0_data = {
.xclk_gpio      = IO_PORTC_00,//供时钟注意： 如果硬件xclk(mclk)接到芯片IO，24MHz会占用OUTPUT_CHANNEL1，12MHz会占用OUTPUT_CHANNEL0
.xclk_hz        = 0, // 0或24-->xclk out:24MHz, 12-->xclk out:12MHz ，默认24M即可
.reset_gpio     = IO_PORTC_03,//复位IO，一般该引脚可以直接接3.3V的高电平，不需要特定IO来控制
.online_detect  = NULL,//默认NULL即可
.pwdn_gpio      = -1,//pwdn引脚可以配合引脚写具体IO如IO_PORTC_04，一般摄像头pwdn引脚直接接地即可，具体要看摄像头数据手册
.power_value    = 0,//pwdn引脚使用IO控制时的正常工作pwdn引脚电平
.interface      = SEN_INTERFACE0,//SEN_INTERFACE_CSI2,//默认即可
.dvp={
 #if (CAMERA_GROUP_PORT == ISC_GROUPA)//不同数据接口配置的摄像头pclk和hsync和vsync
        .pclk_gpio   = IO_PORTA_08,
        .hsync_gpio  = IO_PORTA_09,
        .vsync_gpio  = IO_PORTA_10,
        #else
        .pclk_gpio   = IO_PORTC_08,
        .hsync_gpio  = IO_PORTC_09,
        .vsync_gpio  = IO_PORTC_10,
 #endif
        .group_port  = CAMERA_GROUP_PORT,
        .data_gpio={
 #if (CAMERA_GROUP_PORT == ISC_GROUPA)//不同数据接口配置的摄像头数据接口IO
                    IO_PORTA_07,//从7到0
                    IO_PORTA_06,
                    IO_PORTA_05,
                    IO_PORTA_04,
                    IO_PORTA_03,
                    IO_PORTA_02,
                    IO_PORTA_01,
                    IO_PORTA_00,
                            -1,
                            -1,
        #else
                    IO_PORTC_07,//从7到0
                    IO_PORTC_06,
                    IO_PORTC_05,
                    IO_PORTC_04,
                    IO_PORTC_03,
                    IO_PORTC_02,
                    IO_PORTC_01,
                    IO_PORTC_00,
                            -1,
                            -1,
        #endif
        },
    }
};
static const struct video_subdevice_data video0_subdev_data[] = {//镜头设备参数
{
VIDEO_TAG_CAMERA, (void *)&camera0_data },
};
static const struct video_platform_data video0_data = {//video参数,设备列表参数需要该参数
.data = video0_subdev_data,
.num = ARRAY_SIZE(video0_subdev_data),
};
#endif


//---------------------------设备列表------------------------//
REGISTER_DEVICES(device_table) = {
    { "iic0",  &iic_dev_ops, (void *)&sw_iic0_data },
    { "audio", &audio_dev_ops, (void *)&audio_data },
#ifdef CONFIG_VIDEO_ENABLE
    { "video0.*",  &video_dev_ops, (void *)&video0_data },//添加vdeo设备
#endif
    {"uart2", &uart_dev_ops, (void *)&uart2_data },
};
```

将设备注册到驱动，初始化的时候会通过该这些配置来初始化IO等配置。

## 6.2.5. 常见问题说明

1、摄像头IIC检测出错，id无法检测。A）排查board.c ：IIC、xclk、pwdn_gpio、power_value有没有配置正确，根据摄像头数据手册确定摄像头pwdn正常工作电平。

B）确定xclk输出到摄像头时钟正常（可以用示波器、逻辑分仪抓取），确定xclk IO是否被占用， 当供给摄像头的时钟xclk不正常时无法读取id！

C）确定摄像头是否已经损坏，当接通电源发热严重则可能电源不对或者电源接反！

2、摄像头id读取正常，但出现“isc line in err ”或者“isc line out err”打印，说明摄像头行数据输出到cpu的行数出错。

> A）确定hsync和vsync接线是否正确。
>
> B）确定app_config.h配置的CONFIG_VIDEO_IMAGE_W和CONFIG_VIDEO_IMAGE_H是否在镜头的输出范围内。

3、出现“isc bwerr !!!”和“osd bandwith err”，说明cpu带宽不足。

> A）确定摄像头输出帧率和分辨率是否过高导致出现带宽不足。
>
> B）把相应的video的buffer指定到内部sram，或者提高系统的频率。详见系统各模块时钟介绍

# 6.3. DVP单线说明

* 开发板不提供DVP单线测试提供SPI双线接收
* DVP单线一般应用在接收黑白数据和图像小要求帧数快的情况，实际应用扫描笔摄像头（120x180 only_y数据 50fps）
* 详细代码请产考 `spi_video.c`
* 需要注意的是硬件连接DVP单线采用硬件接收数据格式为BT656
* DVP单线和8BIT是通过版籍中camera_data进行区分一般默认camera0_data为DVP8_bit设备,camera1_data为1bit设备
* 提供的摄像头驱动中byd30a2为单线，byd20a6为单线。

```
///////////////BT656硬件接收////////////////
#define SPI_VIDEO_PCLK_PORT         IO_PORTC_08
#define SPI_VIDEO_MISO_PORT         IO_PORTC_07
///////////////////////////////////////////
```

* 设备需要带2M以上的SDRAM，走DVP单线接收需要开启

```
#define SPI_VIDEO_USE_SPI_RECV              1   //1使用SPI接收(需要软件分离YUV),0使用硬件接收YUV
```

# 6.4. spi_camera说明

spi板级配置举例

```
  SPI1_PLATFORM_DATA_BEGIN(spi1_data)
      .clk    = 20000000,
      .mode   = SPI_STD_MODE,//SPI_1WIRE_MODE（单线模式） SPI_STD_MODE（双线模式） SPI_DUAL_MODE（全双工模式） SPI_QUAD_MODE（四线模式）
      .port   = 'B'，
      .attr   = SPI_SCLK_L_UPH_SMPH | SPI_BIDIR_MODE,

  SPI1_PLATFORM_DATA_END()

{ "spi1", &spi_dev_ops, (void *)&spi1_data }, //注册设备
```

spi摄像头请参考c文件路径： `apps/wifi_story_machine/spi_recv.c` ，不同的摄像头有些协议不同可以自行定义

# 6.5. uvc_camera说明

## 6.5.1. USB配置

版籍

```
#ifdef CONFIG_USB_ENABLE
static const struct otg_dev_data otg_data = {
    .usb_dev_en = 0x03,
#if TCFG_USB_SLAVE_ENABLE
    .slave_online_cnt = 10,
    .slave_offline_cnt = 10,
#endif
#if TCFG_USB_HOST_ENABLE
    .host_online_cnt = 10,
    .host_offline_cnt = 10,
#endif
    .detect_mode = OTG_HOST_MODE | OTG_SLAVE_MODE | OTG_CHARGE_MODE,
    .detect_time_interval = 50,
};
#endif

{ "otg", &usb_dev_ops, (void *)&otg_data},//注册USB设备
```

app_config.h 需要使能UVC宏即可

```
#define TCFG_HOST_UVC_ENABLE    1//打开USB 后拉摄像头功能，需要使能住机模式
```

具体应用请查看 `apps/wifi_camera/ui_camera_demo/camera_lcd_only_show_demo.c`

带UI的请查看 `apps/wifi_camera/ui_camera_demo/camera_demo.c`

# 6.6. 图像处理

工程内支持多种图像处理

* 支持播放GIF, JPG, PNG
* 支持任意尺寸缩放，裁剪，图像旋转。（具体查看 `yuv_soft_scalling.h` ）
* 支持多种数据转换 RGB565->yuv420, YUV420->RGB565等等（具体查看 `yuv_to_rgb.h` ）
* 支持软件图像合成代码开放 `lcd_data_driver.c`
* 支持JPG->YUV, YUV->JPG。
* 支持同步帧处理te_driver文件夹

1、播放GIF已经封装好成api函数使用，路径 `apps/common/ui/gif_api.c`

2、播放JPG已经封装好成api测试线程，路径 `apps/wifi_camera/ui_camera_demo/sd_play_jpg_mp3.c`

3、播放PNG需要开启UI使用UI工程加载PNG文件，demo_ui工程中UI_DEMO_1_0.c控件测试。

4、有关图像合成应用在camera出图时需要图像上显示一些时间信息或者大头框等

该相机为儿童拍照打印相机量产在售，支持前后双摄，320x240分辨率，摄像头640x480帧数20帧无条纹切线，拍照将数据打印出来或者上传到手机。

## 6.6.1. 图像转码例子

相关测试例子查看路径 `apps/common/example/video/image`

## API参考

**Functions**

u16 **rgb_24_to_565**(u8 R, u8 G, u8 B)
void **yuv420p_quto_rgb24**(unsigned char *yuvBuffer_in, unsigned char *rgbBuffer_out, int width, int height)
void **yuv420p_quto_rgb565**(unsigned char *yuvBuffer_in, unsigned char *rgbBuffer_out, int width, int height, char be)
void **yuv422p_quto_rgb565**(unsigned char *yuvBuffer_in, unsigned char *rgbBuffer_out, int width, int height, char be)
void **yuv444p_quto_rgb565**(unsigned char *yuvBuffer_in, unsigned char *rgbBuffer_out, int width, int height, char be)
int **rgb565_to_yuv420p**(unsigned char *rgb565, unsigned char *yuv420p, int width, int height, char be)
int **rgb24_to_yuv420p**(unsigned char *rgb24, unsigned char *yuv420p, int width, int height)
void **RGB565_to_RGB888**(unsigned char *rgb565, unsigned char *rgb888, int width, int height)
void **RGB888_to_YUV420**(u8 *rgb_buf, u8 *yuv_buf, u16 width, u16 heigh)
void **yuv420p_quto_rotate_rgb565**(u8 *in_yuv, u8 *out_rgb, int in_w, int in_h)
void **yuv422p_quto_rotate_rgb565**(u8 *in_yuv, u8 *out_rgb, int in_w, int in_h)

**Functions**

int **YUYV422ToYUV422p**(unsigned char *yuyv, unsigned char *yuv422p, int width, int height)
int **YVYU422ToYUV422p**(unsigned char *yvyu, unsigned char *yuv422p, int width, int height)
int **YUV444pToYUV422p**(unsigned char *yuv444p, unsigned char *yuv422p, int width, int height)
int **YUV420p_ZOOM**(unsigned char *src, unsigned char *out, int src_w, int src_h, int out_w, int out_h)
int **YUV420p_Soft_Scaling**(unsigned char *src, unsigned char *out, int src_w, int src_h, int out_w, int out_h)
int **YUV420p_Cut**(unsigned char *yuv420p, int src_w, int src_h, unsigned char *out, int out_size, int w_start, int w_size, int h_start, int h_size)
void **RGB565_Soft_90**(unsigned char mode, u16 *out_buf, u16 *in_buf, int width, int height)
void **jl_nearest_inter_line**(int line_8, int time_16, int src_w, int src_h, int dst_w, int dst_h, unsigned char *src, unsigned char *dst)

struct **image_info**
Public Members

int **w**
int **h**
union image_info::**[anonymous]** **[anonymous]**

image_info.__unnamed49__Public Members

unsigned **char** ***pixels**
unsigned **char** ***data**
unsigned **char** ***data16**

# 6.7. 二维码配网说明

> 0. 打开微信搜索公众好杰理智能机器人点击右下角更多打开二维码配网。
> 1. 输入wifi名，以及密码点击显示二维码即可然后将二维码对准设备摄像头即可完成配网（需要进入设备配网模式）

## 6.7.1. 代码说明

app_config.h中需要开启CONFIG_QR_CODE_NET_CFG //二维码配网 该宏 以及需要包含二维码算法库libqrcode.a

```
在video_rt_usr.c中 该函数创建了摄像头的调用 以及二维码算法的运行
void config_network_get_yuv_init(void)
{
    get_yuv_init(get_one_frame);
}
config_network_get_yuv_init();包含在config_network.c的config_network_start（）中 所以我们在自己定义二维码配网时候调用该函数即可
当配好了网后可调用 config_network_stop(); 就能停止二维码配网
```

# 6.8. 二维码编码说明

* 二维码编码库enc_qr_coed.a
* 二维码编码测试例子

example: 具体示例代码详见 `apps/common/example/video/image/qr_enc/main.c`

**Note**

> 测试代码备注 QR_LEN 为生成出来的最大尺寸，实际生成的值不一定为 QR_LEN 具体生成的长度需要计算 计算公式 当前版本号假如为 5 最小长度为 21+5*4 = 37，再根据之前设定的最大长度做整除倍数，即长度只能为37的帧数倍 代码会根据你给的长度输出一个最大的正方形数据 纠错等级注释：纠错等级的作用为当二维码存在部分遮挡的情况时二维码一样能识别出来，一般屏不纯在遮挡纠错等级配置为1即可。 输入版本号和最大版本号解析：库会以你输入的版本号给你输出二维码当字符串过长二维码会自动升级版本号去处理这样就会导致输出 的尺寸不能完全覆盖申请的BUF会纯在空白区域。

* 库函数说明

```
EAN_13:只能编码0-9的数字，且输入数据长度必须是12。

Code_39: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ+- /%$.",Code_39只能编码如上的字符。
Code_128:ASCII码的字符都可以编码
Qr_code:ASCII码的字符都可以编码
条形码输入，输出长度说明：
EAN_13:输入长度12，输出长度113
Code_39:输入长度设为l，输出长度为（l+2）*13。图像宽度为width ,则最大输入长度为(width  / 13) - 2;（一个输出至少占两个像素）
Code_128:输入长度设为l，输出最大长度为（l+3）*11+2，图像宽度为width ,则最大输入长度为((width -2) / 11) - 3;（一个输出至少占两个像素）
函数接口说明：void jl_code_init(int code128_mode,uint8_t qr_version, uint8_t qr_max_version,uint8_t qr_ecc_level,int qr_code_max_input_len_,int qr_buf_size,int img_w);
描述：初始化函数
code128_mode:code_128的编码方式。设置为60，则会把本该按照版本C编码的字符按照版本B去编；不想这么做则将其设为其它的任何值。
qr_version：qr_code的版本号。该值设置为1-qr_max_version时，编码时会按照该版本号进行编码。设置为其他值时，编码时内部会计算自动的版本号。
qr_max_version：qr_code的最大版本号。会根据最大版本号开辟内存。建议不超过版本12。
qr_ecc_level：qr_code的纠错等级。该值设置为1-4时，编码时会按照该纠错等级进行编码。设置为其他值时，编码时内部会计算自动的纠错等级。
qr_code_max_input_len_：qr_code的最大输入长度。建议不超过384。
qr_buf_size：qr_code内部用的buffer大小。建议给4K。
img_w：图像的宽度。
int jl_code_process(unsigned char mode_t,char * src, int length, int *out_len,int *line_size)
描述：编码函数
 mode_t:编码模式。0：EAN13；1：code_39;2:code_128;3:qr_code。
src：待编码数据。
length:待编码数据的实际长度（注意不能超过对应模式的最大长度）
out_len：码的实际长度
line_size：一个码元素最大占的像素个数
返回值：若不为1，则说明没有编码，可能是输入数据格式不对或输入数据超过最大长度等。若为1，则代表编码成功。
lvoid jl_code_set_info(jl_code_param_t *jl_code_param_)
描述：设置一个码元素占的像素个数，注意不能超过一个码元素最大占的像素个数。
void jl_code_get_data(int len,int row, unsigned char *outdata)
描述：获取编码数据
len：码的实际长度
row：当为二维码时，表示获取第几行的数据；否则，设置为0即可。
outdata：编码数据buf
void jl_code_deinit();
描述：结束时调用该函数，用于释放内存。
内存大小：
EAN_13,code_39,code_128:  大约1831bit
qr_code:      大约1826bit
jl_code_init: qr_buf_size+4*(21+(qr_max_version-1))*(21+(qr_max_version-1))
若qr_buf_size为4096，qr_max_version为12，则20996
合计：24653bit，约为24K。
```

# 6.9. 二维码解码说明

* 二维码解码库qr_coed.a
* 二维码解码测试例子

example: 具体示例代码详见 `apps/wifi_camera/ui_camera_demo/qr_code.c`

# 6.10. 扫描笔图像拼接说明

本例子使用SPI摄像头BYD30A2输出only_Y(黑白)，图像大小176*128，帧率50帧。图像拼接算法库为img_stitch.a杰理自研拼接算法 。图像拼接帧率为66帧以上即满足一次图像数据来到下一张图像来的时间段完成一次拼接并输出数据。

## 6.10.1. 依赖文件

> spi_recv.c用于开启收摄像头并接收数据以及转发数据，spi_data_deal.c处理摄像头数据并进行拼接算法。byd30a2.c摄像头驱动。app_music.c摄像头初始化以及按键处理（img_stitch.a算法库文件 ，fast_corner.h, img_stitch.h, img_transform.h, matrix_process.h算法库头文件4个）

## 6.10.2. 拼接参数以及函数说明

* 初始化接口 img：第一帧图像 width，height：输入图像分辨率
* output_img：输出图像 w_out，h_out：拼接后输出图像分辨率
* outh_off：输出图像行移动的像素数
* Max_corner_count：角点最大数量，通常取128或64
* Fast_corner_mode：0和1两种模式，通常取1 Fast_th：角点阈值，通常取80左右
* Match_th：匹配阈值，通常取2560或2560*4/3
* offset_th：预匹配的阈值，通常取5
* nms_windon_size:非极大值抑制的窗口，一般取7
* Max_filter_th_x，Max_filter_th_y：最大值滤波的x,y方向的阈值，一般取5，3
* Frame_stride：拼接时帧的步长，一定程度上减缓拼接后的缝隙
* Adjustment_enable：处理放大问题的使能
* max_off：行偏移的最大数，提高匹配的速度。 void
* mg_stitch_reinit(uint8_t*img, int width, int height, uint8_t
* output_img, int w_out, int h_out, int outh_off, int Max_corner_count,
* int Fast_corner_mode, uint32_t Fast_th, uint32_t Match_th, int
* Adjustment_enable); 重新初始化接口 void img_stitch_deinit();
* 结束时调用该接口，释放内存 int img_stitch_process(uint8_t*src_img,
* uint8_t *dst_img, uint8_t*output_img, uint8_t flag_force_stitch,
* uint8_t flag_force_exit); src_img：第一帧图像 dst_img：第二帧图像
* output_img：拼接后输出图像
* flag_force_stitch：是否强制拼接（当拼接失败后，可以返回，也可以将该值设置为1，则会按照上一帧拼接的结果来拼接）
* flag_force_exit：1代表强制推出。
* 返回值：返回1代表拼接成功，否则拼接失败。若为6，说明拼接后的输出图像达到了给定的最大buf，再继续拼接，会出现内存泄露。
* int post_process(uint8_t *src, uint8_t*dst, int width, int height, int
* center_x, int center_y); 后处理接口:对图像进行旋转矫正 src:输入图像
* dst：输出图像 width, height:输入和输出图像的分辨率
* center_x,center_y：中心点（拼接图像的中心点，行需要加上outh_off）
* 返回值为1代表进行了矫正，为0代表没有进行矫正 enum img_stitch_status {
* success = 1, corner_count_err, match_count_err, mapping_err,
* direction_err, out_w_err, force_exit_err, };

## 6.10.3. 操作说明

* 确认工程中是否添加好对应依赖文件没有的话请自行进行添加。
* #ifdef CONFIG_SCAN_PEN_ENABLE
* #define CONFIG_VIDEO1_ENABLE
* #define CONFIG_SPI_VIDEO_ENABLE
* #endif
* 注意CONFIG_SCAN_PEN_ENABLE定义及开启了CONFIG_VIDEO1_ENABLE，
* CONFIG_SPI_VIDEO_ENABLE 这个是摄像头使能宏
* 测试代码在工程AC790N_picture_book_story，找到app_config.h。
* 使用名字CONFIG_BOARD_7901BA_TEST_STORY板级
* 打开CONFIG_SCAN_PEN_ENABLE宏需要自行确认硬件配置，不然测试无法正常进行。
* 将扫描笔头放置书本上，并触发目标按键按下，进行拼接代码。扫描笔抬起结束拼接并将结果保存SD卡中。

## 6.10.4. 代码流程

> 在 `app_music.c` 中调度开始 具体请阅读 `apps/wifi_story_machine/spi_data_deal.c`

# 6.11. 人脸识别

**Overview**

提供人脸识别应用示例和注意事项。

## 6.11.1. 应用示例

**示例演示：**

example: 具体示例代码详见 `apps/common/example/video/camera/dvp/main.c` ，示例工程实现需在 `apps/demo/demo_DevKitBoard/include/demo_config.h` 中开启宏 `#define USE_CAMERA_DVP_SHOW_TO_LCD_DEMO` 和 `#define FACE_DETECT_DEMO`

> 1. 开启工程前要确保摄像头和屏幕可以正常出图具体可以参考 DVP摄像头出图
> 2. 添加库文件 `libjlsp_facedet_simd.a`。
> 3. 识别成功打印会出对应坐标

## 6.11.2. 注意事项

1.注意背景不要有强光

例子使用SPI摄像头BYD30A2输出only_Y(黑白)，图像大小176*128，帧率50帧。图像拼接算法库为img_stitch.a杰理自研拼接算法 。图像拼接帧率为66帧以上即满足一次图像数据来到下一张图像来的时间段完成一次拼接并输出数据。

## 6.10.1. 依赖文件

> spi_recv.c用于开启收摄像头并接收数据以及转发数据，spi_data_deal.c处理摄像头数据并进行拼接算法。byd30a2.c摄像头驱动。app_music.c摄像头初始化以及按键处理（img_stitch.a算法库文件 ，fast_corner.h, img_stitch.h, img_transform.h, matrix_process.h算法库头文件4个）

## 6.10.2. 拼接参数以及函数说明

* 初始化接口 img：第一帧图像 width，height：输入图像分辨率
* output_img：输出图像 w_out，h_out：拼接后输出图像分辨率
* outh_off：输出图像行移动的像素数
* Max_corner_count：角点最大数量，通常取128或64
* Fast_corner_mode：0和1两种模式，通常取1 Fast_th：角点阈值，通常取80左右
* Match_th：匹配阈值，通常取2560或2560*4/3
* offset_th：预匹配的阈值，通常取5
* nms_windon_size:非极大值抑制的窗口，一般取7
* Max_filter_th_x，Max_filter_th_y：最大值滤波的x,y方向的阈值，一般取5，3
* Frame_stride：拼接时帧的步长，一定程度上减缓拼接后的缝隙
* Adjustment_enable：处理放大问题的使能
* max_off：行偏移的最大数，提高匹配的速度。 void
* mg_stitch_reinit(uint8_t*img, int width, int height, uint8_t
* output_img, int w_out, int h_out, int outh_off, int Max_corner_count,
* int Fast_corner_mode, uint32_t Fast_th, uint32_t Match_th, int
* Adjustment_enable); 重新初始化接口 void img_stitch_deinit();
* 结束时调用该接口，释放内存 int img_stitch_process(uint8_t*src_img,
* uint8_t *dst_img, uint8_t*output_img, uint8_t flag_force_stitch,
* uint8_t flag_force_exit); src_img：第一帧图像 dst_img：第二帧图像
* output_img：拼接后输出图像
* flag_force_stitch：是否强制拼接（当拼接失败后，可以返回，也可以将该值设置为1，则会按照上一帧拼接的结果来拼接）
* flag_force_exit：1代表强制推出。
* 返回值：返回1代表拼接成功，否则拼接失败。若为6，说明拼接后的输出图像达到了给定的最大buf，再继续拼接，会出现内存泄露。
* int post_process(uint8_t *src, uint8_t*dst, int width, int height, int
* center_x, int center_y); 后处理接口:对图像进行旋转矫正 src:输入图像
* dst：输出图像 width, height:输入和输出图像的分辨率
* center_x,center_y：中心点（拼接图像的中心点，行需要加上outh_off）
* 返回值为1代表进行了矫正，为0代表没有进行矫正 enum img_stitch_status {
* success = 1, corner_count_err, match_count_err, mapping_err,
* direction_err, out_w_err, force_exit_err, };

## 6.10.3. 操作说明

* 确认工程中是否添加好对应依赖文件没有的话请自行进行添加。
* #ifdef CONFIG_SCAN_PEN_ENABLE
* #define CONFIG_VIDEO1_ENABLE
* #define CONFIG_SPI_VIDEO_ENABLE
* #endif
* 注意CONFIG_SCAN_PEN_ENABLE定义及开启了CONFIG_VIDEO1_ENABLE，
* CONFIG_SPI_VIDEO_ENABLE 这个是摄像头使能宏
* 测试代码在工程AC790N_picture_book_story，找到app_config.h。
* 使用名字CONFIG_BOARD_7901BA_TEST_STORY板级
* 打开CONFIG_SCAN_PEN_ENABLE宏需要自行确认硬件配置，不然测试无法正常进行。
* 将扫描笔头放置书本上，并触发目标按键按下，进行拼接代码。扫描笔抬起结束拼接并将结果保存SD卡中。

## 6.10.4. 代码流程

> 在 `app_music.c` 中调度开始 具体请阅读 `apps/wifi_story_machine/spi_data_deal.c`

# 6.12. 如何调试一款新摄像头

本节旨在让用户快速调试新型号（dvp/spi接口）摄像头出图；

AC79 有两个 ISC （图像传感器控制模块）（ISC0/1），用于接收片外 Image CMOS Sensor 的图像数据，完成数据重排和处理；

其支持传统 8bit 的 DVP、BT601、BT656 接口，除此之外还支持以上接口的串行化，如 4/2/1bit 的 DVP、BT601、BT656，支持 SPI 模式；

推荐使用ISC接收，兼容DVP和SPI模式，用户不需要关心底层是如何收数据，仅需根据需求修改接口配置及摄像头寄存器配置，加快工程的开发进度。

## 6.12.1. 必要说明

> * 板载硬件说明
>   > 板载摄像头型号及接口：
>   >
>   >> camera0-gc2145-dvp
>   >>
>   >> camera1-gc0310-SPI
>   >>
>   >
>   > AC79最大支持 96Mhz-pclk 输入（考虑稳定性，不建议pclk大于60Mhz），最大像素为1280×720
>   >
> * 调试新的摄像头驱动建议以已经适配的摄像头驱动作为参考调试，硬件电路参照AC79_DevKitBoard原理图，开源板引出了摄像头复用IO
> * 调试摄像头期间建议：准备 1 台逻辑分析仪、1 台示波器
> * 摄像头出图流程：检验摄像头（check ID）->向摄像头发送寄存器配置->主控接收数据处理->推送到屏幕显示
> * dvp和spi摄像头调试过程类似，区别在于硬件接口、接收模式上，请参考适配例程中的摄像头型号驱动进行配置

## 6.12.2. 环境配置方法

> 调试DVP-8bit、1bit、2bit及4bit摄像头建议在 `apps/common/example/video/camera/dvp/main.c` 环境下进行（使用ISC接收）
>
> 调试SPI-1/2bit摄像头可以在 `apps/common/example/video/camera/spi/main.c` 环境下进行（SPI接收）
>
> 选择 `demo/demo_DevKitBoard` 工程运行
>
> `apps/demo/demo_DevKitBoard/include/demo_config.h` 中打开对应的宏（确保其余宏全部关闭）
>
> ```
> //SPI:
> #define CONFIG_SPI_VIDEO_ENABLE
> //DVP（ISC）:
> #define USE_CAMERA_DVP_SHOW_TO_LCD_DEMO
> //如果demo_config.h没有对应的宏，请在对应的main.c中#define以使能
> ```
>
> 即可跑对应的main.c

## 6.12.3. 调试步骤

第一步：摄像头引脚与芯片IO正确连接，板级配置对应IO

> * 若硬件连接与板载摄像头一致，请暂时取下板载摄像头（避免通讯冲突）
> * 板级配置文件路径： `apps/demo/demo_DevKitBoard/board/wl82/DevKitBoard.c` 主要配置IIC、SPI（针对SPI摄像头）及摄像头数据IO、时钟IO
>
> ```
> //*********************************************************************************//
> //                                   IIC模块配置                                    //
> //*********************************************************************************//
> #ifdef CONFIG_IIC_ENABLE
> //板载摄像头默认使用iic0
> SW_IIC_PLATFORM_DATA_BEGIN(sw_iic0_data)//软件iic
>     .clk_pin = IO_PORTH_00,//SCL_IO
>     .dat_pin = IO_PORTH_01,//SDA_IO
>     .sw_iic_delay = 50,
> SW_IIC_PLATFORM_DATA_END()
> #endif
> //**********************************END*******************************************//
>
> //*********************************************************************************//
> //                                   SPI模块配置                                    //
> //*********************************************************************************//
> #ifdef CONFIG_SPI_ENABLE
> //spi/main.c默认使用spi2
> SPI2_PLATFORM_DATA_BEGIN(spi2_data)
>     .clk    = 40000000,
>     .mode   = SPI_STD_MODE,//SPI_1WIRE_MODE（单线模式） SPI_STD_MODE（双线模式） SPI_DUAL_MODE（全双工模式） SPI_QUAD_MODE（四线模式）
>     .attr   = SPI_MODE_SLAVE | SPI_SCLK_L_UPH_SMPH | SPI_UNIDIR_MODE,//从机，CLK高 更新数据高，单向模式
>     .port   = 'C',
> SPI2_PLATFORM_DATA_END()
> #endif
> //**********************************END*******************************************//
>
> //*********************************************************************************//
> //                                摄像头模块配置                                   //
> //*********************************************************************************//
> #ifdef CONFIG_VIDEO_ENABLE
> //*****************************************camera0-ISC0接收(DVP-8bit配置为例)****************************************//
> static const struct camera_platform_data camera0_data = {
>     .xclk_gpio      = IO_PORTH_02,//注意： 如果硬件xclk接到芯片IO，则会占用OUTPUT_CHANNEL1
>     .reset_gpio     = IO_PORTH_03,//复位IO，一般该引脚可以直接接3.3V的高电平（根据数据手册），可不需要特定IO来控制
>     .online_detect  = NULL,//默认NULL即可
>     .pwdn_gpio      = -1,//pwdn引脚可以配合引脚写具体IO如IO_PORTC_04，一般摄像头pwdn引脚直接接地即可，具体参考摄像头数据手册
>     .power_value    = 0,//pwdn引脚使用IO控制时的正常工作pwdn引脚电平
>     .interface      = SEN_INTERFACE0,//SEN_INTERFACE_CSI2,//默认即可
>     .dvp={                           //dvp_IO配置
>         .pclk_gpio   = IO_PORTA_08,
>         .hsync_gpio  = IO_PORTA_09,
>         .vsync_gpio  = IO_PORTA_10,
>         .group_port  = ISC_GROUPA,
>         .data_gpio   = {
>                 IO_PORTA_07,
>                 IO_PORTA_06,
>                 IO_PORTA_05,
>                 IO_PORTA_04,
>                 IO_PORTA_03,
>                 IO_PORTA_02,
>                 IO_PORTA_01,
>                 IO_PORTA_00,
>                 -1,
>                 -1,
>         },
>     }
> };
> static const struct video_subdevice_data video0_subdev_data[] = {//镜头设备参数
>     { VIDEO_TAG_CAMERA, (void *)&camera0_data },
> };
> static const struct video_platform_data video0_data = {//video0参数,设备列表参数需要该参数
>     .data = video0_subdev_data,
>     .num = ARRAY_SIZE(video0_subdev_data),
> };
>
> //*****************************************camera1-SPI接收****************************************//
> static const struct camera_platform_data camera1_data = {
>     .xclk_gpio      = -1,//IO_PORTB_02,//IO_PORTC_08,//IO_PORTC_06,//注意： 如果硬件xclk接到芯片IO，则会占用OUTPUT_CHANNEL1
>     .reset_gpio     = IO_PORTH_03,
>     .online_detect  = NULL,
>     .pwdn_gpio      = -1,
>     .power_value    = 0,
>     .interface      = -1,
>     .dvp={
>         .group_port  = -1,
>         .pclk_gpio   = -1,
>         .hsync_gpio  = -1,
>         .vsync_gpio  = -1,
>         .data_gpio={-1},
>     }
> };
> static const struct video_subdevice_data video1_subdev_data[] = {//镜头设备参数
>     { VIDEO_TAG_CAMERA, (void *)&camera1_data },
> };
> static const struct video_platform_data video1_data = {//video1参数,设备列表参数需要该参数
>     .data = video1_subdev_data,
>     .num = ARRAY_SIZE(video1_subdev_data),
> };
> #endif
> //**********************************END*******************************************//
> ```

第二步：摄像头驱动配置，check摄像头ID，检验是否成功与摄像头通信

> * Device Address、Sensor_ID请在相应摄像头的datasheet中查询
>
> 以gc2145为例：
>
> ```
> //GC2145.C
> #define GC2145_DVP_WRCMD 0x78//Device Address
> #define GC2145_DVP_RDCMD 0x79
>
>
> s32 GC2145_ID_check(void)//check摄像头ID
> {
>     u8 pid = 0x00;
>     u8 ver = 0x00;
>     u8 i ;
>     for (i = 0; i < 3; i++) {
>         rdGC2145Reg(0xf0, &pid);//Sensor_ID_Address
>         rdGC2145Reg(0xf1, &ver);
>     }
>     puts("Sensor PID \n");
>     puts("\n");
>     if (pid != 0x21 || ver != 0x45) { //Sensor_ID_DefaultValue
>         puts("\n----not GC2145_DVP-----\n");
>         return -1;
>     }
>     puts("\n----hello GC2145_DVP-----\n");//打印此行说明成功check到摄像头ID通讯成功
>     return 0;
> }
> ```

第三步：根据摄像头官方驱动例程更改寄存器配置及注册配置

> 以DVP-8bit为例
>
> ```
> //GC2145.C
>
> #define GC2145_DEVP_INPUT_W 1280//摄像头输出分辨率，需要与摄像头实际输出分辨率一致
> #define GC2145_DEVP_INPUT_H 720
>
> static const struct reginfo sensor_init_data[] = { //寄存器配置（配置重点）,主要关注输出接口、输出数据格式、输出线数、输出分辨率和pclk频率等相关寄存器
>     //{Address,Value}                              //sensor数据输出正确是接收正确的前提
>     {0xfe, 0xf0},
>     {0xfe, 0xf0},
>     {0xfe, 0xf0},
>     {0xfc, 0x06},
>     {0xf6, 0x00},
>     {0xf7, 0x1d},
> //省略...
> };
>
> REGISTER_CAMERA(GC2145) = { //ISC接收摄像头注册在REGISTER_CAMERA;SPI接收摄像头注册在REGISTER_CAMERA1
>     .logo                   =   "GC2145",
>     .isp_dev                =   ISP_DEV_NONE, //ISP_DEV_NONE 或 ISP_DEV_0，对应”iic0”设备
>     .in_format              =   SEN_IN_FORMAT_YUYV,//YUV排列顺序，与摄像头输出顺序一致
>     .mbus_type              =   SEN_MBUS_PARALLEL, //数据格式配置，与摄像头输出格式一致，详见isp_dev.h
>     .mbus_config            =   SEN_MBUS_DATA_WIDTH_8B | SEN_MBUS_HSYNC_ACTIVE_HIGH | \
>                                 SEN_MBUS_PCLK_SAMPLE_FALLING | SEN_MBUS_VSYNC_ACTIVE_HIGH, //线数配置及采样配置，详见isp_dev.h
> #if CONFIG_CAMERA_H_V_EXCHANGE
>     .sync_config            =   SEN_MBUS_SYNC0_VSYNC_SYNC1_HSYNC,//WL82/AC791才可以H-V SYNC互换，请留意
> #endif
> //省略...
>     }
> };
> ```

第四步：参考摄像头数据手册修改寄存器配置，根据需求调整输出效果。

> * 输出分辨率的大小：裁剪窗口相关寄存器
> * 输出帧率提高：提高pclk频率、缩小输出数据帧间距行间距
>
> …

## 6.12.4. 适配例程

* ISC接收1bit-SPI-bt656：参考byd20a6.c 1bit 配置

  2bit-SPI-bt656：参考byd20a6.c 2bit 配置

  4bit-SPI-bt656：参考byd20a6.c 4bit 配置

  8bit-DVP：参考GC2145.c 配置(上述第一、三步举例)

使用ISC接收配置举例：

> 1/2/4bit接收时.data_gpio的第一个IO配置必须是最低位的对应IO，以下为4bit：PA0-PA3接收配置举例：
>
> ```
> //DevKitBoard.c
> static const struct camera_platform_data camera0_data = {
>             .xclk_gpio      = IO_PORTH_02,//xclk
>             .reset_gpio     = IO_PORTH_03,
>             .online_detect  = NULL,
>             .pwdn_gpio      = -1,
>             .power_value    = 0,
>             .interface      = SEN_INTERFACE0,
>             .dvp={
>                 .pclk_gpio   = IO_PORTA_08,//pclk
>                 .hsync_gpio  = -1,
>                 .vsync_gpio  = -1,
>                 .group_port  = ISC_GROUPA,
>                 .data_gpio   = {           //接收数据IO配置，按此.data_gpio配置的接收IO为PA0-PA3，对应sensor的D0-D3
>                         IO_PORTA_00,//低
>                         IO_PORTA_01,
>                         IO_PORTA_02,
>                         IO_PORTA_03,//高
>                         -1,
>                         -1,
>                         -1,
>                         -1,
>                         -1,
>                         -1,
>                 },
>             }
>         };
> ```
>
> ```
> //byd20a6.c
>         REGISTER_CAMERA(BYD20a6) = {
>         .isp_dev                        =       ISP_DEV_NONE,
>         .in_format                      =       SEN_IN_FORMAT_YVYU,//与摄像头输出格式一致
>         .mbus_type          =   SEN_MBUS_BT656,//与摄像头输出数据格式一致（此例程1/2/4bit帧协议均为：帧头：ff0000ab，帧尾：ff0000b6，行头：ff000080， 行尾：ff00009d）
>       //.mbus_config        =   SEN_MBUS_DATA_WIDTH_1B | SEN_MBUS_PCLK_SAMPLE_FALLING,//1bit接收|下降沿采样
>       //.mbus_config        =   SEN_MBUS_DATA_WIDTH_2B | SEN_MBUS_PCLK_SAMPLE_FALLING,//2bit接收|下降沿采样
>         .mbus_config        =   SEN_MBUS_DATA_WIDTH_4B | SEN_MBUS_PCLK_SAMPLE_FALLING,//4bit接收|下降沿采样
>
>       //省略...
>     };
> ```

* SPI接收SPI-1bit：参考GC0310.c 1bit 配置

  SPI-2bit：参考GC0310.c 2bit 配置

  板级配置参考上述第一步配置

## 6.12.5. IO反转接收功能配置说明

> .data_gpio按照正常正序配置，在摄像头驱动中的.mbus_config添加 `SEN_MBUS_DATA_WIDTH_REVERSE` 即可
>
> 以下配置为4bit：PA4-PA7、IO反转接收举例，即D0-PA7，D1-PA6，D2-PA5，D3-PA4对应
>
> ```
> //DevKitBoard.c
>
> .data_gpio   = {
>         IO_PORTA_04,       //按照正常正序配置
>         IO_PORTA_05,
>         IO_PORTA_06,
>         IO_PORTA_07,
>         -1,
>         -1,
>         -1,
>         -1,
>         -1,
>         -1,
> },
> ```
>
> ```
> //byd20a6.c
>
> .mbus_config        =   SEN_MBUS_DATA_WIDTH_4B | SEN_MBUS_PCLK_SAMPLE_FALLING | SEN_MBUS_DATA_WIDTH_REVERSE ,//4bit接收|下降沿采样|反转接收
> ```

## 6.12.6. 报错总结

* IIC读取ID不匹配：驱动里面的 iic 设备不对应（“iic0”还是“iic1”），原因为：.isp_dev = xx 不对；

  board.c 的 iic 的 IO 不对；

  摄像头的 xmclk 引脚没有时钟输入，检查 board.c 的 xclk 时钟引脚；

  摄像头的 power_down 引脚的电平没接对，一般正常工作低电平（要看数据手册，看看是低电平还是高电平）；

  摄像头的 reset 引脚的电平是否正确；

  检查Device Address、Sensor_ID配置是否正确。
* 出现 video_ioct: err = 11 或 yuv recv timeout：硬件没有收到时钟，检查 pclk 的有没有时钟输出（示波器看下有没有时钟）；

  pclk频率配置过高，镜头输出时钟不稳定，尝试降低频率；

  接线问题：确定 PCLK 和 DATA 数据正确接对在对应 IO，连接没有断线可能；

  VDDIO电压错误；

  协议不正确：逻辑分析仪 100M 采样率抓数据进行解析帧头帧尾、行头行尾；

  ISC 接收情况下检查帧协议是否正确：帧头：ff0000ab，帧尾：ff0000b6，行头：ff000080， 行尾：ff00009d。
* 报错 isc line err 行出错，原因可能有：初始化 bt656 分辨率和实际摄像头输出的分辨率不一致；

  在 2/4/8bit 模式下，可能因为数据位 IO 反接（isc line err 打印很猛下大部分因为这个原因）；

  协议不符合。
* 报错 isc bandwith err，带宽不够，原因可能有：数据瑕疵；

  性能带宽不足，如果能正常出图可忽略。
* 使用 SPI 接收，出现—->SPI_FSTART = 0x%x , 0x%x ，recv data err , reinit spi camera ：数据头出现问题，用逻辑分析仪解析spi数据是否正确。若数据不正确，检查接线及数据格式配置；若数据正确，spi接收不正确,则大部分原因为：配置的边沿采样不符合，尝试更换边沿采样配置。
* 图像显示异常：数据瑕疵；

  出现大片绿色：YUV格式顺序错误，在摄像头驱动.c中配置YUV格式顺序；

  出现图像条纹、显示分格：采样边沿出错、分辨率设置与镜头实际输出分辨率不一致；

  出现蓝色条纹、噪点：检查电源供电
* 以上报错可能来源于电压不稳定、数据线时钟线毛刺，请确保硬件的稳定性。

# 6.13. AVI回放

* 代码路径 `apps/demo/demo_DevKitBoard/avi_replay.c`
* 使用工程 `apps/demo/demo_DevKitBoard/board/wl82/AC791N_DEMO_DEMO_DEVKITBOARD.CBP`

AVI回放，音视频的匀、变速播放，支持0.25 / 0.5 / 1.0 / 2.0 / 3.0 / 4.0的倍速，同时支持缩略图预览。

## 6.13.1. 接口介绍

```
/*
    func  : 开启回放
    params：
            path：文件路径
    return：0 success；其他 fail
*/
char avi_replay_start(char *path);

/*
    func  : 退出回放
    params：
            无
    return：0 success；其他 fail
*/
char avi_replay_exit(void);

/*
    func  : 暂停/继续回放
    params：
            pause：1 暂停，0 继续
    return：0 success；其他 fail
*/
char avi_replay_pause(u8 pause);

/*
    func  : 变速回放
    params：
            speed：速度
                REPLAY_SPEED_1X,
                REPLAY_SPEED_2X,
                REPLAY_SPEED_3X,
                REPLAY_SPEED_4X,
                REPLAY_SPEED_0_5X,
                REPLAY_SPEED_0_25X,
    return：0 success；其他 fail
*/
char avi_replay_change_speed(enum replay_speed_type speed);

/*
    func  : 暂停/继续回放
    params：
            path  ：文件路径
            idx   : 帧序列
            data  ：数据
            len   ：长度
            width ：长度
            height：高度
    return：0 success；其他 fail
*/
char avi_get_litimg(char *path, int idx, u8 *data, int *len, int width, int height);
```

## 6.13.2. 例程

> 例程详见 `apps/demo/demo_DevKitBoard/avi_replay.c` 例程中，实现响应按键，进行AVI的变速播放、暂停、退出，还有缩略图预览，按键功能说明如下： K1：开启回放； K2：暂停播放； K3：退出回放； K4：快速播放； K5：慢速播放； K6：缩率图预览。

## 6.13.3. 常见问题说明

无
